{"version":3,"sources":["loader.js/loader.js","content-kit-editor/cards/image.js","content-kit-editor/cards/placeholder-image.js","content-kit-editor/commands/base.js","content-kit-editor/commands/bold.js","content-kit-editor/commands/card.js","content-kit-editor/commands/format-block.js","content-kit-editor/commands/heading.js","content-kit-editor/commands/image.js","content-kit-editor/commands/italic.js","content-kit-editor/commands/link.js","content-kit-editor/commands/list.js","content-kit-editor/commands/ordered-list.js","content-kit-editor/commands/quote.js","content-kit-editor/commands/subheading.js","content-kit-editor/commands/text-format.js","content-kit-editor/commands/unordered-list.js","content-kit-editor/editor/editor.js","content-kit-editor/editor/post.js","content-kit-editor/index.js","content-kit-editor/models/card-node.js","content-kit-editor/models/card.js","content-kit-editor/models/cursor.js","content-kit-editor/models/image.js","content-kit-editor/models/marker.js","content-kit-editor/models/markup-section.js","content-kit-editor/models/markup.js","content-kit-editor/models/post-node-builder.js","content-kit-editor/models/post.js","content-kit-editor/models/render-node.js","content-kit-editor/models/render-tree.js","content-kit-editor/parsers/dom.js","content-kit-editor/parsers/mobiledoc.js","content-kit-editor/parsers/post.js","content-kit-editor/parsers/section.js","content-kit-editor/renderers/editor-dom.js","content-kit-editor/renderers/mobiledoc.js","content-kit-editor/utils/array-utils.js","content-kit-editor/utils/compat.js","content-kit-editor/utils/compiler.js","content-kit-editor/utils/dom-utils.js","content-kit-editor/utils/element-map.js","content-kit-editor/utils/element-utils.js","content-kit-editor/utils/event-emitter.js","content-kit-editor/utils/event-listener.js","content-kit-editor/utils/http-utils.js","content-kit-editor/utils/key.js","content-kit-editor/utils/keycodes.js","content-kit-editor/utils/linked-item.js","content-kit-editor/utils/linked-list.js","content-kit-editor/utils/mixin.js","content-kit-editor/utils/selection-utils.js","content-kit-editor/utils/string-utils.js","content-kit-editor/views/embed-intent.js","content-kit-editor/views/message.js","content-kit-editor/views/prompt.js","content-kit-editor/views/reversible-toolbar-button.js","content-kit-editor/views/text-format-toolbar.js","content-kit-editor/views/toolbar-button.js","content-kit-editor/views/toolbar.js","content-kit-editor/views/tooltip.js","content-kit-editor/views/view.js","content-kit-utils/array-utils.js","content-kit-utils/index.js","content-kit-utils/node-utils.js","content-kit-utils/object-utils.js","content-kit-utils/string-utils.js"],"sourcesContent":["var define, requireModule, require, requirejs;\n\n(function() {\n\n  var _isArray;\n  if (!Array.isArray) {\n    _isArray = function (x) {\n      return Object.prototype.toString.call(x) === \"[object Array]\";\n    };\n  } else {\n    _isArray = Array.isArray;\n  }\n\n  var registry = {};\n  var seen = {};\n  var FAILED = false;\n\n  var uuid = 0;\n\n  function tryFinally(tryable, finalizer) {\n    try {\n      return tryable();\n    } finally {\n      finalizer();\n    }\n  }\n\n  function unsupportedModule(length) {\n    throw new Error(\"an unsupported module was defined, expected `define(name, deps, module)` instead got: `\" + length + \"` arguments to define`\");\n  }\n\n  var defaultDeps = ['require', 'exports', 'module'];\n\n  function Module(name, deps, callback, exports) {\n    this.id       = uuid++;\n    this.name     = name;\n    this.deps     = !deps.length && callback.length ? defaultDeps : deps;\n    this.exports  = exports || { };\n    this.callback = callback;\n    this.state    = undefined;\n    this._require  = undefined;\n  }\n\n\n  Module.prototype.makeRequire = function() {\n    var name = this.name;\n\n    return this._require || (this._require = function(dep) {\n      return require(resolve(dep, name));\n    });\n  }\n\n  define = function(name, deps, callback) {\n    if (arguments.length < 2) {\n      unsupportedModule(arguments.length);\n    }\n\n    if (!_isArray(deps)) {\n      callback = deps;\n      deps     =  [];\n    }\n\n    registry[name] = new Module(name, deps, callback);\n  };\n\n  // we don't support all of AMD\n  // define.amd = {};\n  // we will support petals...\n  define.petal = { };\n\n  function Alias(path) {\n    this.name = path;\n  }\n\n  define.alias = function(path) {\n    return new Alias(path);\n  };\n\n  function reify(mod, name, seen) {\n    var deps = mod.deps;\n    var length = deps.length;\n    var reified = new Array(length);\n    var dep;\n    // TODO: new Module\n    // TODO: seen refactor\n    var module = { };\n\n    for (var i = 0, l = length; i < l; i++) {\n      dep = deps[i];\n      if (dep === 'exports') {\n        module.exports = reified[i] = seen;\n      } else if (dep === 'require') {\n        reified[i] = mod.makeRequire();\n      } else if (dep === 'module') {\n        mod.exports = seen;\n        module = reified[i] = mod;\n      } else {\n        reified[i] = requireFrom(resolve(dep, name), name);\n      }\n    }\n\n    return {\n      deps: reified,\n      module: module\n    };\n  }\n\n  function requireFrom(name, origin) {\n    var mod = registry[name];\n    if (!mod) {\n      throw new Error('Could not find module `' + name + '` imported from `' + origin + '`');\n    }\n    return require(name);\n  }\n\n  function missingModule(name) {\n    throw new Error('Could not find module ' + name);\n  }\n  requirejs = require = requireModule = function(name) {\n    var mod = registry[name];\n\n    if (mod && mod.callback instanceof Alias) {\n      mod = registry[mod.callback.name];\n    }\n\n    if (!mod) { missingModule(name); }\n\n    if (mod.state !== FAILED &&\n        seen.hasOwnProperty(name)) {\n      return seen[name];\n    }\n\n    var reified;\n    var module;\n    var loaded = false;\n\n    seen[name] = { }; // placeholder for run-time cycles\n\n    tryFinally(function() {\n      reified = reify(mod, name, seen[name]);\n      module = mod.callback.apply(this, reified.deps);\n      loaded = true;\n    }, function() {\n      if (!loaded) {\n        mod.state = FAILED;\n      }\n    });\n\n    var obj;\n    if (module === undefined && reified.module.exports) {\n      obj = reified.module.exports;\n    } else {\n      obj = seen[name] = module;\n    }\n\n    if (obj !== null &&\n        (typeof obj === 'object' || typeof obj === 'function') &&\n          obj['default'] === undefined) {\n      obj['default'] = obj;\n    }\n\n    return (seen[name] = obj);\n  };\n\n  function resolve(child, name) {\n    if (child.charAt(0) !== '.') { return child; }\n\n    var parts = child.split('/');\n    var nameParts = name.split('/');\n    var parentBase = nameParts.slice(0, -1);\n\n    for (var i = 0, l = parts.length; i < l; i++) {\n      var part = parts[i];\n\n      if (part === '..') {\n        if (parentBase.length === 0) {\n          throw new Error('Cannot access parent module of root');\n        }\n        parentBase.pop();\n      } else if (part === '.') {\n        continue;\n      } else { parentBase.push(part); }\n    }\n\n    return parentBase.join('/');\n  }\n\n  requirejs.entries = requirejs._eak_seen = registry;\n  requirejs.unsee = function(moduleName) {\n    delete seen[moduleName];\n  };\n\n  requirejs.clear = function() {\n    requirejs.entries = requirejs._eak_seen = registry = {};\n    seen = state = {};\n  };\n})();\n","define('content-kit-editor/cards/image', ['exports', 'content-kit-editor/cards/placeholder-image', 'content-kit-editor/utils/http-utils'], function (exports, _contentKitEditorCardsPlaceholderImage, _contentKitEditorUtilsHttpUtils) {\n  'use strict';\n\n  function buildFileInput() {\n    var input = document.createElement('input');\n    input.type = 'file';\n    input.accept = 'image/*';\n    input.classList.add('ck-file-input');\n    document.body.appendChild(input);\n    return input;\n  }\n\n  function buildButton(text) {\n    var button = document.createElement('button');\n    button.innerHTML = text;\n    return button;\n  }\n\n  function upload(imageOptions, fileInput, success, failure) {\n    var uploader = new _contentKitEditorUtilsHttpUtils.FileUploader({\n      url: imageOptions.uploadUrl,\n      maxFileSize: 5000000\n    });\n    uploader.upload({\n      fileInput: fileInput,\n      complete: function complete(response, error) {\n        if (!error && response && response.url) {\n          success({\n            src: response.url\n          });\n        } else {\n          window.alert('There was a problem uploading the image: ' + error);\n          failure();\n        }\n      }\n    });\n  }\n\n  exports['default'] = {\n    name: 'image',\n\n    display: {\n      setup: function setup(element, options, _ref, payload) {\n        var edit = _ref.edit;\n\n        var img = document.createElement('img');\n        img.src = payload.src || _contentKitEditorCardsPlaceholderImage['default'];\n        if (edit) {\n          img.onclick = edit;\n        }\n        element.appendChild(img);\n        return img;\n      },\n      teardown: function teardown(element) {\n        element.parentNode.removeChild(element);\n      }\n    },\n\n    edit: {\n      setup: function setup(element, options, _ref2) {\n        var save = _ref2.save;\n        var cancel = _ref2.cancel;\n\n        var uploadButton = buildButton('Upload');\n        var cancelButton = buildButton('Cancel');\n        cancelButton.onclick = cancel;\n\n        var imageOptions = options.image;\n\n        if (!imageOptions || imageOptions && !imageOptions.uploadUrl) {\n          window.alert('Image card must have `image.uploadUrl` included in cardOptions');\n          cancel();\n          return;\n        }\n\n        var fileInput = buildFileInput();\n        uploadButton.onclick = function () {\n          fileInput.dispatchEvent(new MouseEvent('click', { bubbles: false }));\n        };\n        element.appendChild(uploadButton);\n        element.appendChild(cancelButton);\n\n        fileInput.onchange = function () {\n          try {\n            if (fileInput.files.length === 0) {\n              cancel();\n            }\n            upload(imageOptions, fileInput, save, cancel);\n          } catch (error) {\n            window.alert('There was a starting the upload: ' + error);\n            cancel();\n          }\n        };\n        return [uploadButton, cancelButton, fileInput];\n      },\n      teardown: function teardown(elements) {\n        elements.forEach(function (element) {\n          return element.parentNode.removeChild(element);\n        });\n      }\n    }\n\n  };\n});","define(\"content-kit-editor/cards/placeholder-image\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var placeholderImage = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAMFBMVEXp7vG6vsHm6+63u77Hy868wMPe4+bO09bh5unr8fTR1djAxMfM0NPX3N/c4eTBxcjXRf5TAAACh0lEQVR4nO3b6ZKqMBSFUSQMYZL3f9tbBq/NEEDiqUqOfusn1ZXKbjcQlGQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACC6RkbsGHuabChEtHmiGYfS3EQYM+Sxw/gMQvmcNnYaj6oTDHi73WPn2eqnj9B8zo3TJXcq5uNjXmVff86VwSR3JtryMa1BYqi7S1hJDCVpSigyLcGhJJEwzlCSNtPKrbVhVwsdCfOhH7uuaG3ARV9DwsaOzxt3N1yPqCHhvXytTUz92VDpmE/LLhZwl++R6Sds6sUa/PL6K/2E2fIhw1xdRKefsFolrPc+xNx/N0k/4fpBsdhL2HfeiN+TsDCms8dDpeRyS3P3QDl6Iqaf8L0rTf+80m6Lmn7Ct+4Wxf+/2RY1/YRv3PHz/u+fsCmqgoTnq7Z+8SGviqoh4dnKu1ieqauiakh4/PQ0r6ivqDoSHj0B97eNRVG1JNxV+L4bnxdVecJtRTdFVZ7QU9F1UXUn9FZ0VVRlCav5ob2KLouqKmFjy676u2HsVnRRVFUJq3J+8KCi86IqSthMvyl209Hjijqm3RsqAZ5pNfa5PJ2KelJRjQmr1/r7cfy0ouoSNvOfvbvhvKLaEr4qOin9kTQnrN7LpDZhE/Zmhp6Eq4p+YcKgiipKGFhRRQkDK6ooYfgLbiSMioQkJGF8P5XwHv4O+7AaKiXzaeXh1kMl5AffTUxiKEm/krD94BR8Gdxl1fceSlR58ZhXKbEpyD2amNiBtmrJLTMHL1LF8/rpXkSZXEmz8K8uvAFFNm6Iq0aBLUFOmeCuJ6exrcCmoLpN7kYx891bSAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgh/wDdr8peyRHLogAAAAASUVORK5CYII=\";\n\n  exports[\"default\"] = placeholderImage;\n});","define(\"content-kit-editor/commands/base\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var Command = (function () {\n    function Command() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, Command);\n\n      var command = this;\n      var name = options.name;\n      var prompt = options.prompt;\n      command.name = name;\n      command.button = options.button || name;\n      if (prompt) {\n        command.prompt = prompt;\n      }\n    }\n\n    _createClass(Command, [{\n      key: \"exec\",\n      value: function exec() {/* override in subclass */}\n    }, {\n      key: \"unexec\",\n      value: function unexec() {/* override in subclass */}\n    }]);\n\n    return Command;\n  })();\n\n  exports[\"default\"] = Command;\n});","define('content-kit-editor/commands/bold', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var BoldCommand = (function (_TextFormatCommand) {\n    _inherits(BoldCommand, _TextFormatCommand);\n\n    function BoldCommand(editor) {\n      _classCallCheck(this, BoldCommand);\n\n      _get(Object.getPrototypeOf(BoldCommand.prototype), 'constructor', this).call(this, {\n        name: 'bold',\n        button: '<i class=\"ck-icon-bold\"></i>'\n      });\n      this.editor = editor;\n      var builder = this.editor.builder;\n\n      this.markup = builder.createMarkup('strong');\n    }\n\n    _createClass(BoldCommand, [{\n      key: 'exec',\n      value: function exec() {\n        var _this = this;\n\n        var markerRange = this.editor.cursor.offsets;\n        if (!markerRange.leftRenderNode || !markerRange.rightRenderNode) {\n          return;\n        }\n        var markers = this.editor.run(function (postEditor) {\n          return postEditor.applyMarkupToMarkers(markerRange, _this.markup);\n        });\n        this.editor.selectMarkers(markers);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var _this2 = this;\n\n        var markerRange = this.editor.cursor.offsets;\n        var markers = this.editor.run(function (postEditor) {\n          return postEditor.removeMarkupFromMarkers(markerRange, _this2.markup);\n        });\n        this.editor.selectMarkers(markers);\n      }\n    }, {\n      key: 'isActive',\n      value: function isActive() {\n        var _this3 = this;\n\n        return (0, _contentKitEditorUtilsArrayUtils.any)(this.editor.activeMarkers, function (m) {\n          return m.hasMarkup(_this3.markup);\n        });\n      }\n    }]);\n\n    return BoldCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = BoldCommand;\n});","define('content-kit-editor/commands/card', ['exports', 'content-kit-editor/commands/base'], function (exports, _contentKitEditorCommandsBase) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  function injectCardBlock() /* cardName, cardPayload, editor, index */{\n    throw new Error('Unimplemented: BlockModel and Type.CARD are no longer things');\n  }\n\n  var CardCommand = (function (_Command) {\n    _inherits(CardCommand, _Command);\n\n    function CardCommand() {\n      _classCallCheck(this, CardCommand);\n\n      _get(Object.getPrototypeOf(CardCommand.prototype), 'constructor', this).call(this, {\n        name: 'card',\n        button: '<i>CA</i>'\n      });\n    }\n\n    _createClass(CardCommand, [{\n      key: 'exec',\n      value: function exec() {\n        _get(Object.getPrototypeOf(CardCommand.prototype), 'exec', this).call(this);\n        var editor = this.editor;\n        var currentEditingIndex = editor.getCurrentBlockIndex();\n\n        var cardName = 'pick-color';\n        var cardPayload = { options: ['red', 'blue'] };\n        injectCardBlock(cardName, cardPayload, editor, currentEditingIndex);\n      }\n    }]);\n\n    return CardCommand;\n  })(_contentKitEditorCommandsBase['default']);\n\n  exports['default'] = CardCommand;\n});","define('content-kit-editor/commands/format-block', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var FormatBlockCommand = (function (_TextFormatCommand) {\n    _inherits(FormatBlockCommand, _TextFormatCommand);\n\n    function FormatBlockCommand(editor) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      _classCallCheck(this, FormatBlockCommand);\n\n      _get(Object.getPrototypeOf(FormatBlockCommand.prototype), 'constructor', this).call(this, options);\n      this.editor = editor;\n    }\n\n    _createClass(FormatBlockCommand, [{\n      key: 'isActive',\n      value: function isActive() {\n        var _this = this;\n\n        var editor = this.editor;\n        var activeSections = editor.activeSections;\n\n        return (0, _contentKitEditorUtilsArrayUtils.any)(activeSections, function (section) {\n          return (0, _contentKitEditorUtilsArrayUtils.any)(_this.mappedTags, function (t) {\n            return section.tagName === t;\n          });\n        });\n      }\n    }, {\n      key: 'exec',\n      value: function exec() {\n        var _this2 = this;\n\n        var editor = this.editor;\n        var activeSections = editor.activeSections;\n\n        activeSections.forEach(function (s) {\n          editor.resetSectionMarkers(s);\n          editor.setSectionTagName(s, _this2.tag);\n        });\n\n        editor.rerender();\n        editor.selectSections(activeSections);\n        this.editor.didUpdate();\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var editor = this.editor;\n        var activeSections = editor.activeSections;\n\n        activeSections.forEach(function (s) {\n          editor.resetSectionTagName(s);\n        });\n\n        editor.rerender();\n        editor.selectSections(activeSections);\n        this.editor.didUpdate();\n      }\n    }]);\n\n    return FormatBlockCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = FormatBlockCommand;\n});","define('content-kit-editor/commands/heading', ['exports', 'content-kit-editor/commands/format-block'], function (exports, _contentKitEditorCommandsFormatBlock) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var HeadingCommand = (function (_FormatBlockCommand) {\n    _inherits(HeadingCommand, _FormatBlockCommand);\n\n    function HeadingCommand(editor) {\n      _classCallCheck(this, HeadingCommand);\n\n      var options = {\n        name: 'heading',\n        tag: 'h2',\n        button: '<i class=\"ck-icon-heading\"></i>2'\n      };\n      _get(Object.getPrototypeOf(HeadingCommand.prototype), 'constructor', this).call(this, editor, options);\n    }\n\n    return HeadingCommand;\n  })(_contentKitEditorCommandsFormatBlock['default']);\n\n  exports['default'] = HeadingCommand;\n});","define('content-kit-editor/commands/image', ['exports', 'content-kit-editor/commands/base'], function (exports, _contentKitEditorCommandsBase) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ImageCommand = (function (_Command) {\n    _inherits(ImageCommand, _Command);\n\n    function ImageCommand() {\n      _classCallCheck(this, ImageCommand);\n\n      _get(Object.getPrototypeOf(ImageCommand.prototype), 'constructor', this).call(this, {\n        name: 'image',\n        button: '<i class=\"ck-icon-image\"></i>'\n      });\n    }\n\n    _createClass(ImageCommand, [{\n      key: 'exec',\n      value: function exec() {\n        var headMarker = this.editor.cursor.offsets.headMarker;\n\n        var beforeSection = headMarker.section;\n        var afterSection = beforeSection.next;\n        var section = this.editor.builder.createCardSection('image');\n\n        this.editor.run(function (postEditor) {\n          if (beforeSection.isBlank) {\n            postEditor.removeSection(beforeSection);\n          }\n          postEditor.insertSectionBefore(section, afterSection);\n        });\n      }\n    }]);\n\n    return ImageCommand;\n  })(_contentKitEditorCommandsBase['default']);\n\n  exports['default'] = ImageCommand;\n});","define('content-kit-editor/commands/italic', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ItalicCommand = (function (_TextFormatCommand) {\n    _inherits(ItalicCommand, _TextFormatCommand);\n\n    function ItalicCommand(editor) {\n      _classCallCheck(this, ItalicCommand);\n\n      _get(Object.getPrototypeOf(ItalicCommand.prototype), 'constructor', this).call(this, {\n        name: 'italic',\n        button: '<i class=\"ck-icon-italic\"></i>'\n      });\n      this.editor = editor;\n      var builder = this.editor.builder;\n\n      this.markup = builder.createMarkup('em');\n    }\n\n    _createClass(ItalicCommand, [{\n      key: 'exec',\n      value: function exec() {\n        var _this = this;\n\n        var markerRange = this.editor.cursor.offsets;\n        if (!markerRange.leftRenderNode || !markerRange.rightRenderNode) {\n          return;\n        }\n        var markers = this.editor.run(function (postEditor) {\n          return postEditor.applyMarkupToMarkers(markerRange, _this.markup);\n        });\n        this.editor.selectMarkers(markers);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var _this2 = this;\n\n        var markerRange = this.editor.cursor.offsets;\n        var markers = this.editor.run(function (postEditor) {\n          return postEditor.removeMarkupFromMarkers(markerRange, _this2.markup);\n        });\n        this.editor.selectMarkers(markers);\n      }\n    }, {\n      key: 'isActive',\n      value: function isActive() {\n        var _this3 = this;\n\n        return (0, _contentKitEditorUtilsArrayUtils.any)(this.editor.activeMarkers, function (m) {\n          return m.hasMarkup(_this3.markup);\n        });\n      }\n    }]);\n\n    return ItalicCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = ItalicCommand;\n});","define('content-kit-editor/commands/link', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/views/prompt', 'content-kit-editor/utils/selection-utils', 'content-kit-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorViewsPrompt, _contentKitEditorUtilsSelectionUtils, _contentKitUtils) {\n  'use strict';\n\n  var RegExpHttp = /^https?:\\/\\//i;\n\n  function LinkCommand() {\n    _contentKitEditorCommandsTextFormat['default'].call(this, {\n      name: 'link',\n      tag: 'a',\n      action: 'createLink',\n      removeAction: 'unlink',\n      button: '<i class=\"ck-icon-link\"></i>',\n      prompt: new _contentKitEditorViewsPrompt['default']({\n        command: this,\n        placeholder: 'Enter a url, press return...'\n      })\n    });\n  }\n  (0, _contentKitUtils.inherit)(LinkCommand, _contentKitEditorCommandsTextFormat['default']);\n\n  LinkCommand.prototype.exec = function (url) {\n    if (!url) {\n      return LinkCommand._super.prototype.unexec.call(this);\n    }\n\n    if (this.tag === (0, _contentKitEditorUtilsSelectionUtils.getSelectionTagName)()) {\n      this.unexec();\n    } else {\n      if (!RegExpHttp.test(url)) {\n        url = 'http://' + url;\n      }\n      LinkCommand._super.prototype.exec.call(this, url);\n    }\n  };\n\n  exports['default'] = LinkCommand;\n});","define('content-kit-editor/commands/list', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/utils/selection-utils', 'content-kit-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorUtilsSelectionUtils, _contentKitUtils) {\n  'use strict';\n\n  function ListCommand(options) {\n    _contentKitEditorCommandsTextFormat['default'].call(this, options);\n  }\n  (0, _contentKitUtils.inherit)(ListCommand, _contentKitEditorCommandsTextFormat['default']);\n\n  ListCommand.prototype.exec = function () {\n    ListCommand._super.prototype.exec.call(this);\n\n    // After creation, lists need to be unwrapped\n    // TODO: eventually can remove this when direct model manipulation is ready\n    var listElement = (0, _contentKitEditorUtilsSelectionUtils.getSelectionBlockElement)();\n    var wrapperNode = listElement.parentNode;\n    if (wrapperNode.firstChild === listElement) {\n      var editorNode = wrapperNode.parentNode;\n      editorNode.insertBefore(listElement, wrapperNode);\n      editorNode.removeChild(wrapperNode);\n      (0, _contentKitEditorUtilsSelectionUtils.selectNode)(listElement);\n    }\n  };\n\n  ListCommand.prototype.checkAutoFormat = function (node) {\n    // Creates unordered lists when node starts with '- '\n    // or ordered list if node starts with '1. '\n    var regex = this.autoFormatRegex,\n        text;\n    if (node && regex) {\n      text = node.textContent;\n      if ('li' !== (0, _contentKitEditorUtilsSelectionUtils.getSelectionTagName)() && regex.test(text)) {\n        this.exec();\n        window.getSelection().anchorNode.textContent = text.replace(regex, '');\n        return true;\n      }\n    }\n    return false;\n  };\n\n  exports['default'] = ListCommand;\n});","define('content-kit-editor/commands/ordered-list', ['exports', 'content-kit-editor/commands/list', 'content-kit-utils'], function (exports, _contentKitEditorCommandsList, _contentKitUtils) {\n  'use strict';\n\n  function OrderedListCommand() {\n    _contentKitEditorCommandsList['default'].call(this, {\n      name: 'ordered list',\n      tag: 'ol',\n      action: 'insertOrderedList'\n    });\n  }\n  (0, _contentKitUtils.inherit)(OrderedListCommand, _contentKitEditorCommandsList['default']);\n\n  OrderedListCommand.prototype.autoFormatRegex = /^1\\.\\s/;\n\n  exports['default'] = OrderedListCommand;\n});","define('content-kit-editor/commands/quote', ['exports', 'content-kit-editor/commands/format-block'], function (exports, _contentKitEditorCommandsFormatBlock) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var QuoteCommand = (function (_FormatBlockCommand) {\n    _inherits(QuoteCommand, _FormatBlockCommand);\n\n    function QuoteCommand(editor) {\n      _classCallCheck(this, QuoteCommand);\n\n      _get(Object.getPrototypeOf(QuoteCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'quote',\n        tag: 'blockquote',\n        button: '<i class=\"ck-icon-quote\"></i>'\n      });\n    }\n\n    return QuoteCommand;\n  })(_contentKitEditorCommandsFormatBlock['default']);\n\n  exports['default'] = QuoteCommand;\n});","define('content-kit-editor/commands/subheading', ['exports', 'content-kit-editor/commands/format-block'], function (exports, _contentKitEditorCommandsFormatBlock) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var SubheadingCommand = (function (_FormatBlockCommand) {\n    _inherits(SubheadingCommand, _FormatBlockCommand);\n\n    function SubheadingCommand(editor) {\n      _classCallCheck(this, SubheadingCommand);\n\n      _get(Object.getPrototypeOf(SubheadingCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'subheading',\n        tag: 'h3',\n        button: '<i class=\"ck-icon-heading\"></i>3'\n      });\n    }\n\n    return SubheadingCommand;\n  })(_contentKitEditorCommandsFormatBlock['default']);\n\n  exports['default'] = SubheadingCommand;\n});","define('content-kit-editor/commands/text-format', ['exports', 'content-kit-editor/commands/base'], function (exports, _contentKitEditorCommandsBase) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var TextFormatCommand = (function (_Command) {\n    _inherits(TextFormatCommand, _Command);\n\n    function TextFormatCommand() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, TextFormatCommand);\n\n      _get(Object.getPrototypeOf(TextFormatCommand.prototype), 'constructor', this).call(this, options);\n\n      this.tag = options.tag;\n      this.mappedTags = options.mappedTags || [];\n      if (this.tag) {\n        this.mappedTags.push(this.tag);\n      }\n      this.action = options.action || this.name;\n      this.removeAction = options.removeAction || this.action;\n    }\n\n    _createClass(TextFormatCommand, [{\n      key: 'exec',\n      value: function exec(value) {\n        document.execCommand(this.action, false, value || null);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec(value) {\n        document.execCommand(this.removeAction, false, value || null);\n      }\n    }]);\n\n    return TextFormatCommand;\n  })(_contentKitEditorCommandsBase['default']);\n\n  exports['default'] = TextFormatCommand;\n});","define('content-kit-editor/commands/unordered-list', ['exports', 'content-kit-editor/commands/list', 'content-kit-utils'], function (exports, _contentKitEditorCommandsList, _contentKitUtils) {\n  'use strict';\n\n  function UnorderedListCommand() {\n    _contentKitEditorCommandsList['default'].call(this, {\n      name: 'list',\n      tag: 'ul',\n      action: 'insertUnorderedList'\n    });\n  }\n  (0, _contentKitUtils.inherit)(UnorderedListCommand, _contentKitEditorCommandsList['default']);\n\n  UnorderedListCommand.prototype.autoFormatRegex = /^[-*]\\s/;\n\n  exports['default'] = UnorderedListCommand;\n});","define('content-kit-editor/editor/editor', ['exports', 'content-kit-editor/views/text-format-toolbar', 'content-kit-editor/views/tooltip', 'content-kit-editor/views/embed-intent', 'content-kit-editor/editor/post', 'content-kit-editor/views/reversible-toolbar-button', 'content-kit-editor/commands/bold', 'content-kit-editor/commands/italic', 'content-kit-editor/commands/link', 'content-kit-editor/commands/quote', 'content-kit-editor/commands/heading', 'content-kit-editor/commands/subheading', 'content-kit-editor/commands/unordered-list', 'content-kit-editor/commands/ordered-list', 'content-kit-editor/commands/image', 'content-kit-editor/commands/card', 'content-kit-editor/cards/image', 'content-kit-editor/utils/key', 'content-kit-editor/utils/event-emitter', 'content-kit-editor/parsers/mobiledoc', 'content-kit-editor/parsers/post', 'content-kit-editor/parsers/dom', 'content-kit-editor/renderers/editor-dom', 'content-kit-editor/models/render-tree', 'content-kit-editor/renderers/mobiledoc', 'content-kit-utils', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/element-utils', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener', 'content-kit-editor/models/cursor', 'content-kit-editor/models/post-node-builder'], function (exports, _contentKitEditorViewsTextFormatToolbar, _contentKitEditorViewsTooltip, _contentKitEditorViewsEmbedIntent, _contentKitEditorEditorPost, _contentKitEditorViewsReversibleToolbarButton, _contentKitEditorCommandsBold, _contentKitEditorCommandsItalic, _contentKitEditorCommandsLink, _contentKitEditorCommandsQuote, _contentKitEditorCommandsHeading, _contentKitEditorCommandsSubheading, _contentKitEditorCommandsUnorderedList, _contentKitEditorCommandsOrderedList, _contentKitEditorCommandsImage, _contentKitEditorCommandsCard, _contentKitEditorCardsImage, _contentKitEditorUtilsKey, _contentKitEditorUtilsEventEmitter, _contentKitEditorParsersMobiledoc, _contentKitEditorParsersPost, _contentKitEditorParsersDom, _contentKitEditorRenderersEditorDom, _contentKitEditorModelsRenderTree, _contentKitEditorRenderersMobiledoc, _contentKitUtils, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsElementUtils, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener, _contentKitEditorModelsCursor, _contentKitEditorModelsPostNodeBuilder) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var EDITOR_ELEMENT_CLASS_NAME = 'ck-editor';\n\n  exports.EDITOR_ELEMENT_CLASS_NAME = EDITOR_ELEMENT_CLASS_NAME;\n  var defaults = {\n    placeholder: 'Write here...',\n    spellcheck: true,\n    autofocus: true,\n    post: null,\n    // FIXME PhantomJS has 'ontouchstart' in window,\n    // causing the stickyToolbar to accidentally be auto-activated\n    // in tests\n    stickyToolbar: false, // !!('ontouchstart' in window),\n    textFormatCommands: [new _contentKitEditorCommandsLink['default']()],\n    embedCommands: [new _contentKitEditorCommandsImage['default'](), new _contentKitEditorCommandsCard['default']()],\n    autoTypingCommands: [new _contentKitEditorCommandsUnorderedList['default'](), new _contentKitEditorCommandsOrderedList['default']()],\n    cards: [],\n    cardOptions: {},\n    unknownCardHandler: function unknownCardHandler() {\n      throw new Error('Unknown card encountered');\n    },\n    mobiledoc: null,\n    html: null\n  };\n\n  function bindContentEditableTypingListeners(editor) {\n    // On 'PASTE' sanitize and insert\n    editor.addEventListener(editor.element, 'paste', function (e) {\n      var data = e.clipboardData;\n      var pastedHTML = data && data.getData && data.getData('text/html');\n      var sanitizedHTML = pastedHTML && editor._renderer.rerender(pastedHTML);\n      if (sanitizedHTML) {\n        document.execCommand('insertHTML', false, sanitizedHTML);\n        editor.rerender();\n      }\n      e.preventDefault();\n      return false;\n    });\n  }\n\n  function bindAutoTypingListeners(editor) {\n    // Watch typing patterns for auto format commands (e.g. lists '- ', '1. ')\n    editor.addEventListener(editor.element, 'keyup', function (e) {\n      var commands = editor.autoTypingCommands;\n      var count = commands && commands.length;\n      var selection, i;\n\n      if (count) {\n        selection = window.getSelection();\n        for (i = 0; i < count; i++) {\n          if (commands[i].checkAutoFormat(selection.anchorNode)) {\n            e.stopPropagation();\n            return;\n          }\n        }\n      }\n    });\n  }\n\n  function bindSelectionEvent(editor) {\n    /**\n     * The following events/sequences can create a selection and are handled:\n     *  * mouseup -- can happen anywhere in document, must wait until next tick to read selection\n     *  * keyup when key is a movement key and shift is pressed -- in editor element\n     *  * keyup when key combo was cmd-A (alt-A) aka \"select all\"\n     *  * keyup when key combo was cmd-Z (browser restores selection if there was one)\n     *\n     * These cases can create a selection and are not handled:\n     *  * ctrl-click -> context menu -> click \"select all\"\n     */\n\n    var toggleSelection = function toggleSelection() {\n      return editor.cursor.hasSelection() ? editor.hasSelection() : editor.hasNoSelection();\n    };\n\n    // mouseup will not properly report a selection until the next tick, so add a timeout:\n    var mouseupHandler = function mouseupHandler() {\n      return setTimeout(toggleSelection);\n    };\n    editor.addEventListener(document, 'mouseup', mouseupHandler);\n\n    var keyupHandler = toggleSelection;\n    editor.addEventListener(editor.element, 'keyup', keyupHandler);\n  }\n\n  function bindKeyListeners(editor) {\n    if (!editor.isEditable) {\n      return;\n    }\n    editor.addEventListener(document, 'keyup', function (event) {\n      var key = _contentKitEditorUtilsKey['default'].fromEvent(event);\n      if (key.isEscape()) {\n        editor.trigger('escapeKey');\n      }\n    });\n\n    editor.addEventListener(document, 'keydown', function (event) {\n      if (!editor.isEditable) {\n        return;\n      }\n      var key = _contentKitEditorUtilsKey['default'].fromEvent(event);\n\n      if (key.isDelete()) {\n        editor.handleDeletion(event);\n        event.preventDefault();\n      } else if (key.isEnter()) {\n        editor.handleNewline(event);\n      } else if (key.isPrintable()) {\n        if (editor.cursor.hasSelection()) {\n          var offsets = editor.cursor.offsets;\n          editor.run(function (postEditor) {\n            postEditor.deleteRange(editor.cursor.offsets);\n          });\n          editor.cursor.moveToSection(offsets.headSection, offsets.headSectionOffset);\n        }\n      }\n    });\n  }\n\n  function bindDragAndDrop(editor) {\n    // TODO. For now, just prevent redirect when dropping something on the page\n    editor.addEventListener(window, 'dragover', function (e) {\n      e.preventDefault(); // prevents showing cursor where to drop\n    });\n    editor.addEventListener(window, 'drop', function (e) {\n      e.preventDefault(); // prevent page from redirecting\n    });\n  }\n\n  function initEmbedCommands(editor) {\n    var commands = editor.embedCommands;\n    if (commands) {\n      editor.addView(new _contentKitEditorViewsEmbedIntent['default']({\n        editorContext: editor,\n        commands: commands,\n        rootElement: editor.element\n      }));\n    }\n  }\n\n  function makeButtons(editor) {\n    var headingCommand = new _contentKitEditorCommandsHeading['default'](editor);\n    var headingButton = new _contentKitEditorViewsReversibleToolbarButton['default'](headingCommand, editor);\n\n    var subheadingCommand = new _contentKitEditorCommandsSubheading['default'](editor);\n    var subheadingButton = new _contentKitEditorViewsReversibleToolbarButton['default'](subheadingCommand, editor);\n\n    var quoteCommand = new _contentKitEditorCommandsQuote['default'](editor);\n    var quoteButton = new _contentKitEditorViewsReversibleToolbarButton['default'](quoteCommand, editor);\n\n    var boldCommand = new _contentKitEditorCommandsBold['default'](editor);\n    var boldButton = new _contentKitEditorViewsReversibleToolbarButton['default'](boldCommand, editor);\n\n    var italicCommand = new _contentKitEditorCommandsItalic['default'](editor);\n    var italicButton = new _contentKitEditorViewsReversibleToolbarButton['default'](italicCommand, editor);\n\n    return [headingButton, subheadingButton, quoteButton, boldButton, italicButton];\n  }\n\n  /**\n   * @class Editor\n   * An individual Editor\n   * @param element `Element` node\n   * @param options hash of options\n   */\n\n  var Editor = (function () {\n    function Editor() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, Editor);\n\n      if (!options || options.nodeType) {\n        throw new Error('editor create accepts an options object. For legacy usage passing an element for the first argument, consider the `html` option for loading DOM or HTML posts. For other cases call `editor.render(domNode)` after editor creation');\n      }\n      this._elementListeners = [];\n      this._views = [];\n      this.isEditable = null;\n\n      this.builder = new _contentKitEditorModelsPostNodeBuilder['default']();\n\n      // FIXME: This should merge onto this.options\n      (0, _contentKitUtils.mergeWithOptions)(this, defaults, options);\n\n      this.cards.push(_contentKitEditorCardsImage['default']);\n\n      this._parser = new _contentKitEditorParsersPost['default'](this.builder);\n      this._renderer = new _contentKitEditorRenderersEditorDom['default'](this, this.cards, this.unknownCardHandler, this.cardOptions);\n\n      if (this.mobiledoc) {\n        this.post = new _contentKitEditorParsersMobiledoc['default'](this.builder).parse(this.mobiledoc);\n      } else if (this.html) {\n        if (typeof this.html === 'string') {\n          this.html = (0, _contentKitEditorUtilsDomUtils.parseHTML)(this.html);\n        }\n        this.post = new _contentKitEditorParsersDom['default'](this.builder).parse(this.html);\n      } else {\n        this.post = this.builder.createBlankPost();\n      }\n\n      this._renderTree = this.prepareRenderTree(this.post);\n    }\n\n    _createClass(Editor, [{\n      key: 'addView',\n      value: function addView(view) {\n        this._views.push(view);\n      }\n    }, {\n      key: 'prepareRenderTree',\n      value: function prepareRenderTree(post) {\n        var renderTree = new _contentKitEditorModelsRenderTree['default']();\n        var node = renderTree.buildRenderNode(post);\n        renderTree.node = node;\n        return renderTree;\n      }\n    }, {\n      key: 'rerender',\n      value: function rerender() {\n        var postRenderNode = this.post.renderNode;\n\n        // if we haven't rendered this post's renderNode before, mark it dirty\n        if (!postRenderNode.element) {\n          if (!this.element) {\n            throw new Error('Initial call to `render` must happen before `rerender` can be called.');\n          }\n          postRenderNode.element = this.element;\n          postRenderNode.markDirty();\n        }\n\n        this._renderer.render(this._renderTree);\n      }\n    }, {\n      key: 'render',\n      value: function render(element) {\n        var _this = this;\n\n        if (this.element) {\n          throw new Error('Cannot render an editor twice. Use `rerender` to update the rendering of an existing editor instance');\n        }\n\n        this.element = element;\n\n        this.applyClassName(EDITOR_ELEMENT_CLASS_NAME);\n        this.applyPlaceholder();\n\n        element.spellcheck = this.spellcheck;\n\n        if (this.isEditable === null) {\n          this.enableEditing();\n        }\n\n        (0, _contentKitEditorUtilsDomUtils.clearChildNodes)(element);\n\n        bindContentEditableTypingListeners(this);\n        bindAutoTypingListeners(this);\n        bindDragAndDrop(this);\n        bindSelectionEvent(this);\n        bindKeyListeners(this);\n        this.addEventListener(element, 'input', function () {\n          return _this.handleInput();\n        });\n        initEmbedCommands(this);\n\n        this.addView(new _contentKitEditorViewsTextFormatToolbar['default']({\n          editor: this,\n          rootElement: element,\n          // FIXME -- eventually all the commands should migrate to being buttons\n          // that can be added\n          commands: this.textFormatCommands,\n          buttons: makeButtons(this),\n          sticky: this.stickyToolbar\n        }));\n\n        this.addView(new _contentKitEditorViewsTooltip['default']({\n          rootElement: element,\n          showForTag: 'a'\n        }));\n\n        this.rerender();\n\n        if (this.autofocus) {\n          element.focus();\n        }\n      }\n    }, {\n      key: 'handleDeletion',\n      value: function handleDeletion(event) {\n        event.preventDefault();\n\n        var offsets = this.cursor.offsets;\n\n        if (this.cursor.hasSelection()) {\n          this.run(function (postEditor) {\n            postEditor.deleteRange(offsets);\n          });\n          this.cursor.moveToSection(offsets.headSection, offsets.headSectionOffset);\n        } else {\n          var results = this.run(function (postEditor) {\n            var headMarker = offsets.headMarker;\n            var headOffset = offsets.headOffset;\n\n            var key = _contentKitEditorUtilsKey['default'].fromEvent(event);\n\n            var deletePosition = { marker: headMarker, offset: headOffset },\n                direction = key.direction;\n            return postEditor.deleteFrom(deletePosition, direction);\n          });\n          this.cursor.moveToMarker(results.currentMarker, results.currentOffset);\n        }\n      }\n    }, {\n      key: 'handleNewline',\n      value: function handleNewline(event) {\n        var _this2 = this;\n\n        var offsets = this.cursor.offsets;\n\n        // if there's no left/right nodes, we are probably not in the editor,\n        // or we have selected some non-marker thing like a card\n        if (!offsets.leftRenderNode || !offsets.rightRenderNode) {\n          return;\n        }\n\n        event.preventDefault();\n\n        var cursorSection = undefined;\n        this.run(function (postEditor) {\n          if (_this2.cursor.hasSelection()) {\n            postEditor.deleteRange(offsets);\n          }\n          cursorSection = postEditor.splitSection(offsets)[1];\n        });\n        this.cursor.moveToSection(cursorSection);\n      }\n    }, {\n      key: 'hasSelection',\n      value: function hasSelection() {\n        if (!this._hasSelection) {\n          this.trigger('selection');\n        } else {\n          this.trigger('selectionUpdated');\n        }\n        this._hasSelection = true;\n      }\n    }, {\n      key: 'hasNoSelection',\n      value: function hasNoSelection() {\n        if (this._hasSelection) {\n          this.trigger('selectionEnded');\n        }\n        this._hasSelection = false;\n      }\n    }, {\n      key: 'cancelSelection',\n      value: function cancelSelection() {\n        if (this._hasSelection) {\n          // FIXME perhaps restore cursor position to end of the selection?\n          this.cursor.clearSelection();\n          this.hasNoSelection();\n        }\n      }\n    }, {\n      key: 'didUpdate',\n      value: function didUpdate() {\n        this.trigger('update');\n      }\n    }, {\n      key: 'selectSections',\n      value: function selectSections(sections) {\n        this.cursor.selectSections(sections);\n        this.hasSelection();\n      }\n    }, {\n      key: 'selectMarkers',\n      value: function selectMarkers(markers) {\n        this.cursor.selectMarkers(markers);\n        this.hasSelection();\n      }\n    }, {\n      key: 'applyClassName',\n      value: function applyClassName(className) {\n        (0, _contentKitEditorUtilsDomUtils.addClassName)(this.element, className);\n      }\n    }, {\n      key: 'applyPlaceholder',\n      value: function applyPlaceholder() {\n        var placeholder = this.placeholder;\n        var existingPlaceholder = (0, _contentKitEditorUtilsElementUtils.getData)(this.element, 'placeholder');\n\n        if (placeholder && !existingPlaceholder) {\n          (0, _contentKitEditorUtilsElementUtils.setData)(this.element, 'placeholder', placeholder);\n        }\n      }\n\n      /**\n       * types of input to handle:\n       *   * delete from beginning of section\n       *       joins 2 sections\n       *   * delete when multiple sections selected\n       *       removes wholly-selected sections,\n       *       joins the partially-selected sections\n       *   * hit enter (handled by capturing 'keydown' for enter key and `handleNewline`)\n       *       if anything is selected, delete it first, then\n       *       split the current marker at the cursor position,\n       *         schedule removal of every marker after the split,\n       *         create new section, append it to post\n       *         append the after-split markers onto the new section\n       *         rerender -- this should render the new section at the appropriate spot\n       */\n    }, {\n      key: 'handleInput',\n      value: function handleInput() {\n        this.reparse();\n        this.trigger('update');\n      }\n    }, {\n      key: 'reparse',\n      value: function reparse() {\n        var _this3 = this;\n\n        // find added sections\n        var sectionsInDOM = [];\n        var newSections = [];\n        var previousSection = undefined;\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(this.element.childNodes, function (node) {\n          // FIXME: this is kind of slow\n          var sectionRenderNode = (0, _contentKitEditorUtilsArrayUtils.detect)(_this3._renderTree.node.childNodes, function (renderNode) {\n            return renderNode.element === node;\n          });\n          if (!sectionRenderNode) {\n            var _section = _this3._parser.parseSection(node);\n            newSections.push(_section);\n\n            // create a clean \"already-rendered\" node to represent the fact that\n            // this (new) section is already in DOM\n            sectionRenderNode = _this3._renderTree.buildRenderNode(_section);\n            sectionRenderNode.element = node;\n            sectionRenderNode.markClean();\n\n            var previousSectionRenderNode = previousSection && previousSection.renderNode;\n            _this3.post.sections.insertAfter(_section, previousSection);\n            _this3._renderTree.node.childNodes.insertAfter(sectionRenderNode, previousSectionRenderNode);\n          }\n\n          // may cause duplicates to be included\n          var section = sectionRenderNode.postNode;\n          sectionsInDOM.push(section);\n          previousSection = section;\n        });\n\n        // remove deleted nodes\n        var deletedSections = [];\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(this.post.sections, function (section) {\n          if (!section.renderNode) {\n            throw new Error('All sections are expected to have a renderNode');\n          }\n\n          if (sectionsInDOM.indexOf(section) === -1) {\n            deletedSections.push(section);\n          }\n        });\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(deletedSections, function (s) {\n          return s.renderNode.scheduleForRemoval();\n        });\n\n        // reparse the new section(s) with the cursor\n        // to ensure that we catch any changed html that the browser might have\n        // added\n        var sectionsWithCursor = this.cursor.activeSections;\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(sectionsWithCursor, function (section) {\n          if (newSections.indexOf(section) === -1) {\n            _this3.reparseSection(section);\n          }\n        });\n\n        var _cursor$sectionOffsets = this.cursor.sectionOffsets;\n        var headSection = _cursor$sectionOffsets.headSection;\n        var headSectionOffset = _cursor$sectionOffsets.headSectionOffset;\n\n        // The cursor will lose its textNode if we have reparsed (and thus will rerender, below)\n        // its section. Ensure the cursor is placed where it should be after render.\n        //\n        // New sections are presumed clean, and thus do not get rerendered and lose\n        // their cursor position.\n        var resetCursor = sectionsWithCursor.indexOf(headSection) !== -1;\n\n        this.rerender();\n        this.trigger('update');\n\n        if (resetCursor) {\n          this.cursor.moveToSection(headSection, headSectionOffset);\n        }\n      }\n\n      /*\n       * Returns the active sections. If the cursor selection is collapsed this will be\n       * an array of 1 item. Else will return an array containing each section that is either\n       * wholly or partly contained by the cursor selection.\n       *\n       * @return {array} The sections from the cursor's selection start to the selection end\n       */\n    }, {\n      key: 'resetSectionMarkers',\n\n      /*\n       * Clear the markups from each of the section's markers\n       */\n      value: function resetSectionMarkers(section) {\n        section.markers.forEach(function (m) {\n          m.clearMarkups();\n          m.renderNode.markDirty();\n        });\n      }\n\n      /*\n       * Change the tag name for the given section\n       */\n    }, {\n      key: 'setSectionTagName',\n      value: function setSectionTagName(section, tagName) {\n        section.setTagName(tagName);\n        section.renderNode.markDirty();\n      }\n    }, {\n      key: 'resetSectionTagName',\n      value: function resetSectionTagName(section) {\n        section.resetTagName();\n        section.renderNode.markDirty();\n      }\n    }, {\n      key: 'reparseSection',\n      value: function reparseSection(section) {\n        this._parser.reparseSection(section, this._renderTree);\n      }\n    }, {\n      key: 'serialize',\n      value: function serialize() {\n        return _contentKitEditorRenderersMobiledoc['default'].render(this.post);\n      }\n    }, {\n      key: 'removeAllViews',\n      value: function removeAllViews() {\n        this._views.forEach(function (v) {\n          return v.destroy();\n        });\n        this._views = [];\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this._isDestroyed = true;\n        this.removeAllEventListeners();\n        this.removeAllViews();\n      }\n\n      /**\n       * Keep the user from directly editing the post. Modification via the\n       * programmatic API is still permitted.\n       *\n       * @method disableEditing\n       * @return undefined\n       * @public\n       */\n    }, {\n      key: 'disableEditing',\n      value: function disableEditing() {\n        this.isEditable = false;\n        this.element.setAttribute('contentEditable', false);\n      }\n\n      /**\n       * Allow the user to directly interact with editing a post via a cursor.\n       *\n       * @method enableEditing\n       * @return undefined\n       * @public\n       */\n    }, {\n      key: 'enableEditing',\n      value: function enableEditing() {\n        this.isEditable = true;\n        this.element.setAttribute('contentEditable', true);\n      }\n\n      /**\n       * Run a new post editing session. Yields a block with a new `postEditor`\n       * instance. This instance can be used to interact with the post abstract,\n       * and defers rendering until the end of all changes.\n       *\n       * Usage:\n       *\n       *     let markerRange = this.cursor.offsets;\n       *     editor.run((postEditor) => {\n       *       postEditor.deleteRange(markerRange);\n       *       // editing surface not updated yet\n       *       postEditor.schedule(() => {\n       *         console.log('logs during rerender flush');\n       *       });\n       *       // logging not yet flushed\n       *     });\n       *     // editing surface now updated.\n       *     // logging now flushed\n       *\n       * The return value of `run` is whatever was returned from the callback.\n       *\n       * @method run\n       * @param {Function} callback Function to handle post editing with, provided the `postEditor` as an argument.\n       * @return {} Whatever the return value of `callback` is.\n       * @public\n       */\n    }, {\n      key: 'run',\n      value: function run(callback) {\n        var postEditor = new _contentKitEditorEditorPost['default'](this);\n        var result = callback(postEditor);\n        postEditor.complete();\n        return result;\n      }\n    }, {\n      key: 'cursor',\n      get: function get() {\n        return new _contentKitEditorModelsCursor['default'](this);\n      }\n    }, {\n      key: 'activeSections',\n      get: function get() {\n        return this.cursor.activeSections;\n      }\n    }, {\n      key: 'activeMarkers',\n      get: function get() {\n        var _cursor$offsets = this.cursor.offsets;\n        var startMarker = _cursor$offsets.startMarker;\n        var endMarker = _cursor$offsets.endMarker;\n\n        if (!(startMarker && endMarker)) {\n          return [];\n        }\n\n        var activeMarkers = [];\n        this.post.markersFrom(startMarker, endMarker, function (m) {\n          return activeMarkers.push(m);\n        });\n        return activeMarkers;\n      }\n    }]);\n\n    return Editor;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(Editor, _contentKitEditorUtilsEventEmitter['default']);\n  (0, _contentKitEditorUtilsMixin['default'])(Editor, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = Editor;\n});","define('content-kit-editor/editor/post', ['exports', 'content-kit-editor/models/markup-section', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/key'], function (exports, _contentKitEditorModelsMarkupSection, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsKey) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function isMarkupSection(section) {\n    return section.type === _contentKitEditorModelsMarkupSection.MARKUP_SECTION_TYPE;\n  }\n\n  var PostEditor = (function () {\n    function PostEditor(editor) {\n      _classCallCheck(this, PostEditor);\n\n      this.editor = editor;\n      this._completionWorkQueue = [];\n      this._didRerender = false;\n      this._didUpdate = false;\n      this._didComplete = false;\n    }\n\n    /**\n     * Remove a range of markers from the post.\n     *\n     * Usage:\n     *\n     *     let marker = editor.post.sections.head.markers.head;\n     *     editor.run((postEditor) => {\n     *       postEditor.deleteRange({\n     *         headMarker: marker,\n     *         headOffset: 2,\n     *         tailMarker: marker,\n     *         tailOffset: 4,\n     *       });\n     *     });\n     *\n     * `deleteRange` accepts the value of `this.cursor.offsets` for deletion.\n     *\n     * @method deleteRange\n     * @param {Object} markerRange Object with offsets, {headMarker, headOffset, tailMarker, tailOffset}\n     * @return {Object} {currentMarker, currentOffset} for cursor\n     * @public\n     */\n\n    _createClass(PostEditor, [{\n      key: 'deleteRange',\n      value: function deleteRange(markerRange) {\n        var _this = this;\n\n        // types of selection deletion:\n        //   * a selection starts at the beginning of a section\n        //     -- cursor should end up at the beginning of that section\n        //     -- if the section not longer has markers, add a blank one for the cursor to focus on\n        //   * a selection is entirely within a section\n        //     -- split the markers with the selection, remove those new markers from their section\n        //     -- cursor goes at end of the marker before the selection start, or if the\n        //     -- selection was at the start of the section, cursor goes at section start\n        //   * a selection crosses multiple sections\n        //     -- remove all the sections that are between (exclusive) selection start and end\n        //     -- join the start and end sections\n        //     -- mark the end section for removal\n        //     -- cursor goes at end of marker before the selection start\n\n        // markerRange should be akin to this.cursor.offset\n        var headSection = markerRange.headSection;\n        var headSectionOffset = markerRange.headSectionOffset;\n        var tailSection = markerRange.tailSection;\n        var tailSectionOffset = markerRange.tailSectionOffset;\n        var post = this.editor.post;\n\n        if (headSection === tailSection) {\n          this.cutSection(headSection, headSectionOffset, tailSectionOffset);\n        } else {\n          (function () {\n            var removedSections = [];\n            post.sections.walk(headSection, tailSection, function (section) {\n              switch (section) {\n                case headSection:\n                  _this.cutSection(section, headSectionOffset, section.text.length);\n                  break;\n                case tailSection:\n                  tailSection.markersFor(tailSectionOffset, section.text.length).forEach(function (m) {\n                    headSection.markers.append(m);\n                  });\n                  removedSections.push(tailSection);\n                  break;\n                default:\n                  removedSections.push(section);\n              }\n            });\n            removedSections.forEach(function (section) {\n              return _this.removeSection(section);\n            });\n          })();\n        }\n\n        this._coalesceMarkers(headSection);\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n    }, {\n      key: 'cutSection',\n      value: function cutSection(section, headSectionOffset, tailSectionOffset) {\n        var _section$markerPositionAtOffset = section.markerPositionAtOffset(headSectionOffset);\n\n        var headMarker = _section$markerPositionAtOffset.marker;\n        var headOffset = _section$markerPositionAtOffset.offset;\n\n        var _section$markerPositionAtOffset2 = section.markerPositionAtOffset(tailSectionOffset);\n\n        var tailMarker = _section$markerPositionAtOffset2.marker;\n        var tailOffset = _section$markerPositionAtOffset2.offset;\n\n        var markers = this.splitMarkers({ headMarker: headMarker, headOffset: headOffset, tailMarker: tailMarker, tailOffset: tailOffset });\n        section.markers.removeBy(function (m) {\n          return markers.indexOf(m) !== -1;\n        });\n      }\n    }, {\n      key: '_coalesceMarkers',\n      value: function _coalesceMarkers(section) {\n        var _this2 = this;\n\n        var builder = this.editor.builder;\n\n        (0, _contentKitEditorUtilsArrayUtils.filter)(section.markers, function (m) {\n          return m.isEmpty;\n        }).forEach(function (m) {\n          _this2.removeMarker(m);\n        });\n        if (section.markers.isEmpty) {\n          section.markers.append(builder.createBlankMarker());\n          section.renderNode.markDirty();\n        }\n      }\n    }, {\n      key: 'removeMarker',\n      value: function removeMarker(marker) {\n        if (marker.renderNode) {\n          marker.renderNode.scheduleForRemoval();\n        }\n        marker.section.markers.remove(marker);\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n\n      /**\n       * Remove a character from a {marker, offset} position, in either\n       * forward or backward (default) direction.\n       *\n       * Usage:\n       *\n       *     let marker = editor.post.sections.head.markers.head;\n       *     // marker has text of \"Howdy!\"\n       *     editor.run((postEditor) => {\n       *       postEditor.deleteFrom({marker, offset: 3});\n       *     });\n       *     // marker has text of \"Hody!\"\n       *\n       * `deleteFrom` may remove a character from a different marker or join the\n       * marker's section with the previous/next section (depending on the\n       * deletion direction) if direction is `BACKWARD` and the offset is 0,\n       * or direction is `FORWARD` and the offset is equal to the length of the\n       * marker.\n       *\n       * @method deleteFrom\n       * @param {Object} position object with {marker, offset} the marker and offset to delete from\n       * @param {Number} direction The direction to delete in (default is BACKWARD)\n       * @return {Object} {currentMarker, currentOffset} for positioning the cursor\n       * @public\n       */\n    }, {\n      key: 'deleteFrom',\n      value: function deleteFrom(_ref) {\n        var marker = _ref.marker;\n        var offset = _ref.offset;\n        var direction = arguments.length <= 1 || arguments[1] === undefined ? _contentKitEditorUtilsKey.DIRECTION.BACKWARD : arguments[1];\n\n        if (direction === _contentKitEditorUtilsKey.DIRECTION.BACKWARD) {\n          return this._deleteBackwardFrom({ marker: marker, offset: offset });\n        } else {\n          return this._deleteForwardFrom({ marker: marker, offset: offset });\n        }\n      }\n\n      /**\n       * delete 1 character in the FORWARD direction from the given position\n       * @method _deleteForwardFrom\n       * @private\n       */\n    }, {\n      key: '_deleteForwardFrom',\n      value: function _deleteForwardFrom(_ref2) {\n        var marker = _ref2.marker;\n        var offset = _ref2.offset;\n\n        var nextCursorMarker = marker,\n            nextCursorOffset = offset;\n\n        if (offset === marker.length) {\n          var nextMarker = marker.next;\n\n          if (nextMarker) {\n            this._deleteForwardFrom({ marker: nextMarker, offset: 0 });\n          } else {\n            var nextSection = marker.section.next;\n            if (nextSection && isMarkupSection(nextSection)) {\n              var currentSection = marker.section;\n\n              currentSection.join(nextSection);\n\n              currentSection.renderNode.markDirty();\n              nextSection.renderNode.scheduleForRemoval();\n            }\n          }\n        } else {\n          marker.deleteValueAtOffset(offset);\n          marker.renderNode.markDirty();\n        }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return {\n          currentMarker: nextCursorMarker,\n          currentOffset: nextCursorOffset\n        };\n      }\n\n      /**\n       * delete 1 character in the BACKWARD direction from the given position\n       * @method _deleteBackwardFrom\n       * @private\n       */\n    }, {\n      key: '_deleteBackwardFrom',\n      value: function _deleteBackwardFrom(_ref3) {\n        var marker = _ref3.marker;\n        var offset = _ref3.offset;\n\n        var nextCursorMarker = marker,\n            nextCursorOffset = offset;\n\n        if (offset === 0) {\n          var prevMarker = marker.prev;\n\n          if (prevMarker) {\n            return this._deleteBackwardFrom({ marker: prevMarker, offset: prevMarker.length });\n          } else {\n            var prevSection = marker.section.prev;\n\n            if (prevSection) {\n              if (isMarkupSection(prevSection)) {\n                nextCursorMarker = prevSection.markers.tail;\n                nextCursorOffset = nextCursorMarker.length;\n\n                var _prevSection$join = prevSection.join(marker.section);\n\n                var beforeMarker = _prevSection$join.beforeMarker;\n                var afterMarker = _prevSection$join.afterMarker;\n\n                prevSection.renderNode.markDirty();\n                marker.section.renderNode.scheduleForRemoval();\n\n                if (beforeMarker) {\n                  nextCursorMarker = beforeMarker;\n                  nextCursorOffset = beforeMarker.length;\n                } else {\n                  nextCursorMarker = afterMarker;\n                  nextCursorOffset = 0;\n                }\n              }\n              // ELSE: FIXME: card section -- what should deleting into it do?\n            }\n          }\n        } else if (offset <= marker.length) {\n            var offsetToDeleteAt = offset - 1;\n\n            marker.deleteValueAtOffset(offsetToDeleteAt);\n\n            if (marker.isEmpty && marker.prev) {\n              marker.renderNode.scheduleForRemoval();\n              nextCursorMarker = marker.prev;\n              nextCursorOffset = nextCursorMarker.length;\n            } else if (marker.isEmpty && marker.next) {\n              marker.renderNode.scheduleForRemoval();\n              nextCursorMarker = marker.next;\n              nextCursorOffset = 0;\n            } else {\n              marker.renderNode.markDirty();\n              nextCursorOffset = offsetToDeleteAt;\n            }\n          }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return {\n          currentMarker: nextCursorMarker,\n          currentOffset: nextCursorOffset\n        };\n      }\n\n      /**\n       * Split makers at two positions, once at the head, and if necessary once\n       * at the tail. This method is designed to accept `editor.cursor.offsets`\n       * as an argument.\n       *\n       * Usage:\n       *\n       *     let markerRange = this.cursor.offsets;\n       *     editor.run((postEditor) => {\n       *       postEditor.splitMarkers(markerRange);\n       *     });\n       *\n       * The return value will be marker object completely inside the offsets\n       * provided. Markers on the outside of the split may also have been modified.\n       *\n       * @method splitMarkers\n       * @param {Object} markerRange Object with offsets, {headMarker, headOffset, tailMarker, tailOffset}\n       * @return {Array} of markers that are inside the split\n       * @public\n       */\n    }, {\n      key: 'splitMarkers',\n      value: function splitMarkers(_ref4) {\n        var headMarker = _ref4.headMarker;\n        var headOffset = _ref4.headOffset;\n        var tailMarker = _ref4.tailMarker;\n        var tailOffset = _ref4.tailOffset;\n        var post = this.editor.post;\n\n        var selectedMarkers = [];\n\n        var headSection = headMarker.section;\n        var tailSection = tailMarker.section;\n\n        // These render will be removed by the split functions. Mark them\n        // for removal before doing that. FIXME this seems prime for\n        // refactoring onto the postEditor as a split function\n        headMarker.renderNode.scheduleForRemoval();\n        tailMarker.renderNode.scheduleForRemoval();\n        headMarker.section.renderNode.markDirty();\n        tailMarker.section.renderNode.markDirty();\n\n        if (headMarker === tailMarker) {\n          var markers = headSection.splitMarker(headMarker, headOffset, tailOffset);\n          selectedMarkers = post.markersInRange({\n            headMarker: markers[0],\n            tailMarker: markers[markers.length - 1],\n            headOffset: headOffset,\n            tailOffset: tailOffset\n          });\n        } else {\n          var newHeadMarkers = headSection.splitMarker(headMarker, headOffset);\n          var selectedHeadMarkers = post.markersInRange({\n            headMarker: newHeadMarkers[0],\n            tailMarker: newHeadMarkers[newHeadMarkers.length - 1],\n            headOffset: headOffset\n          });\n\n          var newTailMarkers = tailSection.splitMarker(tailMarker, 0, tailOffset);\n          var selectedTailMarkers = post.markersInRange({\n            headMarker: newTailMarkers[0],\n            tailMarker: newTailMarkers[newTailMarkers.length - 1],\n            headOffset: 0,\n            tailOffset: tailOffset\n          });\n\n          var newHeadMarker = selectedHeadMarkers[0],\n              newTailMarker = selectedTailMarkers[selectedTailMarkers.length - 1];\n\n          var newMarkers = [];\n          if (newHeadMarker) {\n            newMarkers.push(newHeadMarker);\n          }\n          if (newTailMarker) {\n            newMarkers.push(newTailMarker);\n          }\n\n          if (newMarkers.length) {\n            this.editor.post.markersFrom(newMarkers[0], newMarkers[newMarkers.length - 1], function (m) {\n              selectedMarkers.push(m);\n            });\n          }\n        }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return selectedMarkers;\n      }\n\n      /**\n       * Split a section at one position. This method is designed to accept\n       * `editor.cursor.offsets` as an argument, but will only split at the\n       * head of the cursor position.\n       *\n       * Usage:\n       *\n       *     let marker = editor.post.sections.head.marker.head;\n       *     editor.run((postEditor) => {\n       *       postEditor.splitSection({\n       *         headMarker: marker,\n       *         headOffset: 3\n       *       });\n       *     });\n       *     // Will result in the marker and its old section being removed from\n       *     // the post and rendered DOM, and in the creation of two new sections\n       *     // replacing the old one.\n       *\n       * The return value will be the two new sections. One or both of these\n       * sections can be blank (contain only a blank marker), for example if the\n       * headOffset is 0.\n       *\n       * @method splitMarkers\n       * @param {Object} markerRange Object with offsets, {headMarker, headOffset, tailMarker, tailOffset}\n       * @return {Array} of new sections, one for the first half and one for the second\n       * @public\n       */\n    }, {\n      key: 'splitSection',\n      value: function splitSection(_ref5) {\n        var section = _ref5.headSection;\n        var headSectionOffset = _ref5.headSectionOffset;\n\n        var _section$markerPositionAtOffset3 = section.markerPositionAtOffset(headSectionOffset);\n\n        var headMarker = _section$markerPositionAtOffset3.marker;\n        var headOffset = _section$markerPositionAtOffset3.offset;\n\n        var _section$splitAtMarker = section.splitAtMarker(headMarker, headOffset);\n\n        var _section$splitAtMarker2 = _slicedToArray(_section$splitAtMarker, 2);\n\n        var beforeSection = _section$splitAtMarker2[0];\n        var afterSection = _section$splitAtMarker2[1];\n\n        this._replaceSection(section, [beforeSection, afterSection]);\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return [beforeSection, afterSection];\n      }\n    }, {\n      key: '_replaceSection',\n      value: function _replaceSection(section, newSections) {\n        var _this3 = this;\n\n        var nextSection = section.next;\n        newSections.forEach(function (s) {\n          return _this3.insertSectionBefore(s, nextSection);\n        });\n        this.removeSection(section);\n      }\n\n      /**\n       * Given a markerRange (for example `editor.cursor.offsets`) mark all markers\n       * inside it as a given markup. The markup must be provided as a post\n       * abstract node.\n       *\n       * Usage:\n       *\n       *     let markerRange = editor.cursor.offsets;\n       *     let strongMarkup = editor.builder.createMarkup('strong');\n       *     editor.run((postEditor) => {\n       *       postEditor.applyMarkupToMarkers(markerRange, strongMarkup);\n       *     });\n       *     // Will result some markers possibly being split, and the markup\n       *     // being applied to all markers between the split.\n       *\n       * The return value will be all markers between the split, the same return\n       * value as `splitMarkers`.\n       *\n       * @method applyMarkupToMarkers\n       * @param {Object} markerRange Object with offsets, {headMarker, headOffset, tailMarker, tailOffset}\n       * @param {Object} markup A markup post abstract node\n       * @return {Array} of markers that are inside the split\n       * @public\n       */\n    }, {\n      key: 'applyMarkupToMarkers',\n      value: function applyMarkupToMarkers(markerRange, markup) {\n        var markers = this.splitMarkers(markerRange);\n        markers.forEach(function (marker) {\n          marker.addMarkup(markup);\n          marker.section.renderNode.markDirty();\n        });\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return markers;\n      }\n\n      /**\n       * Given a markerRange (for example `editor.cursor.offsets`) remove the given\n       * markup from all contained markers. The markup must be provided as a post\n       * abstract node.\n       *\n       * Usage:\n       *\n       *     let markerRange = editor.cursor.offsets;\n       *     let markup = markerRange.headMarker.markups[0];\n       *     editor.run((postEditor) => {\n       *       postEditor.removeMarkupFromMarkers(markerRange, markup);\n       *     });\n       *     // Will result some markers possibly being split, and the markup\n       *     // being removed from all markers between the split.\n       *\n       * The return value will be all markers between the split, the same return\n       * value as `splitMarkers`.\n       *\n       * @method removeMarkupFromMarkers\n       * @param {Object} markerRange Object with offsets, {headMarker, headOffset, tailMarker, tailOffset}\n       * @param {Object} markup A markup post abstract node\n       * @return {Array} of markers that are inside the split\n       * @public\n       */\n    }, {\n      key: 'removeMarkupFromMarkers',\n      value: function removeMarkupFromMarkers(markerRange, markup) {\n        var markers = this.splitMarkers(markerRange);\n        markers.forEach(function (marker) {\n          marker.removeMarkup(markup);\n          marker.section.renderNode.markDirty();\n        });\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return markers;\n      }\n\n      /**\n       * Insert a given section before another one, updating the post abstract\n       * and the rendered UI.\n       *\n       * Usage:\n       *\n       *     let markerRange = editor.cursor.offsets;\n       *     let sectionWithCursor = markerRange.headMarker.section;\n       *     let section = editor.builder.createCardSection('my-image');\n       *     editor.run((postEditor) => {\n       *       postEditor.insertSectionBefore(section, sectionWithCursor);\n       *     });\n       *\n       * @method insertSectionBefore\n       * @param {Object} section The new section\n       * @param {Object} beforeSection The section \"before\" is relative to\n       * @public\n       */\n    }, {\n      key: 'insertSectionBefore',\n      value: function insertSectionBefore(section, beforeSection) {\n        this.editor.post.sections.insertBefore(section, beforeSection);\n        this.editor.post.renderNode.markDirty();\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n\n      /**\n       * Remove a given section from the post abstract and the rendered UI.\n       *\n       * Usage:\n       *\n       *     let markerRange = editor.cursor.offsets;\n       *     let sectionWithCursor = markerRange.headMarker.section;\n       *     editor.run((postEditor) => {\n       *       postEditor.removeSection(sectionWithCursor);\n       *     });\n       *\n       * @method insertSectionBefore\n       * @param {Object} section The section to remove\n       * @public\n       */\n    }, {\n      key: 'removeSection',\n      value: function removeSection(section) {\n        section.renderNode.scheduleForRemoval();\n        section.post.sections.remove(section);\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n\n      /**\n       * A method for adding work the deferred queue\n       *\n       * @method schedule\n       * @param {Function} callback to run during completion\n       * @public\n       */\n    }, {\n      key: 'schedule',\n      value: function schedule(callback) {\n        if (this._didComplete) {\n          throw new Error('Work can only be scheduled before a post edit has completed');\n        }\n        this._completionWorkQueue.push(callback);\n      }\n\n      /**\n       * Add a rerender job to the queue\n       *\n       * @method scheduleRerender\n       * @public\n       */\n    }, {\n      key: 'scheduleRerender',\n      value: function scheduleRerender() {\n        var _this4 = this;\n\n        this.schedule(function () {\n          if (!_this4._didRerender) {\n            _this4._didRerender = true;\n            _this4.editor.rerender();\n          }\n        });\n      }\n\n      /**\n       * Add a didUpdate job to the queue\n       *\n       * @method scheduleDidRender\n       * @public\n       */\n    }, {\n      key: 'scheduleDidUpdate',\n      value: function scheduleDidUpdate() {\n        var _this5 = this;\n\n        this.schedule(function () {\n          if (!_this5._didUpdate) {\n            _this5._didUpdate = true;\n            _this5.editor.didUpdate();\n          }\n        });\n      }\n\n      /**\n       * Flush any work on the queue. `editor.run` already does this, calling this\n       * method directly should not be needed outside `editor.run`.\n       *\n       * @method complete\n       * @private\n       */\n    }, {\n      key: 'complete',\n      value: function complete() {\n        if (this._didComplete) {\n          throw new Error('Post editing can only be completed once');\n        }\n        this._didComplete = true;\n        this._completionWorkQueue.forEach(function (callback) {\n          callback();\n        });\n      }\n    }]);\n\n    return PostEditor;\n  })();\n\n  exports['default'] = PostEditor;\n});","define('content-kit-editor', ['exports', 'content-kit-editor/editor/editor', 'content-kit-editor/commands/bold', 'content-kit-editor/cards/image'], function (exports, _contentKitEditorEditorEditor, _contentKitEditorCommandsBold, _contentKitEditorCardsImage) {\n  'use strict';\n\n  exports.registerGlobal = registerGlobal;\n\n  var ContentKit = {\n    Editor: _contentKitEditorEditorEditor['default'],\n    ImageCard: _contentKitEditorCardsImage['default'],\n    BoldCommand: _contentKitEditorCommandsBold['default']\n  };\n\n  function registerGlobal(global) {\n    global.ContentKit = ContentKit;\n  }\n\n  exports.Editor = _contentKitEditorEditorEditor['default'];\n  exports['default'] = ContentKit;\n});","define('content-kit-editor/models/card-node', ['exports'], function (exports) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var CardNode = (function () {\n    function CardNode(editor, card, section, element, cardOptions) {\n      _classCallCheck(this, CardNode);\n\n      this.editor = editor;\n      this.card = card;\n      this.section = section;\n      this.cardOptions = cardOptions;\n      this.element = element;\n\n      this.mode = null;\n      this.setupResult = null;\n    }\n\n    _createClass(CardNode, [{\n      key: 'render',\n      value: function render(mode) {\n        if (this.mode === mode) {\n          return;\n        }\n\n        this.teardown();\n\n        this.mode = mode;\n        this.setupResult = this.card[mode].setup(this.element, this.cardOptions, this.env, this.section.payload);\n      }\n    }, {\n      key: 'display',\n      value: function display() {\n        this.render('display');\n      }\n    }, {\n      key: 'edit',\n      value: function edit() {\n        this.render('edit');\n      }\n    }, {\n      key: 'teardown',\n      value: function teardown() {\n        if (this.mode) {\n          if (this.card[this.mode].teardown) {\n            this.card[this.mode].teardown(this.setupResult);\n          }\n        }\n      }\n    }, {\n      key: 'env',\n      get: function get() {\n        var _this = this;\n\n        return {\n          name: this.card.name,\n          edit: function edit() {\n            _this.edit();\n          },\n          save: function save(payload) {\n            _this.section.payload = payload;\n\n            _this.editor.didUpdate();\n            _this.display();\n          },\n          cancel: function cancel() {\n            _this.display();\n          }\n        };\n      }\n    }]);\n\n    return CardNode;\n  })();\n\n  exports['default'] = CardNode;\n});","define(\"content-kit-editor/models/card\", [\"exports\", \"content-kit-editor/utils/linked-item\"], function (exports, _contentKitEditorUtilsLinkedItem) {\n  \"use strict\";\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var CARD_TYPE = 'card-section';\n\n  exports.CARD_TYPE = CARD_TYPE;\n\n  var Card = (function (_LinkedItem) {\n    _inherits(Card, _LinkedItem);\n\n    function Card(name, payload) {\n      _classCallCheck(this, Card);\n\n      _get(Object.getPrototypeOf(Card.prototype), \"constructor\", this).call(this);\n      this.name = name;\n      this.payload = payload;\n      this.type = CARD_TYPE;\n    }\n\n    return Card;\n  })(_contentKitEditorUtilsLinkedItem[\"default\"]);\n\n  exports[\"default\"] = Card;\n});","define('content-kit-editor/models/cursor', ['exports', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/selection-utils', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsSelectionUtils, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function findOffsetInParent(parentElement, targetElement, targetOffset) {\n    var offset = 0;\n    var found = false;\n    // FIXME: would be nice to exit this walk early after we find the end node\n    (0, _contentKitEditorUtilsDomUtils.walkDOM)(parentElement, function (childElement) {\n      if (found) {\n        return;\n      }\n      found = childElement === targetElement;\n\n      if (found) {\n        offset += targetOffset;\n      } else if ((0, _contentKitEditorUtilsDomUtils.isTextNode)(childElement)) {\n        offset += childElement.textContent.length;\n      }\n    });\n    return offset;\n  }\n\n  function findSectionContaining(sections, childNode) {\n    var _detectParentNode = (0, _contentKitEditorUtilsDomUtils.detectParentNode)(childNode, function (node) {\n      return (0, _contentKitEditorUtilsArrayUtils.detect)(sections, function (s) {\n        return s.renderNode.element === node;\n      });\n    });\n\n    var section = _detectParentNode.result;\n\n    return section;\n  }\n\n  function comparePosition(selection) {\n    var anchorNode = selection.anchorNode;\n    var focusNode = selection.focusNode;\n    var anchorOffset = selection.anchorOffset;\n    var focusOffset = selection.focusOffset;\n\n    var leftNode = undefined,\n        rightNode = undefined,\n        leftOffset = undefined,\n        rightOffset = undefined;\n\n    var position = anchorNode.compareDocumentPosition(focusNode);\n\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      leftNode = anchorNode;rightNode = focusNode;\n      leftOffset = anchorOffset;rightOffset = focusOffset;\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      leftNode = focusNode;rightNode = anchorNode;\n      leftOffset = focusOffset;rightOffset = anchorOffset;\n    } else {\n      // same node\n      leftNode = anchorNode;\n      rightNode = focusNode;\n      leftOffset = Math.min(anchorOffset, focusOffset);\n      rightOffset = Math.max(anchorOffset, focusOffset);\n    }\n\n    return { leftNode: leftNode, leftOffset: leftOffset, rightNode: rightNode, rightOffset: rightOffset };\n  }\n\n  var Cursor = (function () {\n    function Cursor(editor) {\n      _classCallCheck(this, Cursor);\n\n      this.editor = editor;\n      this.renderTree = editor._renderTree;\n      this.post = editor.post;\n    }\n\n    _createClass(Cursor, [{\n      key: 'hasSelection',\n      value: function hasSelection() {\n        var parentElement = this.editor.element;\n        return (0, _contentKitEditorUtilsSelectionUtils.isSelectionInElement)(parentElement);\n      }\n    }, {\n      key: 'clearSelection',\n      value: function clearSelection() {\n        (0, _contentKitEditorUtilsSelectionUtils.clearSelection)();\n      }\n    }, {\n      key: 'moveToSection',\n\n      // moves cursor to the start of the section\n      value: function moveToSection(section) {\n        var offsetInSection = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n        var _section$markerPositionAtOffset = section.markerPositionAtOffset(offsetInSection);\n\n        var marker = _section$markerPositionAtOffset.marker;\n        var offset = _section$markerPositionAtOffset.offset;\n\n        if (!marker) {\n          throw new Error('Cannot move cursor to section without a marker');\n        }\n        this.moveToMarker(marker, offset);\n      }\n\n      // moves cursor to marker\n    }, {\n      key: 'moveToMarker',\n      value: function moveToMarker(headMarker) {\n        var headOffset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var tailMarker = arguments.length <= 2 || arguments[2] === undefined ? headMarker : arguments[2];\n        var tailOffset = arguments.length <= 3 || arguments[3] === undefined ? headOffset : arguments[3];\n        return (function () {\n          if (!headMarker) {\n            throw new Error('Cannot move cursor to section without a marker');\n          }\n          var headElement = headMarker.renderNode.element;\n          var tailElement = tailMarker.renderNode.element;\n\n          this.moveToNode(headElement, headOffset, tailElement, tailOffset);\n        }).apply(this, arguments);\n      }\n    }, {\n      key: 'selectSections',\n      value: function selectSections(sections) {\n        var startSection = sections[0],\n            endSection = sections[sections.length - 1];\n\n        var startNode = startSection.markers.head.renderNode.element,\n            endNode = endSection.markers.tail.renderNode.element;\n\n        var startOffset = 0,\n            endOffset = endNode.textContent.length;\n\n        this.moveToNode(startNode, startOffset, endNode, endOffset);\n      }\n    }, {\n      key: 'selectMarkers',\n      value: function selectMarkers(markers) {\n        var startMarker = markers[0],\n            endMarker = markers[markers.length - 1];\n\n        var startNode = startMarker.renderNode.element,\n            endNode = endMarker.renderNode.element;\n        var startOffset = 0,\n            endOffset = endMarker.length;\n\n        this.moveToNode(startNode, startOffset, endNode, endOffset);\n      }\n\n      /**\n       * @param {textNode} node\n       * @param {integer} offset\n       * @param {textNode} endNode (default: node)\n       * @param {integer} endOffset (default: offset)\n       */\n    }, {\n      key: 'moveToNode',\n      value: function moveToNode(node) {\n        var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var endNode = arguments.length <= 2 || arguments[2] === undefined ? node : arguments[2];\n        var endOffset = arguments.length <= 3 || arguments[3] === undefined ? offset : arguments[3];\n        return (function () {\n          var r = document.createRange();\n          r.setStart(node, offset);\n          r.setEnd(endNode, endOffset);\n          var selection = this.selection;\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(r);\n        }).apply(this, arguments);\n      }\n    }, {\n      key: 'selection',\n      get: function get() {\n        return window.getSelection();\n      }\n    }, {\n      key: 'sectionOffsets',\n      get: function get() {\n        var sections = this.post.sections;\n\n        var selection = this.selection;\n        var rangeCount = selection.rangeCount;\n\n        var range = rangeCount > 0 && selection.getRangeAt(0);\n\n        if (!range) {\n          return {};\n        }\n\n        var _comparePosition = comparePosition(selection);\n\n        var headNode = _comparePosition.leftNode;\n        var headOffset = _comparePosition.leftOffset;\n\n        var headSection = findSectionContaining(sections, headNode);\n        var headSectionOffset = findOffsetInParent(headSection.renderNode.element, headNode, headOffset);\n\n        return { headSection: headSection, headSectionOffset: headSectionOffset };\n      }\n    }, {\n      key: 'offsets',\n      get: function get() {\n        var sections = this.post.sections;\n\n        var selection = this.selection;\n        var isCollapsed = selection.isCollapsed;\n        var rangeCount = selection.rangeCount;\n\n        var range = rangeCount > 0 && selection.getRangeAt(0);\n\n        if (!range) {\n          return {};\n        }\n\n        var _comparePosition2 = comparePosition(selection);\n\n        var leftNode = _comparePosition2.leftNode;\n        var leftOffset = _comparePosition2.leftOffset;\n        var rightNode = _comparePosition2.rightNode;\n        var rightOffset = _comparePosition2.rightOffset;\n\n        // The selection should contain two text nodes, but may contain a P\n        // tag if the section only has a blank br marker or on\n        // Chrome/Safari using shift+<Up arrow> can create a selection with\n        // a tag rather than a text node. This fixes that.\n        // See https://github.com/bustlelabs/content-kit-editor/issues/56\n\n        var leftRenderNode = this.renderTree.getElementRenderNode(leftNode),\n            rightRenderNode = this.renderTree.getElementRenderNode(rightNode);\n\n        if (!rightRenderNode) {\n          var rightSection = findSectionContaining(sections, rightNode);\n          var rightMarker = rightSection.markers.head;\n          rightRenderNode = rightMarker.renderNode;\n          rightNode = rightRenderNode.element;\n          rightOffset = 0;\n        }\n\n        if (!leftRenderNode) {\n          var leftSection = findSectionContaining(sections, leftNode);\n          var leftMarker = leftSection.markers.head;\n          leftRenderNode = leftMarker.renderNode;\n          leftNode = leftRenderNode.element;\n          leftOffset = 0;\n        }\n\n        var startMarker = leftRenderNode && leftRenderNode.postNode,\n            endMarker = rightRenderNode && rightRenderNode.postNode;\n\n        var startSection = startMarker && startMarker.section;\n        var endSection = endMarker && endMarker.section;\n\n        var headSectionOffset = startSection && startMarker && startMarker.offsetInParent(leftOffset);\n\n        var tailSectionOffset = endSection && endMarker && endMarker.offsetInParent(rightOffset);\n\n        return {\n          leftNode: leftNode,\n          rightNode: rightNode,\n          leftOffset: leftOffset,\n          rightOffset: rightOffset,\n          leftRenderNode: leftRenderNode,\n          rightRenderNode: rightRenderNode,\n          startMarker: startMarker,\n          endMarker: endMarker,\n          startSection: startSection,\n          endSection: endSection,\n\n          // FIXME: this should become the public API\n          headMarker: startMarker,\n          tailMarker: endMarker,\n          headOffset: leftOffset,\n          tailOffset: rightOffset,\n          headNode: leftNode,\n          tailNode: rightNode,\n\n          headSection: startSection,\n          tailSection: endSection,\n          headSectionOffset: headSectionOffset,\n          tailSectionOffset: tailSectionOffset,\n          isCollapsed: isCollapsed\n        };\n      }\n    }, {\n      key: 'activeSections',\n      get: function get() {\n        var sections = this.post.sections;\n\n        var selection = this.selection;\n        var rangeCount = selection.rangeCount;\n\n        var range = rangeCount > 0 && selection.getRangeAt(0);\n\n        if (!range) {\n          return [];\n        }\n\n        var startContainer = range.startContainer;\n        var endContainer = range.endContainer;\n\n        var startSection = findSectionContaining(sections, startContainer);\n        var endSection = findSectionContaining(sections, endContainer);\n\n        return sections.readRange(startSection, endSection);\n      }\n    }]);\n\n    return Cursor;\n  })();\n\n  exports['default'] = Cursor;\n});","define('content-kit-editor/models/image', ['exports'], function (exports) {\n  'use strict';\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var IMAGE_SECTION_TYPE = 'image-section';\n\n  exports.IMAGE_SECTION_TYPE = IMAGE_SECTION_TYPE;\n\n  var Image = function Image() {\n    _classCallCheck(this, Image);\n\n    this.type = IMAGE_SECTION_TYPE;\n    this.src = null;\n  };\n\n  exports['default'] = Image;\n});","define('content-kit-editor/models/marker', ['exports', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/linked-item'], function (exports, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsLinkedItem) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var MARKER_TYPE = 'marker';\n\n  exports.MARKER_TYPE = MARKER_TYPE;\n\n  var Marker = (function (_LinkedItem) {\n    _inherits(Marker, _LinkedItem);\n\n    function Marker() {\n      var _this = this;\n\n      var value = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n      var markups = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, Marker);\n\n      _get(Object.getPrototypeOf(Marker.prototype), 'constructor', this).call(this);\n      this.value = value;\n      this.markups = [];\n      this.type = MARKER_TYPE;\n\n      if (markups && markups.length) {\n        markups.forEach(function (m) {\n          return _this.addMarkup(m);\n        });\n      }\n    }\n\n    _createClass(Marker, [{\n      key: 'clone',\n      value: function clone() {\n        var clonedMarkups = this.markups.slice();\n        return this.builder.createMarker(this.value, clonedMarkups);\n      }\n    }, {\n      key: 'truncateFrom',\n      value: function truncateFrom(offset) {\n        this.value = this.value.substr(0, offset);\n      }\n    }, {\n      key: 'truncateTo',\n      value: function truncateTo(offset) {\n        this.value = this.value.substr(offset);\n      }\n    }, {\n      key: 'clearMarkups',\n      value: function clearMarkups() {\n        this.markups = [];\n      }\n    }, {\n      key: 'addMarkup',\n      value: function addMarkup(markup) {\n        this.markups.push(markup);\n      }\n\n      // find the value of the absolute offset in this marker's parent section\n    }, {\n      key: 'offsetInParent',\n      value: function offsetInParent(offset) {\n        var parent = this.section;\n        var markers = parent.markers;\n\n        var foundMarker = false;\n        var parentOffset = 0;\n        var marker = markers.head;\n        var length;\n        while (marker && !foundMarker) {\n          length = marker.length;\n          if (marker === this) {\n            foundMarker = true;\n            length = offset;\n          }\n\n          parentOffset += length;\n          marker = marker.next;\n        }\n\n        if (!foundMarker) {\n          throw new Error('offsetInParent could not find offset for marker');\n        }\n        return parentOffset;\n      }\n    }, {\n      key: 'removeMarkup',\n      value: function removeMarkup(markup) {\n        var index = this.markups.indexOf(markup);\n        if (index !== -1) {\n          this.markups.splice(index, 1);\n        }\n      }\n\n      // delete the character at this offset,\n      // update the value with the new value\n    }, {\n      key: 'deleteValueAtOffset',\n      value: function deleteValueAtOffset(offset) {\n        var left = this.value.slice(0, offset);\n        var right = this.value.slice(offset + 1);\n\n        this.value = left + right;\n      }\n    }, {\n      key: 'hasMarkup',\n      value: function hasMarkup(tagNameOrMarkup) {\n        var _this2 = this;\n\n        if (typeof tagNameOrMarkup === 'string') {\n          var _ret = (function () {\n            var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagNameOrMarkup);\n            return {\n              v: (0, _contentKitEditorUtilsArrayUtils.detect)(_this2.markups, function (markup) {\n                return markup.tagName === tagName;\n              })\n            };\n          })();\n\n          if (typeof _ret === 'object') return _ret.v;\n        } else {\n          var _ret2 = (function () {\n            var targetMarkup = tagNameOrMarkup;\n            return {\n              v: (0, _contentKitEditorUtilsArrayUtils.detect)(_this2.markups, function (markup) {\n                return markup === targetMarkup;\n              })\n            };\n          })();\n\n          if (typeof _ret2 === 'object') return _ret2.v;\n        }\n      }\n    }, {\n      key: 'getMarkup',\n      value: function getMarkup(tagName) {\n        return this.hasMarkup(tagName);\n      }\n    }, {\n      key: 'join',\n      value: function join(other) {\n        var joined = this.builder.createMarker(this.value + other.value);\n        this.markups.forEach(function (m) {\n          return joined.addMarkup(m);\n        });\n        other.markups.forEach(function (m) {\n          return joined.addMarkup(m);\n        });\n\n        return joined;\n      }\n    }, {\n      key: 'split',\n      value: function split() {\n        var offset = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n        var endOffset = arguments.length <= 1 || arguments[1] === undefined ? this.length : arguments[1];\n\n        var markers = [];\n\n        markers = [this.builder.createMarker(this.value.substring(0, offset)), this.builder.createMarker(this.value.substring(offset, endOffset)), this.builder.createMarker(this.value.substring(endOffset))];\n\n        this.markups.forEach(function (mu) {\n          return markers.forEach(function (m) {\n            return m.addMarkup(mu);\n          });\n        });\n        return markers;\n      }\n    }, {\n      key: 'isEmpty',\n      get: function get() {\n        return this.length === 0;\n      }\n    }, {\n      key: 'length',\n      get: function get() {\n        return this.value.length;\n      }\n    }, {\n      key: 'openedMarkups',\n      get: function get() {\n        var count = 0;\n        if (this.prev) {\n          count = (0, _contentKitEditorUtilsArrayUtils.commonItemLength)(this.markups, this.prev.markups);\n        }\n\n        return this.markups.slice(count);\n      }\n    }, {\n      key: 'closedMarkups',\n      get: function get() {\n        var count = 0;\n        if (this.next) {\n          count = (0, _contentKitEditorUtilsArrayUtils.commonItemLength)(this.markups, this.next.markups);\n        }\n\n        return this.markups.slice(count);\n      }\n    }]);\n\n    return Marker;\n  })(_contentKitEditorUtilsLinkedItem['default']);\n\n  exports['default'] = Marker;\n});","define('content-kit-editor/models/markup-section', ['exports', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/linked-list', 'content-kit-editor/utils/linked-item'], function (exports, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsLinkedList, _contentKitEditorUtilsLinkedItem) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var DEFAULT_TAG_NAME = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)('p');\n  exports.DEFAULT_TAG_NAME = DEFAULT_TAG_NAME;\n  var VALID_MARKUP_SECTION_TAGNAMES = ['p', 'h3', 'h2', 'h1', 'blockquote', 'ul', 'ol'].map(_contentKitEditorUtilsDomUtils.normalizeTagName);\n  exports.VALID_MARKUP_SECTION_TAGNAMES = VALID_MARKUP_SECTION_TAGNAMES;\n  var MARKUP_SECTION_TYPE = 'markup-section';\n  exports.MARKUP_SECTION_TYPE = MARKUP_SECTION_TYPE;\n\n  var Section = (function (_LinkedItem) {\n    _inherits(Section, _LinkedItem);\n\n    function Section(tagName) {\n      var _this = this;\n\n      var markers = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, Section);\n\n      _get(Object.getPrototypeOf(Section.prototype), 'constructor', this).call(this);\n      this.markers = new _contentKitEditorUtilsLinkedList['default']({\n        adoptItem: function adoptItem(m) {\n          return m.section = _this;\n        },\n        freeItem: function freeItem(m) {\n          return m.section = null;\n        }\n      });\n      this.tagName = tagName || DEFAULT_TAG_NAME;\n      this.type = MARKUP_SECTION_TYPE;\n      this.element = null;\n\n      markers.forEach(function (m) {\n        return _this.markers.append(m);\n      });\n    }\n\n    _createClass(Section, [{\n      key: 'setTagName',\n      value: function setTagName(newTagName) {\n        newTagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(newTagName);\n        if (VALID_MARKUP_SECTION_TAGNAMES.indexOf(newTagName) === -1) {\n          throw new Error('Cannot change section tagName to \"' + newTagName);\n        }\n        this.tagName = newTagName;\n      }\n    }, {\n      key: 'resetTagName',\n      value: function resetTagName() {\n        this.tagName = DEFAULT_TAG_NAME;\n      }\n\n      /**\n       * Splits the marker at the offset, filters empty markers from the result,\n       * and replaces this marker with the new non-empty ones\n       * @param {Marker} marker the marker to split\n       * @return {Array} the new markers that replaced `marker`\n       */\n    }, {\n      key: 'splitMarker',\n      value: function splitMarker(marker, offset) {\n        var endOffset = arguments.length <= 2 || arguments[2] === undefined ? marker.length : arguments[2];\n        return (function () {\n          var newMarkers = (0, _contentKitEditorUtilsArrayUtils.filter)(marker.split(offset, endOffset), function (m) {\n            return !m.isEmpty;\n          });\n          this.markers.splice(marker, 1, newMarkers);\n          if (this.markers.length === 0) {\n            var blankMarker = this.builder.createBlankMarker();\n            this.markers.append(blankMarker);\n            newMarkers.push(blankMarker);\n          }\n          return newMarkers;\n        }).apply(this, arguments);\n      }\n    }, {\n      key: 'splitAtMarker',\n      value: function splitAtMarker(marker) {\n        var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var beforeSection = this.builder.createMarkupSection(this.tagName, []);\n        var afterSection = this.builder.createMarkupSection(this.tagName, []);\n\n        var currentSection = beforeSection;\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(this.markers, function (m) {\n          if (m === marker) {\n            var _marker$split = marker.split(offset);\n\n            var _marker$split2 = _toArray(_marker$split);\n\n            var beforeMarker = _marker$split2[0];\n\n            var afterMarkers = _marker$split2.slice(1);\n\n            beforeSection.markers.append(beforeMarker);\n            (0, _contentKitEditorUtilsArrayUtils.forEach)(afterMarkers, function (_m) {\n              return afterSection.markers.append(_m);\n            });\n            currentSection = afterSection;\n          } else {\n            currentSection.markers.append(m.clone());\n          }\n        });\n\n        beforeSection.coalesceMarkers();\n        afterSection.coalesceMarkers();\n\n        return [beforeSection, afterSection];\n      }\n\n      /**\n       * Remove extranous empty markers, adding one at the end if there\n       * are no longer any markers\n       *\n       * Mutates this section's markers\n       */\n    }, {\n      key: 'coalesceMarkers',\n      value: function coalesceMarkers() {\n        var _this2 = this;\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)((0, _contentKitEditorUtilsArrayUtils.filter)(this.markers, function (m) {\n          return m.isEmpty;\n        }), function (m) {\n          return _this2.markers.remove(m);\n        });\n        if (this.markers.isEmpty) {\n          this.markers.append(this.builder.createBlankMarker());\n        }\n      }\n    }, {\n      key: 'markerPositionAtOffset',\n      value: function markerPositionAtOffset(offset) {\n        var currentOffset = 0;\n        var currentMarker = undefined;\n        var remaining = offset;\n        this.markers.detect(function (marker) {\n          currentOffset = Math.min(remaining, marker.length);\n          remaining -= currentOffset;\n          if (remaining === 0) {\n            currentMarker = marker;\n            return true; // break out of detect\n          }\n        });\n\n        return { marker: currentMarker, offset: currentOffset };\n      }\n\n      // mutates this by appending the other section's (cloned) markers to it\n    }, {\n      key: 'join',\n      value: function join(otherSection) {\n        var _this3 = this;\n\n        var wasBlank = this.isBlank;\n        var didAddContent = false;\n\n        var beforeMarker = this.markers.tail;\n        var afterMarker = null;\n\n        otherSection.markers.forEach(function (m) {\n          if (!m.isEmpty) {\n            m = m.clone();\n            _this3.markers.append(m);\n            if (!afterMarker) {\n              afterMarker = m;\n            }\n            didAddContent = true;\n          }\n        });\n\n        if (wasBlank && didAddContent) {\n          // FIXME: Join should maybe not be on the markup-section\n          beforeMarker.renderNode.scheduleForRemoval();\n          beforeMarker = null;\n        }\n\n        return { beforeMarker: beforeMarker, afterMarker: afterMarker };\n      }\n    }, {\n      key: 'markersFor',\n      value: function markersFor(headOffset, tailOffset) {\n        var markers = [];\n        var adjustedHead = 0,\n            adjustedTail = 0;\n        this.markers.forEach(function (m) {\n          adjustedTail += m.length;\n\n          if (adjustedTail > headOffset && adjustedHead < tailOffset) {\n            var head = Math.max(headOffset - adjustedHead, 0);\n            var tail = m.length - Math.max(adjustedTail - tailOffset, 0);\n            var cloned = m.clone();\n\n            cloned.value = m.value.slice(head, tail);\n            markers.push(cloned);\n          }\n          adjustedHead += m.length;\n        });\n        return markers;\n      }\n    }, {\n      key: 'tagName',\n      set: function set(val) {\n        this._tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(val);\n      },\n      get: function get() {\n        return this._tagName;\n      }\n    }, {\n      key: 'isBlank',\n      get: function get() {\n        if (!this.markers.length) {\n          return true;\n        }\n        var markerWithLength = this.markers.detect(function (marker) {\n          return !!marker.length;\n        });\n        return !markerWithLength;\n      }\n    }, {\n      key: 'text',\n      get: function get() {\n        var text = '';\n        this.markers.forEach(function (m) {\n          return text += m.value;\n        });\n        return text;\n      }\n    }]);\n\n    return Section;\n  })(_contentKitEditorUtilsLinkedItem['default']);\n\n  exports['default'] = Section;\n});","define('content-kit-editor/models/markup', ['exports', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var MARKUP_TYPE = 'markup';\n  exports.MARKUP_TYPE = MARKUP_TYPE;\n  var VALID_MARKUP_TAGNAMES = ['b', 'i', 'strong', 'em', 'a', 'li'].map(_contentKitEditorUtilsDomUtils.normalizeTagName);\n\n  exports.VALID_MARKUP_TAGNAMES = VALID_MARKUP_TAGNAMES;\n\n  var Markup = (function () {\n    /*\n     * @param {attributes} array flat array of key1,value1,key2,value2,...\n     */\n\n    function Markup(tagName) {\n      var attributes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, Markup);\n\n      this.tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n      this.attributes = attributes;\n      this.type = MARKUP_TYPE;\n\n      if (VALID_MARKUP_TAGNAMES.indexOf(this.tagName) === -1) {\n        throw new Error('Cannot create markup of tagName ' + tagName);\n      }\n    }\n\n    _createClass(Markup, null, [{\n      key: 'isValidElement',\n      value: function isValidElement(element) {\n        var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n        return VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1;\n      }\n    }]);\n\n    return Markup;\n  })();\n\n  exports['default'] = Markup;\n});","define('content-kit-editor/models/post-node-builder', ['exports', 'content-kit-editor/models/post', 'content-kit-editor/models/markup-section', 'content-kit-editor/models/image', 'content-kit-editor/models/marker', 'content-kit-editor/models/markup', 'content-kit-editor/models/card', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorModelsPost, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsImage, _contentKitEditorModelsMarker, _contentKitEditorModelsMarkup, _contentKitEditorModelsCard, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var PostNodeBuilder = (function () {\n    function PostNodeBuilder() {\n      _classCallCheck(this, PostNodeBuilder);\n\n      this.markupCache = {};\n    }\n\n    _createClass(PostNodeBuilder, [{\n      key: 'createPost',\n      value: function createPost() {\n        var sections = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        var post = new _contentKitEditorModelsPost['default']();\n        post.builder = this;\n\n        sections.forEach(function (s) {\n          return post.sections.append(s);\n        });\n\n        return post;\n      }\n    }, {\n      key: 'createBlankPost',\n      value: function createBlankPost() {\n        var blankMarkupSection = this.createBlankMarkupSection('p');\n        return this.createPost([blankMarkupSection]);\n      }\n    }, {\n      key: 'createMarkupSection',\n      value: function createMarkupSection(tagName) {\n        var markers = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n        var isGenerated = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        var section = new _contentKitEditorModelsMarkupSection['default'](tagName, markers);\n        if (isGenerated) {\n          section.isGenerated = true;\n        }\n        section.builder = this;\n        return section;\n      }\n    }, {\n      key: 'createBlankMarkupSection',\n      value: function createBlankMarkupSection(tagName) {\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        var blankMarker = this.createBlankMarker();\n        return this.createMarkupSection(tagName, [blankMarker]);\n      }\n    }, {\n      key: 'createImageSection',\n      value: function createImageSection(url) {\n        var section = new _contentKitEditorModelsImage['default']();\n        if (url) {\n          section.src = url;\n        }\n        return section;\n      }\n    }, {\n      key: 'createCardSection',\n      value: function createCardSection(name) {\n        var payload = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n        return new _contentKitEditorModelsCard['default'](name, payload);\n      }\n    }, {\n      key: 'createMarker',\n      value: function createMarker(value) {\n        var markups = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        var marker = new _contentKitEditorModelsMarker['default'](value, markups);\n        marker.builder = this;\n        return marker;\n      }\n    }, {\n      key: 'createBlankMarker',\n      value: function createBlankMarker() {\n        var marker = new _contentKitEditorModelsMarker['default']('');\n        marker.builder = this;\n        return marker;\n      }\n    }, {\n      key: 'createMarkup',\n      value: function createMarkup(tagName, attributes) {\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n\n        var markup = undefined;\n\n        if (attributes) {\n          // FIXME: This could also be cached\n          markup = new _contentKitEditorModelsMarkup['default'](tagName, attributes);\n        } else {\n          if (this.markupCache[tagName]) {\n            markup = this.markupCache[tagName];\n          } else {\n            markup = new _contentKitEditorModelsMarkup['default'](tagName, attributes);\n          }\n        }\n\n        markup.builder = this;\n        return markup;\n      }\n    }]);\n\n    return PostNodeBuilder;\n  })();\n\n  exports['default'] = PostNodeBuilder;\n});","define(\"content-kit-editor/models/post\", [\"exports\", \"content-kit-editor/utils/linked-list\"], function (exports, _contentKitEditorUtilsLinkedList) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var POST_TYPE = 'post';\n  exports.POST_TYPE = POST_TYPE;\n\n  var Post = (function () {\n    function Post() {\n      var _this = this;\n\n      _classCallCheck(this, Post);\n\n      this.type = POST_TYPE;\n      this.sections = new _contentKitEditorUtilsLinkedList[\"default\"]({\n        adoptItem: function adoptItem(s) {\n          return s.post = _this;\n        },\n        freeItem: function freeItem(s) {\n          return s.post = null;\n        }\n      });\n    }\n\n    _createClass(Post, [{\n      key: \"markersInRange\",\n      value: function markersInRange(_ref) {\n        var headMarker = _ref.headMarker;\n        var headOffset = _ref.headOffset;\n        var tailMarker = _ref.tailMarker;\n        var tailOffset = _ref.tailOffset;\n\n        var offset = 0;\n        var foundMarkers = [];\n        var toEnd = tailOffset === undefined;\n        if (toEnd) {\n          tailOffset = 0;\n        }\n\n        this.markersFrom(headMarker, tailMarker, function (marker) {\n          if (toEnd) {\n            tailOffset += marker.length;\n          }\n\n          if (offset >= headOffset && offset < tailOffset) {\n            foundMarkers.push(marker);\n          }\n\n          offset += marker.length;\n        });\n\n        return foundMarkers;\n      }\n    }, {\n      key: \"cutMarkers\",\n      value: function cutMarkers(markers) {\n        var _this2 = this;\n\n        var firstSection = markers.length && markers[0].section,\n            lastSection = markers.length && markers[markers.length - 1].section;\n\n        var currentSection = firstSection;\n        var removedSections = [],\n            changedSections = [];\n        if (firstSection) {\n          changedSections.push(firstSection);\n        }\n        if (lastSection) {\n          changedSections.push(lastSection);\n        }\n        if (markers.length !== 0) {\n          markers.forEach(function (marker) {\n            if (marker.section !== currentSection) {\n              // this marker is in a section we haven't seen yet\n              if (marker.section !== firstSection && marker.section !== lastSection) {\n                // section is wholly contained by markers, and can be removed\n                removedSections.push(marker.section);\n              }\n            }\n\n            currentSection = marker.section;\n            currentSection.markers.remove(marker);\n          });\n\n          // add a blank marker to any sections that are now empty\n          changedSections.forEach(function (section) {\n            if (section.markers.isEmpty) {\n              section.markers.append(_this2.builder.createBlankMarker());\n            }\n          });\n\n          if (firstSection !== lastSection) {\n            firstSection.join(lastSection);\n            removedSections.push(lastSection);\n          }\n        }\n\n        return { changedSections: changedSections, removedSections: removedSections };\n      }\n\n      /**\n       * Invoke `callbackFn` for all markers between the startMarker and endMarker (inclusive),\n       * across sections\n       */\n    }, {\n      key: \"markersFrom\",\n      value: function markersFrom(startMarker, endMarker, callbackFn) {\n        var currentMarker = startMarker;\n        while (currentMarker) {\n          callbackFn(currentMarker);\n\n          if (currentMarker === endMarker) {\n            currentMarker = null;\n          } else if (currentMarker.next) {\n            currentMarker = currentMarker.next;\n          } else {\n            var nextSection = currentMarker.section.next;\n            currentMarker = nextSection && nextSection.markers.head;\n          }\n        }\n      }\n    }]);\n\n    return Post;\n  })();\n\n  exports[\"default\"] = Post;\n});","define(\"content-kit-editor/models/render-node\", [\"exports\", \"content-kit-editor/utils/linked-item\", \"content-kit-editor/utils/linked-list\"], function (exports, _contentKitEditorUtilsLinkedItem, _contentKitEditorUtilsLinkedList) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var RenderNode = (function (_LinkedItem) {\n    _inherits(RenderNode, _LinkedItem);\n\n    function RenderNode(postNode) {\n      _classCallCheck(this, RenderNode);\n\n      _get(Object.getPrototypeOf(RenderNode.prototype), \"constructor\", this).call(this);\n      this.parent = null;\n      this.isDirty = true;\n      this.isRemoved = false;\n      this.postNode = postNode;\n      this._childNodes = null;\n      this.element = null;\n    }\n\n    _createClass(RenderNode, [{\n      key: \"scheduleForRemoval\",\n      value: function scheduleForRemoval() {\n        this.isRemoved = true;\n        if (this.parent) {\n          this.parent.markDirty();\n        }\n      }\n    }, {\n      key: \"markDirty\",\n      value: function markDirty() {\n        this.isDirty = true;\n        if (this.parent) {\n          this.parent.markDirty();\n        }\n      }\n    }, {\n      key: \"markClean\",\n      value: function markClean() {\n        this.isDirty = false;\n      }\n    }, {\n      key: \"childNodes\",\n      get: function get() {\n        var _this = this;\n\n        if (!this._childNodes) {\n          this._childNodes = new _contentKitEditorUtilsLinkedList[\"default\"]({\n            adoptItem: function adoptItem(item) {\n              item.parent = _this;\n              item.renderTree = _this.renderTree;\n            },\n            freeItem: function freeItem(item) {\n              item.parent = null;\n              item.renderTree = null;\n            }\n          });\n        }\n        return this._childNodes;\n      }\n    }]);\n\n    return RenderNode;\n  })(_contentKitEditorUtilsLinkedItem[\"default\"]);\n\n  exports[\"default\"] = RenderNode;\n});","define(\"content-kit-editor/models/render-tree\", [\"exports\", \"content-kit-editor/models/render-node\", \"content-kit-editor/utils/element-map\"], function (exports, _contentKitEditorModelsRenderNode, _contentKitEditorUtilsElementMap) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var RenderTree = (function () {\n    function RenderTree(node) {\n      _classCallCheck(this, RenderTree);\n\n      this.node = node;\n      this.elements = new _contentKitEditorUtilsElementMap[\"default\"]();\n    }\n\n    _createClass(RenderTree, [{\n      key: \"getElementRenderNode\",\n      value: function getElementRenderNode(element) {\n        return this.elements.get(element);\n      }\n    }, {\n      key: \"buildRenderNode\",\n      value: function buildRenderNode(section) {\n        var renderNode = new _contentKitEditorModelsRenderNode[\"default\"](section);\n        renderNode.renderTree = this;\n        section.renderNode = renderNode;\n        return renderNode;\n      }\n    }]);\n\n    return RenderTree;\n  })();\n\n  exports[\"default\"] = RenderTree;\n});","define('content-kit-editor/parsers/dom', ['exports', 'content-kit-utils', 'content-kit-editor/models/markup-section', 'content-kit-editor/models/markup', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitUtils, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsMarkup, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var ELEMENT_NODE = 1;\n  var TEXT_NODE = 3;\n\n  var ALLOWED_ATTRIBUTES = ['href', 'rel', 'src'];\n\n  function isEmptyTextNode(node) {\n    return node.nodeType === TEXT_NODE && (0, _contentKitUtils.trim)(node.textContent) === '';\n  }\n\n  // FIXME we need sorted attributes for deterministic tests. This is not\n  // a particularly elegant method, since it loops at least 3 times.\n  function sortAttributes(attributes) {\n    var keyValueAttributes = [];\n    var currentKey = undefined;\n    attributes.forEach(function (keyOrValue, index) {\n      if (index % 2 === 0) {\n        currentKey = keyOrValue;\n      } else {\n        keyValueAttributes.push({ key: currentKey, value: keyOrValue });\n      }\n    });\n    keyValueAttributes.sort(function (a, b) {\n      return a.key === b.key ? 0 : a.key > b.key ? 1 : -1;\n    });\n    var sortedAttributes = [];\n    keyValueAttributes.forEach(function (_ref) {\n      var key = _ref.key;\n      var value = _ref.value;\n\n      sortedAttributes.push(key, value);\n    });\n    return sortedAttributes;\n  }\n\n  /**\n   * @return {array} attributes as key1,value1,key2,value2,etc\n   */\n  function readAttributes(node) {\n    var attributes = [];\n\n    if (node.hasAttributes()) {\n      var i, l;\n      for (i = 0, l = node.attributes.length; i < l; i++) {\n        if (ALLOWED_ATTRIBUTES.indexOf(node.attributes[i].name) !== -1) {\n          attributes.push(node.attributes[i].name);\n          attributes.push(node.attributes[i].value);\n        }\n      }\n    }\n\n    return sortAttributes(attributes);\n  }\n\n  function isValidMarkerElement(element) {\n    var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n    return _contentKitEditorModelsMarkup.VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1;\n  }\n\n  function parseMarkers(section, builder, topNode) {\n    var markups = [];\n    var text = null;\n    var currentNode = topNode;\n    while (currentNode) {\n      switch (currentNode.nodeType) {\n        case ELEMENT_NODE:\n          if (isValidMarkerElement(currentNode)) {\n            markups.push(builder.createMarkup(currentNode.tagName, readAttributes(currentNode)));\n          }\n          break;\n        case TEXT_NODE:\n          text = (text || '') + currentNode.textContent;\n          break;\n      }\n\n      if (currentNode.firstChild) {\n        if (isValidMarkerElement(currentNode) && text !== null) {\n          section.markers.append(builder.createMarker(text, markups.slice()));\n          text = null;\n        }\n        currentNode = currentNode.firstChild;\n      } else if (currentNode.nextSibling) {\n        if (currentNode === topNode) {\n          section.markers.append(builder.createMarker(text, markups.slice()));\n          break;\n        } else {\n          currentNode = currentNode.nextSibling;\n          if (currentNode.nodeType === ELEMENT_NODE && isValidMarkerElement(currentNode) && text !== null) {\n            section.markers.append(builder.createMarker(text, markups.slice()));\n            text = null;\n          }\n        }\n      } else {\n        section.markers.append(builder.createMarker(text, markups.slice()));\n\n        while (currentNode && !currentNode.nextSibling && currentNode !== topNode) {\n          currentNode = currentNode.parentNode;\n          if (isValidMarkerElement(currentNode)) {\n            markups.pop();\n          }\n        }\n\n        text = null;\n\n        if (currentNode === topNode) {\n          break;\n        } else {\n          currentNode = currentNode.nextSibling;\n          if (currentNode === topNode) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function NewHTMLParser(builder) {\n    this.builder = builder;\n  }\n\n  NewHTMLParser.prototype = {\n    parseSection: function parseSection(previousSection, sectionElement) {\n      var builder = this.builder;\n      var section;\n      switch (sectionElement.nodeType) {\n        case ELEMENT_NODE:\n          var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(sectionElement.tagName);\n          // <p> <h2>, etc\n          if (_contentKitEditorModelsMarkupSection.VALID_MARKUP_SECTION_TAGNAMES.indexOf(tagName) !== -1) {\n            section = builder.createMarkupSection(tagName);\n            var node = sectionElement.firstChild;\n            while (node) {\n              parseMarkers(section, builder, node);\n              node = node.nextSibling;\n            }\n            // <strong> <b>, etc\n          } else {\n              if (previousSection && previousSection.isGenerated) {\n                section = previousSection;\n              } else {\n                section = builder.createMarkupSection('P', [], true);\n              }\n              parseMarkers(section, builder, sectionElement);\n            }\n          break;\n        case TEXT_NODE:\n          if (previousSection && previousSection.isGenerated) {\n            section = previousSection;\n          } else {\n            section = builder.createMarkupSection('P', [], true);\n          }\n          parseMarkers(section, builder, sectionElement);\n          break;\n      }\n      if (section.markers.isEmpty) {\n        var marker = this.builder.createBlankMarker();\n        section.markers.append(marker);\n      }\n      return section;\n    },\n    parse: function parse(postElement) {\n      var post = this.builder.createPost();\n      var i, l, section, previousSection, sectionElement;\n      // FIXME: Instead of storing isGenerated on sections, and passing\n      // the previous section to the parser, we could instead do a two-pass\n      // parse. The first pass identifies sections and gathers a list of\n      // dom nodes that can be parsed for markers, the second pass parses\n      // for markers.\n      for (i = 0, l = postElement.childNodes.length; i < l; i++) {\n        sectionElement = postElement.childNodes[i];\n        if (!isEmptyTextNode(sectionElement)) {\n          section = this.parseSection(previousSection, sectionElement);\n          if (section !== previousSection) {\n            post.sections.append(section);\n            previousSection = section;\n          }\n        }\n      }\n\n      if (post.sections.isEmpty) {\n        section = this.builder.createMarkupSection('p');\n        var marker = this.builder.createBlankMarker();\n        section.markers.append(marker);\n        post.sections.append(section);\n      }\n\n      return post;\n    }\n  };\n\n  exports['default'] = NewHTMLParser;\n});","define('content-kit-editor/parsers/mobiledoc', ['exports'], function (exports) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var CARD_SECTION_TYPE = 10;\n  var IMAGE_SECTION_TYPE = 2;\n\n  /*\n   * input mobiledoc: [ markers, elements ]\n   * output: Post\n   *\n   */\n\n  var MobiledocParser = (function () {\n    function MobiledocParser(builder) {\n      _classCallCheck(this, MobiledocParser);\n\n      this.builder = builder;\n    }\n\n    _createClass(MobiledocParser, [{\n      key: 'parse',\n      value: function parse(_ref) {\n        var version = _ref.version;\n        var sectionData = _ref.sections;\n\n        var markerTypes = sectionData[0];\n        var sections = sectionData[1];\n\n        var post = this.builder.createPost();\n\n        this.markups = [];\n        this.markerTypes = this.parseMarkerTypes(markerTypes);\n        this.parseSections(sections, post);\n\n        if (post.sections.isEmpty) {\n          var section = this.builder.createMarkupSection('p');\n          var marker = this.builder.createBlankMarker();\n          section.markers.append(marker);\n          post.sections.append(section);\n        }\n\n        return post;\n      }\n    }, {\n      key: 'parseMarkerTypes',\n      value: function parseMarkerTypes(markerTypes) {\n        var _this = this;\n\n        return markerTypes.map(function (markerType) {\n          return _this.parseMarkerType(markerType);\n        });\n      }\n    }, {\n      key: 'parseMarkerType',\n      value: function parseMarkerType(_ref2) {\n        var _ref22 = _slicedToArray(_ref2, 2);\n\n        var tagName = _ref22[0];\n        var attributes = _ref22[1];\n\n        return this.builder.createMarkup(tagName, attributes);\n      }\n    }, {\n      key: 'parseSections',\n      value: function parseSections(sections, post) {\n        var _this2 = this;\n\n        sections.forEach(function (section) {\n          return _this2.parseSection(section, post);\n        });\n      }\n    }, {\n      key: 'parseSection',\n      value: function parseSection(section, post) {\n        var _section = _slicedToArray(section, 1);\n\n        var type = _section[0];\n\n        switch (type) {\n          case 1:\n            // markup section\n            this.parseMarkupSection(section, post);\n            break;\n          case IMAGE_SECTION_TYPE:\n            this.parseImageSection(section, post);\n            break;\n          case CARD_SECTION_TYPE:\n            this.parseCardSection(section, post);\n            break;\n          default:\n            throw new Error('Unexpected section type ' + type);\n        }\n      }\n    }, {\n      key: 'parseCardSection',\n      value: function parseCardSection(_ref3, post) {\n        var _ref32 = _slicedToArray(_ref3, 3);\n\n        var type = _ref32[0];\n        var name = _ref32[1];\n        var payload = _ref32[2];\n\n        var section = this.builder.createCardSection(name, payload);\n        post.sections.append(section);\n      }\n    }, {\n      key: 'parseImageSection',\n      value: function parseImageSection(_ref4, post) {\n        var _ref42 = _slicedToArray(_ref4, 2);\n\n        var type = _ref42[0];\n        var src = _ref42[1];\n\n        var section = this.builder.createImageSection(src);\n        post.sections.append(section);\n      }\n    }, {\n      key: 'parseMarkupSection',\n      value: function parseMarkupSection(_ref5, post) {\n        var _ref52 = _slicedToArray(_ref5, 3);\n\n        var type = _ref52[0];\n        var tagName = _ref52[1];\n        var markers = _ref52[2];\n\n        var section = this.builder.createMarkupSection(tagName);\n        post.sections.append(section);\n        this.parseMarkers(markers, section);\n        if (section.markers.isEmpty) {\n          var marker = this.builder.createBlankMarker();\n          section.markers.append(marker);\n        }\n      }\n    }, {\n      key: 'parseMarkers',\n      value: function parseMarkers(markers, section) {\n        var _this3 = this;\n\n        markers.forEach(function (marker) {\n          return _this3.parseMarker(marker, section);\n        });\n      }\n    }, {\n      key: 'parseMarker',\n      value: function parseMarker(_ref6, section) {\n        var _this4 = this;\n\n        var _ref62 = _slicedToArray(_ref6, 3);\n\n        var markerTypeIndexes = _ref62[0];\n        var closeCount = _ref62[1];\n        var value = _ref62[2];\n\n        markerTypeIndexes.forEach(function (index) {\n          _this4.markups.push(_this4.markerTypes[index]);\n        });\n        var marker = this.builder.createMarker(value, this.markups.slice());\n        section.markers.append(marker);\n        this.markups = this.markups.slice(0, this.markups.length - closeCount);\n      }\n    }]);\n\n    return MobiledocParser;\n  })();\n\n  exports['default'] = MobiledocParser;\n});","define('content-kit-editor/parsers/post', ['exports', 'content-kit-editor/models/markup-section', 'content-kit-editor/parsers/section', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/renderers/editor-dom', 'content-kit-editor/models/markup'], function (exports, _contentKitEditorModelsMarkupSection, _contentKitEditorParsersSection, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsDomUtils, _contentKitEditorRenderersEditorDom, _contentKitEditorModelsMarkup) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var sanitizeTextRegex = new RegExp(_contentKitEditorRenderersEditorDom.UNPRINTABLE_CHARACTER, 'g');\n\n  function sanitizeText(text) {\n    return text.replace(sanitizeTextRegex, '');\n  }\n\n  var PostParser = (function () {\n    function PostParser(builder) {\n      _classCallCheck(this, PostParser);\n\n      this.builder = builder;\n      this.sectionParser = new _contentKitEditorParsersSection['default'](this.builder);\n    }\n\n    _createClass(PostParser, [{\n      key: 'parse',\n      value: function parse(element) {\n        var _this = this;\n\n        var post = this.builder.createPost();\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(element.childNodes, function (child) {\n          post.sections.append(_this.sectionParser.parse(child));\n        });\n\n        return post;\n      }\n    }, {\n      key: 'parseSection',\n      value: function parseSection(element, otherArg) {\n        if (!!otherArg) {\n          element = otherArg; // hack to deal with passed previousSection\n        }\n        return this.sectionParser.parse(element);\n      }\n\n      // FIXME should move to the section parser?\n      // FIXME the `collectMarkups` logic could simplify the section parser?\n    }, {\n      key: 'reparseSection',\n      value: function reparseSection(section, renderTree) {\n        var _this2 = this;\n\n        if (section.type !== _contentKitEditorModelsMarkupSection.MARKUP_SECTION_TYPE) {\n          // can only reparse markup sections\n          return;\n        }\n        var sectionElement = section.renderNode.element;\n\n        // Turn an element node into a markup\n        var markupFromNode = function markupFromNode(node) {\n          if (_contentKitEditorModelsMarkup['default'].isValidElement(node)) {\n            var tagName = node.tagName;\n            var attributes = (0, _contentKitEditorUtilsDomUtils.getAttributesArray)(node);\n\n            return _this2.builder.createMarkup(tagName, attributes);\n          }\n        };\n\n        // walk up from the textNode until the rootNode, converting each\n        // parentNode into a markup\n        var collectMarkups = function collectMarkups(textNode, rootNode) {\n          var markups = [];\n          var currentNode = textNode.parentNode;\n          while (currentNode && currentNode !== rootNode) {\n            var markup = markupFromNode(currentNode);\n            if (markup) {\n              markups.push(markup);\n            }\n\n            currentNode = currentNode.parentNode;\n          }\n          return markups;\n        };\n\n        var seenRenderNodes = [];\n        var previousMarker = undefined;\n\n        (0, _contentKitEditorUtilsDomUtils.walkTextNodes)(sectionElement, function (textNode) {\n          var text = sanitizeText(textNode.textContent);\n          var markups = collectMarkups(textNode, sectionElement);\n\n          var marker = undefined;\n\n          var renderNode = renderTree.getElementRenderNode(textNode);\n          if (renderNode) {\n            if (text.length) {\n              marker = renderNode.postNode;\n              marker.value = text;\n              marker.markups = markups;\n            } else {\n              renderNode.scheduleForRemoval();\n            }\n          } else {\n            marker = _this2.builder.createMarker(text, markups);\n\n            // create a cleaned render node to account for the fact that this\n            // render node comes from already-displayed DOM\n            // FIXME this should be cleaner\n            renderNode = renderTree.buildRenderNode(marker);\n            renderNode.element = textNode;\n            renderNode.markClean();\n\n            if (previousMarker) {\n              // insert this marker after the previous one\n              section.markers.insertAfter(marker, previousMarker);\n              section.renderNode.childNodes.insertAfter(renderNode, previousMarker.renderNode);\n            } else {\n              // insert marker at the beginning of the section\n              section.markers.prepend(marker);\n              section.renderNode.childNodes.insertAfter(renderNode, null);\n            }\n\n            // find the nextMarkerElement, set it on the render node\n            var parentNodeCount = marker.closedMarkups.length;\n            var nextMarkerElement = textNode.parentNode;\n            while (parentNodeCount--) {\n              nextMarkerElement = nextMarkerElement.parentNode;\n            }\n            renderNode.nextMarkerElement = nextMarkerElement;\n          }\n\n          seenRenderNodes.push(renderNode);\n          previousMarker = marker;\n        });\n\n        // remove any nodes that were not marked as seen\n        section.renderNode.childNodes.forEach(function (childRenderNode) {\n          if (seenRenderNodes.indexOf(childRenderNode) === -1) {\n            childRenderNode.scheduleForRemoval();\n          }\n        });\n\n        /** FIXME that we are reparsing and there are no markers should never\n         * happen. We manage the delete key on our own. */\n        if (section.markers.isEmpty) {\n          var marker = this.builder.createBlankMarker();\n          section.markers.append(marker);\n        }\n      }\n    }]);\n\n    return PostParser;\n  })();\n\n  exports['default'] = PostParser;\n});","define('content-kit-editor/parsers/section', ['exports', 'content-kit-editor/models/markup-section', 'content-kit-editor/models/markup', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsMarkup, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var TEXT_NODE = 3;\n  var ELEMENT_NODE = 1;\n\n  /**\n   * parses an element into a section, ignoring any non-markup\n   * elements contained within\n   * @return {Section}\n   */\n\n  var SectionParser = (function () {\n    function SectionParser(builder) {\n      _classCallCheck(this, SectionParser);\n\n      this.builder = builder;\n    }\n\n    _createClass(SectionParser, [{\n      key: 'parse',\n      value: function parse(element) {\n        var _this = this;\n\n        var tagName = this.sectionTagNameFromElement(element);\n        var section = this.builder.createMarkupSection(tagName);\n        var state = { section: section, markups: [], text: '' };\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(element.childNodes, function (el) {\n          _this.parseNode(el, state);\n        });\n\n        // close a trailing text nodes if it exists\n        if (state.text.length) {\n          var marker = this.builder.createMarker(state.text, state.markups);\n          state.section.markers.append(marker);\n        }\n\n        if (section.markers.length === 0) {\n          section.markers.append(this.builder.createBlankMarker());\n        }\n\n        return section;\n      }\n    }, {\n      key: 'parseNode',\n      value: function parseNode(node, state) {\n        switch (node.nodeType) {\n          case TEXT_NODE:\n            this.parseTextNode(node, state);\n            break;\n          case ELEMENT_NODE:\n            this.parseElementNode(node, state);\n            break;\n          default:\n            throw new Error('parseNode got unexpected element type ' + node.nodeType + ' ' + node);\n        }\n      }\n    }, {\n      key: 'parseElementNode',\n      value: function parseElementNode(element, state) {\n        var _this2 = this;\n\n        var markup = this.markupFromElement(element);\n        if (markup) {\n          if (state.text.length) {\n            // close previous text marker\n            var marker = this.builder.createMarker(state.text, state.markups);\n            state.section.markers.append(marker);\n            state.text = '';\n          }\n\n          state.markups.push(markup);\n        }\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(element.childNodes, function (node) {\n          _this2.parseNode(node, state);\n        });\n\n        if (markup) {\n          // close the marker started for this node and pop\n          // its markup from the stack\n          var marker = this.builder.createMarker(state.text, state.markups);\n          state.section.markers.append(marker);\n          state.markups.pop();\n          state.text = '';\n        }\n      }\n    }, {\n      key: 'parseTextNode',\n      value: function parseTextNode(textNode, state) {\n        state.text += textNode.textContent;\n      }\n    }, {\n      key: 'isSectionElement',\n      value: function isSectionElement(element) {\n        return element.nodeType === ELEMENT_NODE && _contentKitEditorModelsMarkupSection.VALID_MARKUP_SECTION_TAGNAMES.indexOf((0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName)) !== -1;\n      }\n    }, {\n      key: 'markupFromElement',\n      value: function markupFromElement(element) {\n        var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n        if (_contentKitEditorModelsMarkup.VALID_MARKUP_TAGNAMES.indexOf(tagName) === -1) {\n          return null;\n        }\n\n        return this.builder.createMarkup(tagName, (0, _contentKitEditorUtilsDomUtils.getAttributes)(element));\n      }\n    }, {\n      key: 'sectionTagNameFromElement',\n      value: function sectionTagNameFromElement(element) {\n        var tagName = element.tagName;\n        tagName = tagName && (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        if (_contentKitEditorModelsMarkupSection.VALID_MARKUP_SECTION_TAGNAMES.indexOf(tagName) === -1) {\n          tagName = _contentKitEditorModelsMarkupSection.DEFAULT_TAG_NAME;\n        }\n        return tagName;\n      }\n    }]);\n\n    return SectionParser;\n  })();\n\n  exports['default'] = SectionParser;\n});","define(\"content-kit-editor/renderers/editor-dom\", [\"exports\", \"content-kit-editor/models/render-node\", \"content-kit-editor/models/card-node\", \"content-kit-editor/utils/array-utils\", \"content-kit-editor/models/post\", \"content-kit-editor/models/markup-section\", \"content-kit-editor/models/marker\", \"content-kit-editor/models/image\", \"content-kit-editor/models/card\", \"content-kit-editor/utils/dom-utils\", \"content-kit-editor/utils/string-utils\"], function (exports, _contentKitEditorModelsRenderNode, _contentKitEditorModelsCardNode, _contentKitEditorUtilsArrayUtils, _contentKitEditorModelsPost, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsMarker, _contentKitEditorModelsImage, _contentKitEditorModelsCard, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsStringUtils) {\n  \"use strict\";\n\n  var _destroyHooks;\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var UNPRINTABLE_CHARACTER = \"‌\";\n  exports.UNPRINTABLE_CHARACTER = UNPRINTABLE_CHARACTER;\n  var NO_BREAK_SPACE = \" \";\n  exports.NO_BREAK_SPACE = NO_BREAK_SPACE;\n  var SPACE = ' ';\n\n  function createElementFromMarkup(doc, markup) {\n    var element = doc.createElement(markup.tagName);\n    if (markup.attributes) {\n      for (var i = 0, l = markup.attributes.length; i < l; i = i + 2) {\n        element.setAttribute(markup.attributes[i], markup.attributes[i + 1]);\n      }\n    }\n    return element;\n  }\n\n  // ascends from element upward, returning the last parent node that is not\n  // parentElement\n  function penultimateParentOf(element, parentElement) {\n    while (parentElement && element.parentNode !== parentElement && element.parentElement !== document.body // ensure the while loop stops\n    ) {\n      element = element.parentNode;\n    }\n    return element;\n  }\n\n  function renderMarkupSection(section) {\n    var element = document.createElement(section.tagName);\n    section.element = element;\n    return element;\n  }\n\n  function getNextMarkerElement(renderNode) {\n    var element = renderNode._teardownElement.parentNode;\n    var marker = renderNode.postNode;\n    var closedCount = marker.closedMarkups.length;\n\n    while (closedCount--) {\n      element = element.parentNode;\n    }\n    return element;\n  }\n\n  function renderBlankMarker(marker, element, previousRenderNode) {\n    var blankElement = document.createElement('br');\n\n    if (previousRenderNode) {\n      // FIXME there should never be a previousRenderNode for a blank marker\n      var previousSibling = previousRenderNode.element;\n      var previousSiblingPenultimate = penultimateParentOf(previousSibling, element);\n      element.insertBefore(blankElement, previousSiblingPenultimate.nextSibling);\n    } else {\n      element.insertBefore(blankElement, element.firstChild);\n    }\n\n    return blankElement;\n  }\n\n  function renderMarker(marker, element, previousRenderNode) {\n    var text = marker.value;\n\n    // If the first marker has a leading space or the last marker has a\n    // trailing space, the browser will collapse the space when we position\n    // the cursor.\n    // See https://github.com/bustlelabs/content-kit-editor/issues/68\n    //   and https://github.com/bustlelabs/content-kit-editor/issues/75\n    if (!marker.next && (0, _contentKitEditorUtilsStringUtils.endsWith)(text, SPACE)) {\n      text = text.substr(0, text.length - 1) + NO_BREAK_SPACE;\n    } else if (!marker.prev && (0, _contentKitEditorUtilsStringUtils.startsWith)(text, SPACE)) {\n      text = NO_BREAK_SPACE + text.substr(1);\n    }\n\n    var textNode = document.createTextNode(text);\n    var currentElement = textNode;\n    var markup = undefined;\n\n    var openTypes = marker.openedMarkups;\n    for (var j = openTypes.length - 1; j >= 0; j--) {\n      markup = openTypes[j];\n      var openedElement = createElementFromMarkup(document, markup);\n      openedElement.appendChild(currentElement);\n      currentElement = openedElement;\n    }\n\n    if (previousRenderNode) {\n      var previousSibling = previousRenderNode.element;\n      var previousSiblingPenultimate = penultimateParentOf(previousSibling, element);\n      element.insertBefore(currentElement, previousSiblingPenultimate.nextSibling);\n    } else {\n      element.insertBefore(currentElement, element.firstChild);\n    }\n\n    return textNode;\n  }\n\n  var Visitor = (function () {\n    function Visitor(editor, cards, unknownCardHandler, options) {\n      _classCallCheck(this, Visitor);\n\n      this.editor = editor;\n      this.cards = cards;\n      this.unknownCardHandler = unknownCardHandler;\n      this.options = options;\n    }\n\n    _createClass(Visitor, [{\n      key: _contentKitEditorModelsPost.POST_TYPE,\n      value: function value(renderNode, post, visit) {\n        if (!renderNode.element) {\n          var element = document.createElement('div');\n          renderNode.element = element;\n        }\n        visit(renderNode, post.sections);\n      }\n    }, {\n      key: _contentKitEditorModelsMarkupSection.MARKUP_SECTION_TYPE,\n      value: function value(renderNode, section, visit) {\n        var originalElement = renderNode.element;\n        var hasRendered = !!originalElement;\n\n        // Always rerender the section -- its tag name or attributes may have changed.\n        // TODO make this smarter, only rerendering and replacing the element when necessary\n        var element = renderMarkupSection(section);\n        renderNode.element = element;\n\n        if (!hasRendered) {\n          var _element = renderNode.element;\n\n          if (renderNode.prev) {\n            var previousElement = renderNode.prev.element;\n            var parentNode = previousElement.parentNode;\n            parentNode.insertBefore(_element, previousElement.nextSibling);\n          } else {\n            var parentElement = renderNode.parent.element;\n            parentElement.insertBefore(_element, parentElement.firstChild);\n          }\n        } else {\n          renderNode.parent.element.replaceChild(element, originalElement);\n        }\n\n        // remove all elements so that we can rerender\n        (0, _contentKitEditorUtilsDomUtils.clearChildNodes)(renderNode.element);\n\n        var visitAll = true;\n        visit(renderNode, section.markers, visitAll);\n      }\n    }, {\n      key: _contentKitEditorModelsMarker.MARKER_TYPE,\n      value: function value(renderNode, marker) {\n        var parentElement = undefined;\n\n        if (renderNode.prev) {\n          parentElement = getNextMarkerElement(renderNode.prev);\n        } else {\n          parentElement = renderNode.parent.element;\n        }\n        var markerNode = undefined,\n            focusableNode = undefined;\n        if (marker.isEmpty) {\n          markerNode = renderBlankMarker(marker, parentElement, renderNode.prev);\n          focusableNode = markerNode.parentNode;\n        } else {\n          markerNode = focusableNode = renderMarker(marker, parentElement, renderNode.prev);\n        }\n\n        renderNode.renderTree.elements.set(focusableNode, renderNode);\n        renderNode.element = focusableNode;\n        renderNode._teardownElement = markerNode;\n      }\n    }, {\n      key: _contentKitEditorModelsImage.IMAGE_SECTION_TYPE,\n      value: function value(renderNode, section) {\n        if (renderNode.element) {\n          if (renderNode.element.src !== section.src) {\n            renderNode.element.src = section.src;\n          }\n        } else {\n          var element = document.createElement('img');\n          element.src = section.src;\n          if (renderNode.prev) {\n            var previousElement = renderNode.prev.element;\n            var nextElement = previousElement.nextSibling;\n            if (nextElement) {\n              nextElement.parentNode.insertBefore(element, nextElement);\n            }\n          }\n          if (!element.parentNode) {\n            renderNode.parent.element.appendChild(element);\n          }\n          renderNode.element = element;\n        }\n      }\n    }, {\n      key: _contentKitEditorModelsCard.CARD_TYPE,\n      value: function value(renderNode, section) {\n        var editor = this.editor;\n        var options = this.options;\n\n        var card = (0, _contentKitEditorUtilsArrayUtils.detect)(this.cards, function (card) {\n          return card.name === section.name;\n        });\n\n        var env = { name: section.name };\n        var element = document.createElement('div');\n        element.contentEditable = 'false';\n        renderNode.element = element;\n        if (renderNode.prev) {\n          var previousElement = renderNode.prev.element;\n          var nextElement = previousElement.nextSibling;\n          if (nextElement) {\n            nextElement.parentNode.insertBefore(element, nextElement);\n          }\n        }\n        if (!element.parentNode) {\n          renderNode.parent.element.appendChild(element);\n        }\n\n        if (card) {\n          var cardNode = new _contentKitEditorModelsCardNode[\"default\"](editor, card, section, renderNode.element, options);\n          renderNode.cardNode = cardNode;\n          cardNode.display();\n        } else {\n          this.unknownCardHandler(renderNode.element, options, env, section.payload);\n        }\n      }\n    }]);\n\n    return Visitor;\n  })();\n\n  var destroyHooks = (_destroyHooks = {}, _defineProperty(_destroyHooks, _contentKitEditorModelsPost.POST_TYPE, function () /*renderNode, post*/{\n    throw new Error('post destruction is not supported by the renderer');\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsMarkupSection.MARKUP_SECTION_TYPE, function (renderNode, section) {\n    var post = renderNode.parent.postNode;\n    post.sections.remove(section);\n    // Some formatting commands remove the element from the DOM during\n    // formatting. Do not error if this is the case.\n    if (renderNode.element.parentNode) {\n      renderNode.element.parentNode.removeChild(renderNode.element);\n    }\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsMarker.MARKER_TYPE, function (renderNode, marker) {\n    // FIXME before we render marker, should delete previous renderNode's element\n    // and up until the next marker element\n\n    var element = renderNode._teardownElement;\n    var nextMarkerElement = getNextMarkerElement(renderNode);\n    while (element.parentNode && element.parentNode !== nextMarkerElement) {\n      element = element.parentNode;\n    }\n\n    if (marker.section) {\n      marker.section.markers.remove(marker);\n    }\n\n    if (element.parentNode) {\n      // if no parentNode, the browser already removed this element\n      element.parentNode.removeChild(element);\n    }\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsImage.IMAGE_SECTION_TYPE, function (renderNode, section) {\n    var post = renderNode.parent.postNode;\n    post.sections.remove(section);\n    renderNode.element.parentNode.removeChild(renderNode.element);\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsCard.CARD_TYPE, function (renderNode, section) {\n    if (renderNode.cardNode) {\n      renderNode.cardNode.teardown();\n    }\n    var post = renderNode.parent.postNode;\n    post.sections.remove(section);\n    renderNode.element.parentNode.removeChild(renderNode.element);\n  }), _destroyHooks);\n\n  // removes children from parentNode that are scheduled for removal\n  function removeChildren(parentNode) {\n    var child = parentNode.childNodes.head;\n    while (child) {\n      var nextChild = child.next;\n      if (child.isRemoved) {\n        destroyHooks[child.postNode.type](child, child.postNode);\n        parentNode.childNodes.remove(child);\n      }\n      child = nextChild;\n    }\n  }\n\n  // Find an existing render node for the given postNode, or\n  // create one, insert it into the tree, and return it\n  function lookupNode(renderTree, parentNode, postNode, previousNode) {\n    if (postNode.renderNode) {\n      return postNode.renderNode;\n    } else {\n      var renderNode = new _contentKitEditorModelsRenderNode[\"default\"](postNode);\n      parentNode.childNodes.insertAfter(renderNode, previousNode);\n      postNode.renderNode = renderNode;\n      return renderNode;\n    }\n  }\n\n  var Renderer = (function () {\n    function Renderer(editor, cards, unknownCardHandler, options) {\n      _classCallCheck(this, Renderer);\n\n      this.editor = editor;\n      this.visitor = new Visitor(editor, cards, unknownCardHandler, options);\n      this.nodes = [];\n    }\n\n    _createClass(Renderer, [{\n      key: \"visit\",\n      value: function visit(renderTree, parentNode, postNodes) {\n        var _this = this;\n\n        var visitAll = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        var previousNode = undefined;\n        postNodes.forEach(function (postNode) {\n          var node = lookupNode(renderTree, parentNode, postNode, previousNode);\n          if (node.isDirty || visitAll) {\n            _this.nodes.push(node);\n          }\n          previousNode = node;\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(renderTree) {\n        var _this2 = this;\n\n        var node = renderTree.node;\n        while (node) {\n          removeChildren(node);\n          this.visitor[node.postNode.type](node, node.postNode, function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return _this2.visit.apply(_this2, [renderTree].concat(args));\n          });\n          node.markClean();\n          node = this.nodes.shift();\n        }\n      }\n    }]);\n\n    return Renderer;\n  })();\n\n  exports[\"default\"] = Renderer;\n});","define(\"content-kit-editor/renderers/mobiledoc\", [\"exports\", \"content-kit-editor/utils/compiler\", \"content-kit-editor/models/post\", \"content-kit-editor/models/markup-section\", \"content-kit-editor/models/image\", \"content-kit-editor/models/marker\", \"content-kit-editor/models/markup\", \"content-kit-editor/models/card\"], function (exports, _contentKitEditorUtilsCompiler, _contentKitEditorModelsPost, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsImage, _contentKitEditorModelsMarker, _contentKitEditorModelsMarkup, _contentKitEditorModelsCard) {\n  \"use strict\";\n\n  var _visitor;\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n  var MOBILEDOC_VERSION = '0.1';\n\n  exports.MOBILEDOC_VERSION = MOBILEDOC_VERSION;\n  var visitor = (_visitor = {}, _defineProperty(_visitor, _contentKitEditorModelsPost.POST_TYPE, function (node, opcodes) {\n    opcodes.push(['openPost']);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.sections, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsMarkupSection.MARKUP_SECTION_TYPE, function (node, opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName]);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.markers, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsImage.IMAGE_SECTION_TYPE, function (node, opcodes) {\n    opcodes.push(['openImageSection', node.src]);\n  }), _defineProperty(_visitor, _contentKitEditorModelsCard.CARD_TYPE, function (node, opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload]);\n  }), _defineProperty(_visitor, _contentKitEditorModelsMarker.MARKER_TYPE, function (node, opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.openedMarkups, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsMarkup.MARKUP_TYPE, function (node, opcodes) {\n    opcodes.push(['openMarkup', node.tagName, node.attributes]);\n  }), _visitor);\n\n  var postOpcodeCompiler = {\n    openMarker: function openMarker(closeCount, value) {\n      this.markupMarkerIds = [];\n      this.markers.push([this.markupMarkerIds, closeCount, value || '']);\n    },\n    openMarkupSection: function openMarkupSection(tagName) {\n      this.markers = [];\n      this.sections.push([1, tagName, this.markers]);\n    },\n    openImageSection: function openImageSection(url) {\n      this.sections.push([2, url]);\n    },\n    openCardSection: function openCardSection(name, payload) {\n      this.sections.push([10, name, payload]);\n    },\n    openPost: function openPost() {\n      this.markerTypes = [];\n      this.sections = [];\n      this.result = {\n        version: MOBILEDOC_VERSION,\n        sections: [this.markerTypes, this.sections]\n      };\n    },\n    openMarkup: function openMarkup(tagName, attributes) {\n      if (!this._seenMarkerTypes) {\n        this._seenMarkerTypes = {};\n      }\n      var index = undefined;\n      if (attributes.length) {\n        this.markerTypes.push([tagName, attributes]);\n        index = this.markerTypes.length - 1;\n      } else {\n        index = this._seenMarkerTypes[tagName];\n        if (index === undefined) {\n          this.markerTypes.push([tagName]);\n          this._seenMarkerTypes[tagName] = index = this.markerTypes.length - 1;\n        }\n      }\n      this.markupMarkerIds.push(index);\n    }\n  };\n\n  exports[\"default\"] = {\n    render: function render(post) {\n      var opcodes = [];\n      (0, _contentKitEditorUtilsCompiler.visit)(visitor, post, opcodes);\n      var compiler = Object.create(postOpcodeCompiler);\n      (0, _contentKitEditorUtilsCompiler.compile)(compiler, opcodes);\n      return compiler.result;\n    }\n  };\n});","define(\"content-kit-editor/utils/array-utils\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  function detect(enumerable, callback) {\n    if (enumerable.detect) {\n      return enumerable.detect(callback);\n    } else {\n      for (var i = 0; i < enumerable.length; i++) {\n        if (callback(enumerable[i])) {\n          return enumerable[i];\n        }\n      }\n    }\n  }\n\n  function any(array, callback) {\n    for (var i = 0; i < array.length; i++) {\n      if (callback(array[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Useful for array-like things that aren't\n   * actually arrays, like NodeList\n   */\n  function forEach(enumerable, callback) {\n    if (enumerable.forEach) {\n      enumerable.forEach(callback);\n    } else {\n      for (var i = 0; i < enumerable.length; i++) {\n        callback(enumerable[i], i);\n      }\n    }\n  }\n\n  function filter(enumerable, conditionFn) {\n    var filtered = [];\n    forEach(enumerable, function (i) {\n      if (conditionFn(i)) {\n        filtered.push(i);\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * @return {Integer} the number of items that are the same, starting from the 0th index, in a and b\n   */\n  function commonItemLength(listA, listB) {\n    var offset = 0;\n    while (offset < listA.length && offset < listB.length) {\n      if (listA[offset] !== listB[offset]) {\n        break;\n      }\n      offset++;\n    }\n    return offset;\n  }\n\n  exports.detect = detect;\n  exports.forEach = forEach;\n  exports.any = any;\n  exports.filter = filter;\n  exports.commonItemLength = commonItemLength;\n});","define('content-kit-editor/utils/compat', ['exports', 'content-kit-editor/utils/doc', 'content-kit-editor/utils/win'], function (exports, _contentKitEditorUtilsDoc, _contentKitEditorUtilsWin) {\n  'use strict';\n\n  exports.doc = _contentKitEditorUtilsDoc['default'];\n  exports.win = _contentKitEditorUtilsWin['default'];\n});","define(\"content-kit-editor/utils/compiler\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  exports.visit = visit;\n  exports.compile = compile;\n  exports.visitArray = visitArray;\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  function visit(visitor, node, opcodes) {\n    visitor[node.type](node, opcodes);\n  }\n\n  function compile(compiler, opcodes) {\n    for (var i = 0, l = opcodes.length; i < l; i++) {\n      var _opcodes$i = _toArray(opcodes[i]);\n\n      var method = _opcodes$i[0];\n\n      var params = _opcodes$i.slice(1);\n\n      if (params.length) {\n        compiler[method].apply(compiler, params);\n      } else {\n        compiler[method].call(compiler);\n      }\n    }\n  }\n\n  function visitArray(visitor, nodes, opcodes) {\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n    nodes.forEach(function (node) {\n      visit(visitor, node, opcodes);\n    });\n  }\n});","define('content-kit-editor/utils/dom-utils', ['exports', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var TEXT_NODE_TYPE = 3;\n\n  function detectParentNode(element, callback) {\n    while (element) {\n      var result = callback(element);\n      if (result) {\n        return {\n          element: element,\n          result: result\n        };\n      }\n      element = element.parentNode;\n    }\n\n    return {\n      element: null,\n      result: null\n    };\n  }\n\n  function isTextNode(node) {\n    return node.nodeType === TEXT_NODE_TYPE;\n  }\n\n  // perform a pre-order tree traversal of the dom, calling `callbackFn(node)`\n  // for every node for which `conditionFn(node)` is true\n  function walkDOM(topNode) {\n    var callbackFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n    var conditionFn = arguments.length <= 2 || arguments[2] === undefined ? function () {\n      return true;\n    } : arguments[2];\n\n    var currentNode = topNode;\n\n    if (conditionFn(currentNode)) {\n      callbackFn(currentNode);\n    }\n\n    currentNode = currentNode.firstChild;\n\n    while (currentNode) {\n      walkDOM(currentNode, callbackFn, conditionFn);\n      currentNode = currentNode.nextSibling;\n    }\n  }\n\n  function walkTextNodes(topNode) {\n    var callbackFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    var conditionFn = function conditionFn(node) {\n      return isTextNode(node);\n    };\n    walkDOM(topNode, callbackFn, conditionFn);\n  }\n\n  function clearChildNodes(element) {\n    while (element.childNodes.length) {\n      element.removeChild(element.childNodes[0]);\n    }\n  }\n\n  // walks DOWN the dom from node to childNodes, returning the element\n  // for which `conditionFn(element)` is true\n  function walkDOMUntil(topNode) {\n    var conditionFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    if (!topNode) {\n      throw new Error('Cannot call walkDOMUntil without a node');\n    }\n    var stack = [topNode];\n    var currentElement = undefined;\n\n    while (stack.length) {\n      currentElement = stack.pop();\n\n      if (conditionFn(currentElement)) {\n        return currentElement;\n      }\n\n      (0, _contentKitEditorUtilsArrayUtils.forEach)(currentElement.childNodes, function (el) {\n        return stack.push(el);\n      });\n    }\n  }\n\n  // see https://github.com/webmodules/node-contains/blob/master/index.js\n  function containsNode(parentNode, childNode) {\n    var isSame = function isSame() {\n      return parentNode === childNode;\n    };\n    var isContainedBy = function isContainedBy() {\n      var position = parentNode.compareDocumentPosition(childNode);\n      return !!(position & Node.DOCUMENT_POSITION_CONTAINED_BY);\n    };\n    return isSame() || isContainedBy();\n  }\n\n  /**\n   * converts the element's NamedNodeMap of attrs into\n   * an object with key-value pairs\n   * FIXME should add a whitelist as a second arg\n   */\n  function getAttributes(element) {\n    var result = {};\n    if (element.hasAttributes()) {\n      var attributes = element.attributes;\n\n      (0, _contentKitEditorUtilsArrayUtils.forEach)(attributes, function (_ref) {\n        var name = _ref.name;\n        var value = _ref.value;\n        return result[name] = value;\n      });\n    }\n    return result;\n  }\n\n  /**\n   * converts the element's NamedNodeMap of attrs into\n   * an array of key1,value1,key2,value2,...\n   * FIXME should add a whitelist as a second arg\n   */\n  function getAttributesArray(element) {\n    var attributes = getAttributes(element);\n    var result = [];\n    Object.keys(attributes).forEach(function (key) {\n      result.push(key);\n      result.push(attributes[key]);\n    });\n    return result;\n  }\n\n  function addClassName(element, className) {\n    // FIXME-IE IE10+\n    element.classList.add(className);\n  }\n\n  function normalizeTagName(tagName) {\n    return tagName.toLowerCase();\n  }\n\n  function parseHTML(html) {\n    var div = document.createElement('div');\n    div.innerHTML = html;\n    return div;\n  }\n\n  exports.detectParentNode = detectParentNode;\n  exports.containsNode = containsNode;\n  exports.clearChildNodes = clearChildNodes;\n  exports.getAttributes = getAttributes;\n  exports.getAttributesArray = getAttributesArray;\n  exports.walkDOMUntil = walkDOMUntil;\n  exports.walkDOM = walkDOM;\n  exports.walkTextNodes = walkTextNodes;\n  exports.addClassName = addClassName;\n  exports.normalizeTagName = normalizeTagName;\n  exports.isTextNode = isTextNode;\n  exports.parseHTML = parseHTML;\n});","define('content-kit-editor/utils/element-map', ['exports'], function (exports) {\n  // start at one to make the falsy semantics easier\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var uuidGenerator = 1;\n\n  var ElementMap = (function () {\n    function ElementMap() {\n      _classCallCheck(this, ElementMap);\n\n      this._map = {};\n    }\n\n    _createClass(ElementMap, [{\n      key: 'set',\n      value: function set(key, value) {\n        var uuid = key._uuid;\n        if (!uuid) {\n          key._uuid = uuid = '' + uuidGenerator++;\n        }\n        this._map[uuid] = value;\n      }\n    }, {\n      key: 'get',\n      value: function get(key) {\n        if (key._uuid) {\n          return this._map[key._uuid];\n        }\n        return null;\n      }\n    }, {\n      key: 'remove',\n      value: function remove(key) {\n        if (!key._uuid) {\n          throw new Error('tried to fetch a value for an element not seen before');\n        }\n        delete this._map[key._uuid];\n      }\n    }]);\n\n    return ElementMap;\n  })();\n\n  exports['default'] = ElementMap;\n});","define('content-kit-editor/utils/element-utils', ['exports', 'content-kit-editor/utils/string-utils', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsStringUtils, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  function createDiv(className) {\n    var div = document.createElement('div');\n    if (className) {\n      div.className = className;\n    }\n    return div;\n  }\n\n  function hideElement(element) {\n    element.style.display = 'none';\n  }\n\n  function showElement(element) {\n    element.style.display = 'block';\n  }\n\n  function swapElements(elementToShow, elementToHide) {\n    hideElement(elementToHide);\n    showElement(elementToShow);\n  }\n\n  function getEventTargetMatchingTag(tagName, target, container) {\n    tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n    // Traverses up DOM from an event target to find the node matching specifed tag\n    while (target && target !== container) {\n      if ((0, _contentKitEditorUtilsDomUtils.normalizeTagName)(target.tagName) === tagName) {\n        return target;\n      }\n      target = target.parentNode;\n    }\n  }\n\n  function getElementRelativeOffset(element) {\n    var offset = { left: 0, top: -window.pageYOffset };\n    var offsetParent = element.offsetParent;\n    var offsetParentPosition = window.getComputedStyle(offsetParent).position;\n    var offsetParentRect;\n\n    if (offsetParentPosition === 'relative') {\n      offsetParentRect = offsetParent.getBoundingClientRect();\n      offset.left = offsetParentRect.left;\n      offset.top = offsetParentRect.top;\n    }\n    return offset;\n  }\n\n  function getElementComputedStyleNumericProp(element, prop) {\n    return parseFloat(window.getComputedStyle(element)[prop]);\n  }\n\n  function positionElementToRect(element, rect, topOffset, leftOffset) {\n    var relativeOffset = getElementRelativeOffset(element);\n    var style = element.style;\n    var round = Math.round;\n    var left, top;\n\n    topOffset = topOffset || 0;\n    leftOffset = leftOffset || 0;\n    left = round(rect.left - relativeOffset.left - leftOffset);\n    top = round(rect.top - relativeOffset.top - topOffset);\n    style.left = left + 'px';\n    style.top = top + 'px';\n    return { left: left, top: top };\n  }\n\n  function positionElementHorizontallyCenteredToRect(element, rect, topOffset) {\n    var horizontalCenter = element.offsetWidth / 2 - rect.width / 2;\n    return positionElementToRect(element, rect, topOffset, horizontalCenter);\n  }\n\n  function positionElementCenteredAbove(element, aboveElement) {\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginBottom');\n    return positionElementHorizontallyCenteredToRect(element, aboveElement.getBoundingClientRect(), element.offsetHeight + elementMargin);\n  }\n\n  function positionElementCenteredBelow(element, belowElement) {\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginTop');\n    return positionElementHorizontallyCenteredToRect(element, belowElement.getBoundingClientRect(), -element.offsetHeight - elementMargin);\n  }\n\n  function positionElementCenteredIn(element, inElement) {\n    var verticalCenter = inElement.offsetHeight / 2 - element.offsetHeight / 2;\n    return positionElementHorizontallyCenteredToRect(element, inElement.getBoundingClientRect(), -verticalCenter);\n  }\n\n  function positionElementToLeftOf(element, leftOfElement) {\n    var verticalCenter = leftOfElement.offsetHeight / 2 - element.offsetHeight / 2;\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginRight');\n    return positionElementToRect(element, leftOfElement.getBoundingClientRect(), -verticalCenter, element.offsetWidth + elementMargin);\n  }\n\n  function positionElementToRightOf(element, rightOfElement) {\n    var verticalCenter = rightOfElement.offsetHeight / 2 - element.offsetHeight / 2;\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginLeft');\n    var rightOfElementRect = rightOfElement.getBoundingClientRect();\n    return positionElementToRect(element, rightOfElementRect, -verticalCenter, -rightOfElement.offsetWidth - elementMargin);\n  }\n\n  function getData(element, name) {\n    if (element.dataset) {\n      return element.dataset[name];\n    } else {\n      var dataName = (0, _contentKitEditorUtilsStringUtils.dasherize)(name);\n      return element.getAttribute(dataName);\n    }\n  }\n\n  function setData(element, name, value) {\n    if (element.dataset) {\n      element.dataset[name] = value;\n    } else {\n      var dataName = (0, _contentKitEditorUtilsStringUtils.dasherize)(name);\n      return element.setAttribute(dataName, value);\n    }\n  }\n\n  exports.getData = getData;\n  exports.setData = setData;\n  exports.createDiv = createDiv;\n  exports.hideElement = hideElement;\n  exports.showElement = showElement;\n  exports.swapElements = swapElements;\n  exports.getEventTargetMatchingTag = getEventTargetMatchingTag;\n  exports.getElementRelativeOffset = getElementRelativeOffset;\n  exports.getElementComputedStyleNumericProp = getElementComputedStyleNumericProp;\n  exports.positionElementToRect = positionElementToRect;\n  exports.positionElementHorizontallyCenteredToRect = positionElementHorizontallyCenteredToRect;\n  exports.positionElementCenteredAbove = positionElementCenteredAbove;\n  exports.positionElementCenteredBelow = positionElementCenteredBelow;\n  exports.positionElementCenteredIn = positionElementCenteredIn;\n  exports.positionElementToLeftOf = positionElementToLeftOf;\n  exports.positionElementToRightOf = positionElementToRightOf;\n});","define(\"content-kit-editor/utils/event-emitter\", [\"exports\"], function (exports) {\n  // Based on https://github.com/jeromeetienne/microevent.js/blob/master/microevent.js\n  // See also: https://github.com/allouis/minivents/blob/master/minivents.js\n\n  \"use strict\";\n\n  var EventEmitter = {\n    on: function on(type, handler) {\n      var events = this.__events = this.__events || {};\n      events[type] = events[type] || [];\n      events[type].push(handler);\n    },\n    off: function off(type, handler) {\n      var events = this.__events = this.__events || {};\n      if (type in events) {\n        events[type].splice(events[type].indexOf(handler), 1);\n      }\n    },\n    trigger: function trigger(type) {\n      var events = this.__events = this.__events || {};\n      var eventForTypeCount, i;\n      if (type in events) {\n        eventForTypeCount = events[type].length;\n        for (i = 0; i < eventForTypeCount; i++) {\n          events[type][i].apply(this, Array.prototype.slice.call(arguments, 1));\n        }\n      }\n    }\n  };\n\n  exports[\"default\"] = EventEmitter;\n});","define(\"content-kit-editor/utils/event-listener\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var EventListenerMixin = (function () {\n    function EventListenerMixin() {\n      _classCallCheck(this, EventListenerMixin);\n    }\n\n    _createClass(EventListenerMixin, [{\n      key: \"addEventListener\",\n      value: function addEventListener(context, eventName, listener) {\n        if (!this._eventListeners) {\n          this._eventListeners = [];\n        }\n        context.addEventListener(eventName, listener);\n        this._eventListeners.push([context, eventName, listener]);\n      }\n    }, {\n      key: \"removeAllEventListeners\",\n      value: function removeAllEventListeners() {\n        var listeners = this._eventListeners || [];\n        listeners.forEach(function (_ref) {\n          var _ref2 = _toArray(_ref);\n\n          var context = _ref2[0];\n\n          var args = _ref2.slice(1);\n\n          context.removeEventListener.apply(context, _toConsumableArray(args));\n        });\n      }\n    }]);\n\n    return EventListenerMixin;\n  })();\n\n  exports[\"default\"] = EventListenerMixin;\n});","define('content-kit-editor/utils/http-utils', ['exports'], function (exports) {\n  'use strict';\n\n  function createXHR(options) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(options.method, options.url);\n    xhr.onload = function () {\n      var response = xhr.responseText;\n      if (xhr.status === 200) {\n        return options.success.call(this, response);\n      }\n      options.error.call(this, response);\n    };\n    xhr.onerror = function (error) {\n      options.error.call(this, error);\n    };\n    return xhr;\n  }\n\n  function xhrPost(options) {\n    options.method = 'POST';\n    var xhr = createXHR(options);\n    var formData = new FormData();\n    formData.append('file', options.data);\n    try {\n      xhr.send(formData);\n    } catch (error) {}\n  }\n\n  function responseJSON(jsonString) {\n    if (!jsonString) {\n      return null;\n    }\n    try {\n      return window.JSON.parse(jsonString);\n    } catch (e) {\n      return jsonString;\n    }\n  }\n\n  // --------------------------------------------\n\n  function FileUploader(options) {\n    options = options || {};\n    var url = options.url;\n    var maxFileSize = options.maxFileSize;\n    if (url) {\n      this.url = url;\n    } else {\n      throw new Error('FileUploader: setting the `url` to an upload service is required');\n    }\n    if (maxFileSize) {\n      this.maxFileSize = maxFileSize;\n    }\n  }\n\n  FileUploader.prototype.upload = function (options) {\n    if (!options) {\n      return;\n    }\n\n    var fileInput = options.fileInput;\n    var file = options.file || fileInput && fileInput.files && fileInput.files[0];\n    var callback = options.complete;\n    var maxFileSize = this.maxFileSize;\n    if (!file || !(file instanceof window.File)) {\n      return;\n    }\n\n    if (maxFileSize && file.size > maxFileSize) {\n      if (callback) {\n        callback.call(this, null, { message: 'max file size is ' + maxFileSize + ' bytes' });\n      }\n      return;\n    }\n\n    xhrPost({\n      url: this.url,\n      data: file,\n      success: function success(response) {\n        if (callback) {\n          callback.call(this, responseJSON(response));\n        }\n      },\n      error: function error(_error) {\n        if (callback) {\n          callback.call(this, null, responseJSON(_error));\n        }\n      }\n    });\n  };\n\n  exports.FileUploader = FileUploader;\n});","define('content-kit-editor/utils/key', ['exports', 'content-kit-editor/utils/keycodes'], function (exports, _contentKitEditorUtilsKeycodes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var DIRECTION = {\n    FORWARD: 1,\n    BACKWARD: 2\n  };\n\n  exports.DIRECTION = DIRECTION;\n  /**\n   * An abstraction around a KeyEvent\n   * that key listeners in the editor can use\n   * to determine what sort of key was pressed\n   */\n  var Key = (function () {\n    function Key(event) {\n      _classCallCheck(this, Key);\n\n      this.keyCode = event.keyCode;\n      this.event = event;\n    }\n\n    _createClass(Key, [{\n      key: 'isEscape',\n      value: function isEscape() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].ESC;\n      }\n    }, {\n      key: 'isDelete',\n      value: function isDelete() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].BACKSPACE || this.keyCode === _contentKitEditorUtilsKeycodes['default'].DELETE;\n      }\n    }, {\n      key: 'isForwardDelete',\n      value: function isForwardDelete() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].DELETE;\n      }\n    }, {\n      key: 'isSpace',\n      value: function isSpace() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].SPACE;\n      }\n    }, {\n      key: 'isEnter',\n      value: function isEnter() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].ENTER;\n      }\n    }, {\n      key: 'isPrintable',\n\n      /**\n       * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Printable_keys_in_standard_position\n       *   and http://stackoverflow.com/a/12467610/137784\n       */\n      value: function isPrintable() {\n        if (this.ctrlKey || this.metaKey) {\n          return false;\n        }\n\n        var code = this.keyCode;\n\n        return code >= _contentKitEditorUtilsKeycodes['default']['0'] && code <= _contentKitEditorUtilsKeycodes['default']['9'] || // number keys\n        this.isSpace() || this.isEnter() || code >= _contentKitEditorUtilsKeycodes['default'].A && code <= _contentKitEditorUtilsKeycodes['default'].Z || // letter keys\n        code >= _contentKitEditorUtilsKeycodes['default'].NUMPAD_0 && code <= _contentKitEditorUtilsKeycodes['default'].NUMPAD_9 || // numpad keys\n        code >= _contentKitEditorUtilsKeycodes['default'][';'] && code <= _contentKitEditorUtilsKeycodes['default']['`'] || // punctuation\n        code >= _contentKitEditorUtilsKeycodes['default']['['] && code <= _contentKitEditorUtilsKeycodes['default']['\"'] ||\n        // FIXME the IME action seems to get lost when we issue an `editor.deleteSelection`\n        // before it (in Chrome)\n        code === _contentKitEditorUtilsKeycodes['default'].IME;\n      }\n    }, {\n      key: 'direction',\n      get: function get() {\n        return this.isForwardDelete() ? DIRECTION.FORWARD : DIRECTION.BACKWARD;\n      }\n    }, {\n      key: 'ctrlKey',\n      get: function get() {\n        return this.event.ctrlKey;\n      }\n    }, {\n      key: 'metaKey',\n      get: function get() {\n        return this.event.metaKey;\n      }\n    }], [{\n      key: 'fromEvent',\n      value: function fromEvent(event) {\n        return new Key(event);\n      }\n    }]);\n\n    return Key;\n  })();\n\n  exports['default'] = Key;\n});","define('content-kit-editor/utils/keycodes', ['exports'], function (exports) {\n  'use strict';\n\n  exports['default'] = {\n    BACKSPACE: 8,\n    SPACE: 32,\n    ENTER: 13,\n    ESC: 27,\n    DELETE: 46,\n    '0': 48,\n    '9': 57,\n    A: 65,\n    Z: 90,\n    'NUMPAD_0': 186,\n    'NUMPAD_9': 111,\n    ';': 186,\n    '`': 192,\n    '[': 219,\n    '\"': 222,\n\n    // Input Method Editor uses multiple keystrokes to display characters.\n    // Example on mac: press option-i then i. This fires 2 key events in Chrome\n    // with keyCode 229 and displays ˆ and then î.\n    // See http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html#fixed-virtual-key-codes\n    IME: 229\n  };\n});","define(\"content-kit-editor/utils/linked-item\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var LinkedItem = function LinkedItem() {\n    _classCallCheck(this, LinkedItem);\n\n    this.next = null;\n    this.prev = null;\n  };\n\n  exports[\"default\"] = LinkedItem;\n});","define('content-kit-editor/utils/linked-list', ['exports'], function (exports) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var LinkedList = (function () {\n    function LinkedList(options) {\n      _classCallCheck(this, LinkedList);\n\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n\n      if (options) {\n        var adoptItem = options.adoptItem;\n        var freeItem = options.freeItem;\n\n        this._adoptItem = adoptItem;\n        this._freeItem = freeItem;\n      }\n    }\n\n    _createClass(LinkedList, [{\n      key: 'adoptItem',\n      value: function adoptItem(item) {\n        if (this._adoptItem) {\n          this._adoptItem(item);\n        }\n      }\n    }, {\n      key: 'freeItem',\n      value: function freeItem(item) {\n        if (this._freeItem) {\n          this._freeItem(item);\n        }\n      }\n    }, {\n      key: 'prepend',\n      value: function prepend(item) {\n        this.insertBefore(item, this.head);\n      }\n    }, {\n      key: 'append',\n      value: function append(item) {\n        this.insertBefore(item, null);\n      }\n    }, {\n      key: 'insertAfter',\n      value: function insertAfter(item, prevItem) {\n        var nextItem = null;\n        if (prevItem) {\n          nextItem = prevItem.next;\n        } else {\n          nextItem = this.head;\n        }\n        this.insertBefore(item, nextItem);\n      }\n    }, {\n      key: 'insertBefore',\n      value: function insertBefore(item, nextItem) {\n        if (item.next || item.prev || this.head === item) {\n          throw new Error('Cannot insert an item into a list if it is already in a list');\n        }\n        this.adoptItem(item);\n\n        if (nextItem && nextItem.prev) {\n          // middle of the items\n          var prevItem = nextItem.prev;\n          item.next = nextItem;\n          nextItem.prev = item;\n          item.prev = prevItem;\n          prevItem.next = item;\n        } else if (nextItem) {\n          // first item\n          if (this.head === nextItem) {\n            item.next = nextItem;\n            nextItem.prev = item;\n          } else {\n            this.tail = item;\n          }\n          this.head = item;\n        } else {\n          // last item\n          if (this.tail) {\n            item.prev = this.tail;\n            this.tail.next = item;\n          }\n          if (!this.head) {\n            this.head = item;\n          }\n          this.tail = item;\n        }\n        this.length++;\n      }\n    }, {\n      key: 'remove',\n      value: function remove(item) {\n        this.freeItem(item);\n\n        var didRemove = false;\n        if (item.next && item.prev) {\n          // Middle of the list\n          item.next.prev = item.prev;\n          item.prev.next = item.next;\n          didRemove = true;\n        } else {\n          if (item === this.head) {\n            // Head of the list\n            if (item.next) {\n              item.next.prev = null;\n            }\n            this.head = item.next;\n            didRemove = true;\n          }\n          if (item === this.tail) {\n            // Tail of the list\n            if (item.prev) {\n              item.prev.next = null;\n            }\n            this.tail = item.prev;\n            didRemove = true;\n          }\n        }\n        if (didRemove) {\n          this.length--;\n        }\n        item.prev = null;\n        item.next = null;\n      }\n    }, {\n      key: 'forEach',\n      value: function forEach(callback) {\n        var item = this.head;\n        var index = 0;\n        while (item) {\n          callback(item, index);\n          index++;\n          item = item.next;\n        }\n      }\n    }, {\n      key: 'walk',\n      value: function walk(startItem, endItem, callback) {\n        var item = startItem || this.head;\n        while (item) {\n          callback(item);\n          if (item === endItem) {\n            break;\n          }\n          item = item.next;\n        }\n      }\n    }, {\n      key: 'readRange',\n      value: function readRange(startItem, endItem) {\n        var items = [];\n        this.walk(startItem, endItem, function (item) {\n          items.push(item);\n        });\n        return items;\n      }\n    }, {\n      key: 'toArray',\n      value: function toArray() {\n        return this.readRange();\n      }\n    }, {\n      key: 'detect',\n      value: function detect(callback) {\n        var item = arguments.length <= 1 || arguments[1] === undefined ? this.head : arguments[1];\n\n        while (item) {\n          if (callback(item)) {\n            return item;\n          }\n          item = item.next;\n        }\n      }\n    }, {\n      key: 'objectAt',\n      value: function objectAt(targetIndex) {\n        var index = -1;\n        return this.detect(function () {\n          index++;\n          return targetIndex === index;\n        });\n      }\n    }, {\n      key: 'splice',\n      value: function splice(targetItem, removalCount, newItems) {\n        var _this = this;\n\n        var item = targetItem;\n        var nextItem = item.next;\n        var count = 0;\n        while (item && count < removalCount) {\n          count++;\n          nextItem = item.next;\n          this.remove(item);\n          item = nextItem;\n        }\n        newItems.forEach(function (newItem) {\n          _this.insertBefore(newItem, nextItem);\n        });\n      }\n    }, {\n      key: 'removeBy',\n      value: function removeBy(conditionFn) {\n        var item = this.head;\n        while (item) {\n          var nextItem = item.next;\n\n          if (conditionFn(item)) {\n            this.remove(item);\n          }\n\n          item = nextItem;\n        }\n      }\n    }, {\n      key: 'isEmpty',\n      get: function get() {\n        return this.length === 0;\n      }\n    }]);\n\n    return LinkedList;\n  })();\n\n  exports['default'] = LinkedList;\n});","define('content-kit-editor/utils/mixin', ['exports'], function (exports) {\n  'use strict';\n\n  exports['default'] = mixin;\n  var CONSTRUCTOR_FN_NAME = 'constructor';\n\n  function mixin(target, source) {\n    target = target.prototype;\n    // Fallback to just `source` to allow mixing in a plain object (pojo)\n    source = source.prototype || source;\n\n    Object.getOwnPropertyNames(source).forEach(function (name) {\n      if (name !== CONSTRUCTOR_FN_NAME) {\n        var descriptor = Object.getOwnPropertyDescriptor(source, name);\n\n        Object.defineProperty(target, name, descriptor);\n      }\n    });\n  }\n});","define('content-kit-editor/utils/selection-utils', ['exports', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  // TODO: remove, pass in Editor's current block set\n  var RootTags = ['p', 'h2', 'h3', 'blockquote', 'ul', 'ol'];\n\n  var SelectionDirection = {\n    LEFT_TO_RIGHT: 1,\n    RIGHT_TO_LEFT: 2,\n    SAME_NODE: 3\n  };\n\n  function clearSelection() {\n    // FIXME-IE ensure this works on IE 9. It works on IE10.\n    window.getSelection().removeAllRanges();\n  }\n\n  function getDirectionOfSelection(selection) {\n    var node = selection.anchorNode;\n    var position = node && node.compareDocumentPosition(selection.focusNode);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return SelectionDirection.LEFT_TO_RIGHT;\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return SelectionDirection.RIGHT_TO_LEFT;\n    }\n    return SelectionDirection.SAME_NODE;\n  }\n\n  function getSelectionElement(selection) {\n    selection = selection || window.getSelection();\n    // FIXME it used to return `anchorNode` when selection direction is `LEFT_TO_RIGHT`,\n    // but I think that was a bug. In Safari and Chrome the selection usually had the\n    // same anchorNode and focusNode when selecting text, so it didn't matter.\n    var node = getDirectionOfSelection(selection) === SelectionDirection.LEFT_TO_RIGHT ? selection.focusNode : selection.anchorNode;\n    return node && (node.nodeType === 3 ? node.parentNode : node);\n  }\n\n  function isSelectionInElement(element) {\n    var selection = window.getSelection();\n    var rangeCount = selection.rangeCount;\n    var anchorNode = selection.anchorNode;\n    var focusNode = selection.focusNode;\n\n    var range = rangeCount > 0 && selection.getRangeAt(0);\n    var hasSelection = range && !range.collapsed;\n\n    if (hasSelection) {\n      return (0, _contentKitEditorUtilsDomUtils.containsNode)(element, anchorNode) && (0, _contentKitEditorUtilsDomUtils.containsNode)(element, focusNode);\n    } else {\n      return false;\n    }\n  }\n\n  function getSelectionBlockElement(selection) {\n    selection = selection || window.getSelection();\n    var element = getSelectionElement();\n    var tag = element && (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n    while (tag && RootTags.indexOf(tag) === -1) {\n      if (element.contentEditable === 'true') {\n        return null; // Stop traversing up dom when hitting an editor element\n      }\n      element = element.parentNode;\n      tag = element.tagName && (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n    }\n    return element;\n  }\n\n  function getSelectionTagName() {\n    var element = getSelectionElement();\n    return element ? (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName) : null;\n  }\n\n  function getSelectionBlockTagName() {\n    var element = getSelectionBlockElement();\n    return element ? element.tagName && (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName) : null;\n  }\n\n  function tagsInSelection(selection) {\n    var element = getSelectionElement(selection);\n    var tags = [];\n    while (element) {\n      if (element.contentEditable === 'true') {\n        break;\n      } // Stop traversing up dom when hitting an editor element\n      if (element.tagName) {\n        tags.push((0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName));\n      }\n      element = element.parentNode;\n    }\n    return tags;\n  }\n\n  function restoreRange(range) {\n    clearSelection();\n    var selection = window.getSelection();\n    selection.addRange(range);\n  }\n\n  function selectNode(node) {\n    clearSelection();\n\n    var range = document.createRange();\n    range.setStart(node, 0);\n    range.setEnd(node, node.length);\n\n    var selection = window.getSelection();\n    selection.addRange(range);\n  }\n\n  exports.getDirectionOfSelection = getDirectionOfSelection;\n  exports.getSelectionElement = getSelectionElement;\n  exports.getSelectionBlockElement = getSelectionBlockElement;\n  exports.getSelectionTagName = getSelectionTagName;\n  exports.getSelectionBlockTagName = getSelectionBlockTagName;\n  exports.tagsInSelection = tagsInSelection;\n  exports.restoreRange = restoreRange;\n  exports.selectNode = selectNode;\n  exports.clearSelection = clearSelection;\n  exports.isSelectionInElement = isSelectionInElement;\n});","define('content-kit-editor/utils/string-utils', ['exports'], function (exports) {\n  /*\n   * @param {String} string\n   * @return {String} a dasherized string. 'modelIndex' -> 'model-index', etc\n   */\n  'use strict';\n\n  exports.dasherize = dasherize;\n  exports.startsWith = startsWith;\n  exports.endsWith = endsWith;\n\n  function dasherize(string) {\n    return string.replace(/[A-Z]/g, function (match, offset) {\n      var lower = match.toLowerCase();\n\n      return offset === 0 ? lower : '-' + lower;\n    });\n  }\n\n  function startsWith(string, character) {\n    return string.charAt(0) === character;\n  }\n\n  function endsWith(string, character) {\n    return string.charAt(string.length - 1) === character;\n  }\n});","define('content-kit-editor/views/embed-intent', ['exports', 'content-kit-editor/views/view', 'content-kit-editor/views/toolbar', 'content-kit-utils', 'content-kit-editor/utils/element-utils', 'content-kit-editor/utils/keycodes'], function (exports, _contentKitEditorViewsView, _contentKitEditorViewsToolbar, _contentKitUtils, _contentKitEditorUtilsElementUtils, _contentKitEditorUtilsKeycodes) {\n  'use strict';\n\n  var LayoutStyle = {\n    GUTTER: 1,\n    CENTERED: 2\n  };\n\n  function computeLayoutStyle(rootElement) {\n    if (rootElement.getBoundingClientRect().left > 100) {\n      return LayoutStyle.GUTTER;\n    }\n    return LayoutStyle.CENTERED;\n  }\n\n  function EmbedIntent(options) {\n    var _this = this;\n\n    var embedIntent = this;\n    var rootElement = embedIntent.rootElement = options.rootElement;\n    options.classNames = ['ck-embed-intent'];\n    _contentKitEditorViewsView['default'].call(embedIntent, options);\n\n    embedIntent.isActive = false;\n    embedIntent.editorContext = options.editorContext;\n    embedIntent.loadingIndicator = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-embed-loading');\n    embedIntent.button = document.createElement('button');\n    embedIntent.button.className = 'ck-embed-intent-btn';\n    embedIntent.button.title = 'Insert image or embed...';\n    embedIntent.element.appendChild(embedIntent.button);\n\n    this.addEventListener(embedIntent.button, 'click', function (e) {\n      if (embedIntent.isActive) {\n        embedIntent.deactivate();\n      } else {\n        embedIntent.activate();\n      }\n      e.stopPropagation();\n    });\n\n    embedIntent.toolbar = new _contentKitEditorViewsToolbar['default']({\n      container: embedIntent.element,\n      embedIntent: embedIntent,\n      editor: embedIntent.editorContext,\n      commands: options.commands,\n      direction: _contentKitEditorViewsToolbar['default'].Direction.RIGHT\n    });\n\n    var embedIntentHandler = function embedIntentHandler() {\n      var editor = _this.editorContext;\n\n      if (_this._isDestroyed || editor._isDestroyed) {\n        return;\n      }\n\n      var _embedIntent$editorContext$cursor$offsets = embedIntent.editorContext.cursor.offsets;\n      var headSection = _embedIntent$editorContext$cursor$offsets.headSection;\n      var isCollapsed = _embedIntent$editorContext$cursor$offsets.isCollapsed;\n\n      var headRenderNode = headSection && headSection.renderNode && headSection.renderNode.element;\n\n      if (headRenderNode && headSection.isBlank && isCollapsed) {\n        embedIntent.showAt(headRenderNode);\n      } else {\n        embedIntent.hide();\n      }\n    };\n\n    this.addEventListener(rootElement, 'keyup', embedIntentHandler);\n    this.addEventListener(document, 'click', function () {\n      setTimeout(function () {\n        embedIntentHandler();\n      });\n    });\n\n    this.addEventListener(document, 'keyup', function (e) {\n      if (e.keyCode === _contentKitEditorUtilsKeycodes['default'].ESC) {\n        embedIntent.hide();\n      }\n    });\n\n    this.addEventListener(window, 'resize', function () {\n      if (embedIntent.isShowing) {\n        embedIntent.reposition();\n      }\n    });\n  }\n  (0, _contentKitUtils.inherit)(EmbedIntent, _contentKitEditorViewsView['default']);\n\n  EmbedIntent.prototype.hide = function () {\n    if (EmbedIntent._super.prototype.hide.call(this)) {\n      this.deactivate();\n    }\n  };\n\n  EmbedIntent.prototype.showAt = function (node) {\n    this.atNode = node;\n    this.show();\n    this.deactivate();\n    this.reposition();\n  };\n\n  EmbedIntent.prototype.reposition = function () {\n    if (computeLayoutStyle(this.rootElement) === LayoutStyle.GUTTER) {\n      (0, _contentKitEditorUtilsElementUtils.positionElementToLeftOf)(this.element, this.atNode);\n    } else {\n      (0, _contentKitEditorUtilsElementUtils.positionElementCenteredIn)(this.element, this.atNode);\n    }\n  };\n\n  EmbedIntent.prototype.activate = function () {\n    if (!this.isActive) {\n      this.addClass('activated');\n      this.toolbar.show();\n      this.isActive = true;\n    }\n  };\n\n  EmbedIntent.prototype.deactivate = function () {\n    if (this.isActive) {\n      this.removeClass('activated');\n      this.toolbar.hide();\n      this.isActive = false;\n    }\n  };\n\n  EmbedIntent.prototype.showLoading = function () {\n    var embedIntent = this;\n    var loadingIndicator = embedIntent.loadingIndicator;\n    embedIntent.hide();\n    embedIntent.atNode.appendChild(loadingIndicator);\n  };\n\n  EmbedIntent.prototype.hideLoading = function () {\n    this.atNode.removeChild(this.loadingIndicator);\n  };\n\n  exports['default'] = EmbedIntent;\n});","define('content-kit-editor/views/message', ['exports', 'content-kit-editor/views/view', 'content-kit-utils'], function (exports, _contentKitEditorViewsView, _contentKitUtils) {\n  'use strict';\n\n  var defaultClassNames = ['ck-message'];\n\n  function Message(options) {\n    options = options || {};\n    options.classNames = defaultClassNames;\n    _contentKitEditorViewsView['default'].call(this, options);\n  }\n  (0, _contentKitUtils.inherit)(Message, _contentKitEditorViewsView['default']);\n\n  function show(view, message) {\n    view.element.innerHTML = message;\n    Message._super.prototype.show.call(view);\n    setTimeout(function () {\n      view.hide();\n    }, 3200);\n  }\n\n  Message.prototype.showInfo = function (message) {\n    this.setClasses(defaultClassNames);\n    show(this, message);\n  };\n\n  Message.prototype.showError = function (message) {\n    this.addClass('ck-message-error');\n    show(this, message);\n  };\n\n  exports['default'] = Message;\n});","define('content-kit-editor/views/prompt', ['exports', 'content-kit-editor/views/view', 'content-kit-editor/utils/selection-utils', 'content-kit-editor/utils/element-utils', 'content-kit-editor/utils/keycodes'], function (exports, _contentKitEditorViewsView, _contentKitEditorUtilsSelectionUtils, _contentKitEditorUtilsElementUtils, _contentKitEditorUtilsKeycodes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var container = document.body;\n  var hiliter = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-editor-hilite');\n\n  function positionHiliteRange(range) {\n    var rect = range.getBoundingClientRect();\n    var style = hiliter.style;\n    style.width = rect.width + 'px';\n    style.height = rect.height + 'px';\n    (0, _contentKitEditorUtilsElementUtils.positionElementToRect)(hiliter, rect);\n  }\n\n  var Prompt = (function (_View) {\n    _inherits(Prompt, _View);\n\n    function Prompt(options) {\n      var _this = this;\n\n      _classCallCheck(this, Prompt);\n\n      options.tagName = 'input';\n      _get(Object.getPrototypeOf(Prompt.prototype), 'constructor', this).call(this, options);\n\n      var prompt = this;\n\n      prompt.command = options.command;\n      prompt.element.placeholder = options.placeholder || '';\n      this.addEventListener(prompt.element, 'click', function (e) {\n        // prevents closing prompt when clicking input\n        e.stopPropagation();\n      });\n      this.addEventListener(prompt.element, 'keyup', function (e) {\n        var entry = prompt.element.value;\n\n        if (entry && prompt.range && !e.shiftKey && e.which === _contentKitEditorUtilsKeycodes['default'].ENTER) {\n          (0, _contentKitEditorUtilsSelectionUtils.restoreRange)(prompt.range);\n          _this.command.exec(entry);\n          if (_this.onComplete) {\n            _this.onComplete();\n          }\n        }\n      });\n\n      this.addEventListener(window, 'resize', function () {\n        var activeHilite = hiliter.parentNode;\n        var range = prompt.range;\n        if (activeHilite && range) {\n          positionHiliteRange(range);\n        }\n      });\n    }\n\n    _createClass(Prompt, [{\n      key: 'show',\n      value: function show(callback) {\n        var element = this.element;\n        var selection = window.getSelection();\n        var range = selection && selection.rangeCount && selection.getRangeAt(0);\n        element.value = null;\n        this.range = range || null;\n\n        if (range) {\n          container.appendChild(hiliter);\n          positionHiliteRange(this.range);\n          setTimeout(function () {\n            // defer focus (disrupts mouseup events)\n            element.focus();\n          });\n          if (callback) {\n            this.onComplete = callback;\n          }\n        }\n      }\n    }, {\n      key: 'hide',\n      value: function hide() {\n        if (hiliter.parentNode) {\n          container.removeChild(hiliter);\n        }\n      }\n    }]);\n\n    return Prompt;\n  })(_contentKitEditorViewsView['default']);\n\n  exports['default'] = Prompt;\n});","define('content-kit-editor/views/reversible-toolbar-button', ['exports', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener'], function (exports, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var ELEMENT_TYPE = 'button';\n  var BUTTON_CLASS_NAME = 'ck-toolbar-btn';\n\n  var ReversibleToolbarButton = (function () {\n    function ReversibleToolbarButton(command, editor) {\n      var _this = this;\n\n      _classCallCheck(this, ReversibleToolbarButton);\n\n      this.command = command;\n      this.editor = editor;\n      this.element = this.createElement();\n      this.active = false;\n\n      this.addEventListener(this.element, 'click', function (e) {\n        return _this.handleClick(e);\n      });\n      this.editor.on('selection', function () {\n        return _this.updateActiveState();\n      });\n      this.editor.on('selectionUpdated', function () {\n        return _this.updateActiveState();\n      });\n      this.editor.on('selectionEnded', function () {\n        return _this.updateActiveState();\n      });\n    }\n\n    // These are here to match the API of the ToolbarButton class\n\n    _createClass(ReversibleToolbarButton, [{\n      key: 'setInactive',\n      value: function setInactive() {}\n    }, {\n      key: 'setActive',\n      value: function setActive() {}\n    }, {\n      key: 'handleClick',\n      value: function handleClick(e) {\n        e.stopPropagation();\n\n        if (this.active) {\n          this.command.unexec();\n        } else {\n          this.command.exec();\n        }\n      }\n    }, {\n      key: 'updateActiveState',\n      value: function updateActiveState() {\n        this.active = this.command.isActive();\n      }\n    }, {\n      key: 'createElement',\n      value: function createElement() {\n        var element = document.createElement(ELEMENT_TYPE);\n        element.className = BUTTON_CLASS_NAME;\n        element.innerHTML = this.command.button;\n        element.title = this.command.name;\n        return element;\n      }\n    }, {\n      key: 'active',\n      set: function set(val) {\n        this._active = val;\n        if (this._active) {\n          this.element.className = BUTTON_CLASS_NAME + ' active';\n        } else {\n          this.element.className = BUTTON_CLASS_NAME;\n        }\n      },\n      get: function get() {\n        return this._active;\n      }\n    }]);\n\n    return ReversibleToolbarButton;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(ReversibleToolbarButton, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = ReversibleToolbarButton;\n});","define('content-kit-editor/views/text-format-toolbar', ['exports', 'content-kit-editor/views/toolbar'], function (exports, _contentKitEditorViewsToolbar) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var TextFormatToolbar = (function (_Toolbar) {\n    _inherits(TextFormatToolbar, _Toolbar);\n\n    function TextFormatToolbar() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, TextFormatToolbar);\n\n      _get(Object.getPrototypeOf(TextFormatToolbar.prototype), 'constructor', this).call(this, options);\n\n      this.editor.on('selection', function () {\n        return _this.handleSelection();\n      });\n      this.editor.on('selectionUpdated', function () {\n        return _this.handleSelection();\n      });\n      this.editor.on('selectionEnded', function () {\n        return _this.handleSelectionEnded();\n      });\n      this.editor.on('escapeKey', function () {\n        return _this.editor.cancelSelection();\n      });\n      this.addEventListener(window, 'resize', function () {\n        return _this.handleResize();\n      });\n    }\n\n    _createClass(TextFormatToolbar, [{\n      key: 'handleResize',\n      value: function handleResize() {\n        if (this.isShowing) {\n          var activePromptRange = this.activePrompt && this.activePrompt.range;\n          this.positionToContent(activePromptRange ? activePromptRange : window.getSelection().getRangeAt(0));\n        }\n      }\n    }, {\n      key: 'handleSelection',\n      value: function handleSelection() {\n        this.show();\n        this.updateForSelection(window.getSelection());\n      }\n    }, {\n      key: 'handleSelectionEnded',\n      value: function handleSelectionEnded() {\n        this.hide();\n      }\n    }]);\n\n    return TextFormatToolbar;\n  })(_contentKitEditorViewsToolbar['default']);\n\n  exports['default'] = TextFormatToolbar;\n});","define('content-kit-editor/views/toolbar-button', ['exports', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener'], function (exports, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener) {\n  'use strict';\n\n  var buttonClassName = 'ck-toolbar-btn';\n\n  function ToolbarButton(options) {\n    var button = this;\n    var toolbar = options.toolbar;\n    var command = options.command;\n    var prompt = command.prompt;\n    var element = document.createElement('button');\n\n    button.element = element;\n    button.command = command;\n    button.isActive = false;\n\n    element.title = command.name;\n    element.className = buttonClassName;\n    element.innerHTML = command.button;\n    this.addEventListener(element, 'click', function (e) {\n      if (!button.isActive && prompt) {\n        toolbar.displayPrompt(prompt);\n      } else {\n        command.exec();\n        toolbar.updateForSelection();\n        if (toolbar.embedIntent) {\n          toolbar.embedIntent.hide();\n        }\n      }\n      e.stopPropagation();\n    });\n  }\n\n  ToolbarButton.prototype = {\n    setActive: function setActive() {\n      var button = this;\n      if (!button.isActive) {\n        button.element.className = buttonClassName + ' active';\n        button.isActive = true;\n      }\n    },\n    setInactive: function setInactive() {\n      var button = this;\n      if (button.isActive) {\n        button.element.className = buttonClassName;\n        button.isActive = false;\n      }\n    }\n  };\n\n  (0, _contentKitEditorUtilsMixin['default'])(ToolbarButton, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = ToolbarButton;\n});","define('content-kit-editor/views/toolbar', ['exports', 'content-kit-editor/views/view', 'content-kit-editor/views/toolbar-button', 'content-kit-editor/utils/selection-utils', 'content-kit-editor/utils/element-utils'], function (exports, _contentKitEditorViewsView, _contentKitEditorViewsToolbarButton, _contentKitEditorUtilsSelectionUtils, _contentKitEditorUtilsElementUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ToolbarDirection = {\n    TOP: 1,\n    RIGHT: 2\n  };\n\n  function selectionContainsButtonsTag(selectedTags, buttonsTags) {\n    return selectedTags.filter(function (tag) {\n      return buttonsTags.indexOf(tag) > -1;\n    }).length;\n  }\n\n  function updateButtonsForSelection(buttons, selection) {\n    var selectedTags = (0, _contentKitEditorUtilsSelectionUtils.tagsInSelection)(selection);\n    var len = buttons.length;\n    var i, button;\n\n    for (i = 0; i < len; i++) {\n      button = buttons[i];\n      if (selectionContainsButtonsTag(selectedTags, button.command.mappedTags)) {\n        button.setActive();\n      } else {\n        button.setInactive();\n      }\n    }\n  }\n\n  var Toolbar = (function (_View) {\n    _inherits(Toolbar, _View);\n\n    function Toolbar() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, Toolbar);\n\n      options.classNames = ['ck-toolbar'];\n      _get(Object.getPrototypeOf(Toolbar.prototype), 'constructor', this).call(this, options);\n\n      this.setDirection(options.direction || ToolbarDirection.TOP);\n      this.editor = options.editor || null;\n      this.embedIntent = options.embedIntent || null;\n      this.activePrompt = null;\n      this.buttons = [];\n\n      this.contentElement = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-toolbar-content');\n      this.promptContainerElement = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-toolbar-prompt');\n      this.buttonContainerElement = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-toolbar-buttons');\n      this.contentElement.appendChild(this.promptContainerElement);\n      this.contentElement.appendChild(this.buttonContainerElement);\n      this.element.appendChild(this.contentElement);\n\n      (options.buttons || []).forEach(function (b) {\n        return _this.addButton(b);\n      });\n      (options.commands || []).forEach(function (c) {\n        return _this.addCommand(c);\n      });\n\n      // Closes prompt if displayed when changing selection\n      this.addEventListener(document, 'click', function () {\n        _this.dismissPrompt();\n      });\n    }\n\n    _createClass(Toolbar, [{\n      key: 'hide',\n      value: function hide() {\n        if (_get(Object.getPrototypeOf(Toolbar.prototype), 'hide', this).call(this)) {\n          var style = this.element.style;\n          style.left = '';\n          style.top = '';\n          this.dismissPrompt();\n        }\n      }\n    }, {\n      key: 'addCommand',\n      value: function addCommand(command) {\n        command.editor = this.editor;\n        command.embedIntent = this.embedIntent;\n        var button = new _contentKitEditorViewsToolbarButton['default']({ command: command, toolbar: this });\n        this.addButton(button);\n      }\n    }, {\n      key: 'addButton',\n      value: function addButton(button) {\n        this.buttons.push(button);\n        this.buttonContainerElement.appendChild(button.element);\n      }\n    }, {\n      key: 'displayPrompt',\n      value: function displayPrompt(prompt) {\n        var _this2 = this;\n\n        (0, _contentKitEditorUtilsElementUtils.swapElements)(this.promptContainerElement, this.buttonContainerElement);\n        this.promptContainerElement.appendChild(prompt.element);\n        prompt.show(function () {\n          _this2.dismissPrompt();\n          _this2.updateForSelection();\n        });\n        this.activePrompt = prompt;\n      }\n    }, {\n      key: 'dismissPrompt',\n      value: function dismissPrompt() {\n        var activePrompt = this.activePrompt;\n        if (activePrompt) {\n          activePrompt.hide();\n          (0, _contentKitEditorUtilsElementUtils.swapElements)(this.buttonContainerElement, this.promptContainerElement);\n          this.activePrompt = null;\n        }\n      }\n    }, {\n      key: 'updateForSelection',\n      value: function updateForSelection() {\n        var selection = arguments.length <= 0 || arguments[0] === undefined ? window.getSelection() : arguments[0];\n\n        if (!selection.isCollapsed) {\n          this.positionToContent(selection.getRangeAt(0));\n          updateButtonsForSelection(this.buttons, selection);\n        }\n      }\n    }, {\n      key: 'positionToContent',\n      value: function positionToContent(content) {\n        var directions = ToolbarDirection;\n        var positioningMethod, position, sideEdgeOffset;\n        switch (this.direction) {\n          case directions.RIGHT:\n            positioningMethod = _contentKitEditorUtilsElementUtils.positionElementToRightOf;\n            break;\n          default:\n            positioningMethod = _contentKitEditorUtilsElementUtils.positionElementCenteredAbove;\n        }\n        position = positioningMethod(this.element, content);\n        sideEdgeOffset = Math.min(Math.max(10, position.left), document.body.clientWidth - this.element.offsetWidth - 10);\n        this.contentElement.style.transform = 'translateX(' + (sideEdgeOffset - position.left) + 'px)';\n      }\n    }, {\n      key: 'setDirection',\n      value: function setDirection(direction) {\n        this.direction = direction;\n        if (direction === ToolbarDirection.RIGHT) {\n          this.addClass('right');\n        } else {\n          this.removeClass('right');\n        }\n      }\n    }]);\n\n    return Toolbar;\n  })(_contentKitEditorViewsView['default']);\n\n  Toolbar.Direction = ToolbarDirection;\n\n  exports['default'] = Toolbar;\n});","define('content-kit-editor/views/tooltip', ['exports', 'content-kit-editor/views/view', 'content-kit-utils', 'content-kit-editor/utils/element-utils'], function (exports, _contentKitEditorViewsView, _contentKitUtils, _contentKitEditorUtilsElementUtils) {\n  'use strict';\n\n  function Tooltip(options) {\n    var tooltip = this;\n    var rootElement = options.rootElement;\n    var delay = options.delay || 200;\n    var timeout;\n    options.classNames = ['ck-tooltip'];\n    _contentKitEditorViewsView['default'].call(tooltip, options);\n\n    this.addEventListener(rootElement, 'mouseover', function (e) {\n      var target = (0, _contentKitEditorUtilsElementUtils.getEventTargetMatchingTag)(options.showForTag, e.target, rootElement);\n      if (target && target.isContentEditable) {\n        timeout = setTimeout(function () {\n          tooltip.showLink(target.href, target);\n        }, delay);\n      }\n    });\n\n    this.addEventListener(rootElement, 'mouseout', function (e) {\n      clearTimeout(timeout);\n      var toElement = e.toElement || e.relatedTarget;\n      if (toElement && toElement.className !== tooltip.element.className) {\n        tooltip.hide();\n      }\n    });\n  }\n  (0, _contentKitUtils.inherit)(Tooltip, _contentKitEditorViewsView['default']);\n\n  Tooltip.prototype.showMessage = function (message, element) {\n    var tooltip = this;\n    var tooltipElement = tooltip.element;\n    tooltipElement.innerHTML = message;\n    tooltip.show();\n    (0, _contentKitEditorUtilsElementUtils.positionElementCenteredBelow)(tooltipElement, element);\n  };\n\n  Tooltip.prototype.showLink = function (link, element) {\n    var message = '<a href=\"' + link + '\" target=\"_blank\">' + link + '</a>';\n    this.showMessage(message, element);\n  };\n\n  exports['default'] = Tooltip;\n});","define('content-kit-editor/views/view', ['exports', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener'], function (exports, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function renderClasses(view) {\n    var classNames = view.classNames;\n    if (classNames && classNames.length) {\n      view.element.className = classNames.join(' ');\n    } else if (view.element.className) {\n      view.element.removeAttribute('className');\n    }\n  }\n\n  var View = (function () {\n    function View() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, View);\n\n      this.tagName = options.tagName || 'div';\n      this.classNames = options.classNames || [];\n      this.element = document.createElement(this.tagName);\n      this.container = options.container || document.body;\n      this.isShowing = false;\n      renderClasses(this);\n    }\n\n    _createClass(View, [{\n      key: 'show',\n      value: function show() {\n        var view = this;\n        if (!view.isShowing) {\n          view.container.appendChild(view.element);\n          view.isShowing = true;\n          return true;\n        }\n      }\n    }, {\n      key: 'hide',\n      value: function hide() {\n        var view = this;\n        if (view.isShowing) {\n          view.container.removeChild(view.element);\n          view.isShowing = false;\n          return true;\n        }\n      }\n    }, {\n      key: 'addClass',\n      value: function addClass(className) {\n        var index = this.classNames && this.classNames.indexOf(className);\n        if (index === -1) {\n          this.classNames.push(className);\n          renderClasses(this);\n        }\n      }\n    }, {\n      key: 'removeClass',\n      value: function removeClass(className) {\n        var index = this.classNames && this.classNames.indexOf(className);\n        if (index > -1) {\n          this.classNames.splice(index, 1);\n          renderClasses(this);\n        }\n      }\n    }, {\n      key: 'setClasses',\n      value: function setClasses(classNameArr) {\n        this.classNames = classNameArr;\n        renderClasses(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeAllEventListeners();\n        this.hide();\n        this._isDestroyed = true;\n      }\n    }]);\n\n    return View;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(View, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = View;\n});","define(\"content-kit-utils/array-utils\", [\"exports\"], function (exports) {\n  /**\n   * Converts an array-like object (i.e. NodeList) to Array\n   * Note: could just use Array.prototype.slice but does not work in IE <= 8\n   */\n  \"use strict\";\n\n  function toArray(obj) {\n    var array = [];\n    var i = obj && obj.length >>> 0; // cast to Uint32\n    while (i--) {\n      array[i] = obj[i];\n    }\n    return array;\n  }\n\n  /**\n   * Computes the sum of values in a (sparse) array\n   */\n  function sumSparseArray(array) {\n    var sum = 0,\n        i;\n    for (i in array) {\n      // 'for in' is better for sparse arrays\n      if (array.hasOwnProperty(i)) {\n        sum += array[i];\n      }\n    }\n    return sum;\n  }\n\n  exports.toArray = toArray;\n  exports.sumSparseArray = sumSparseArray;\n});","define('content-kit-utils', ['exports', 'content-kit-utils/array-utils', 'content-kit-utils/node-utils', 'content-kit-utils/object-utils', 'content-kit-utils/string-utils'], function (exports, _contentKitUtilsArrayUtils, _contentKitUtilsNodeUtils, _contentKitUtilsObjectUtils, _contentKitUtilsStringUtils) {\n  'use strict';\n\n  exports.toArray = _contentKitUtilsArrayUtils.toArray;\n  exports.sumSparseArray = _contentKitUtilsArrayUtils.sumSparseArray;\n  exports.textOfNode = _contentKitUtilsNodeUtils.textOfNode;\n  exports.unwrapNode = _contentKitUtilsNodeUtils.unwrapNode;\n  exports.attributesForNode = _contentKitUtilsNodeUtils.attributesForNode;\n  exports.mergeWithOptions = _contentKitUtilsObjectUtils.mergeWithOptions;\n  exports.merge = _contentKitUtilsObjectUtils.merge;\n  exports.inherit = _contentKitUtilsObjectUtils.inherit;\n  exports.trim = _contentKitUtilsStringUtils.trim;\n  exports.trimLeft = _contentKitUtilsStringUtils.trimLeft;\n  exports.underscore = _contentKitUtilsStringUtils.underscore;\n  exports.sanitizeWhitespace = _contentKitUtilsStringUtils.sanitizeWhitespace;\n  exports.injectIntoString = _contentKitUtilsStringUtils.injectIntoString;\n\n  // needs a default export to be compatible with\n  // broccoli-multi-builder\n  exports['default'] = {};\n});","define('content-kit-utils/node-utils', ['exports', 'content-kit-utils/string-utils', 'content-kit-utils/array-utils'], function (exports, _contentKitUtilsStringUtils, _contentKitUtilsArrayUtils) {\n  'use strict';\n\n  /**\n   * Returns plain-text of a `Node`\n   */\n  function textOfNode(node) {\n    var text = node.textContent || node.innerText;\n    return text ? (0, _contentKitUtilsStringUtils.sanitizeWhitespace)(text) : '';\n  }\n\n  /**\n   * Replaces a `Node` with its children\n   */\n  function unwrapNode(node) {\n    if (node.hasChildNodes()) {\n      var children = (0, _contentKitUtilsArrayUtils.toArray)(node.childNodes);\n      var len = children.length;\n      var parent = node.parentNode,\n          i;\n      for (i = 0; i < len; i++) {\n        parent.insertBefore(children[i], node);\n      }\n    }\n  }\n\n  /**\n   * Extracts attributes of a `Node` to a hash of key/value pairs\n   */\n  function attributesForNode(node, blacklist) {\n    var attrs = node.attributes;\n    var len = attrs && attrs.length;\n    var i, attr, name, hash;\n\n    for (i = 0; i < len; i++) {\n      attr = attrs[i];\n      name = attr.name;\n      if (attr.specified && attr.value) {\n        if (blacklist && name in blacklist) {\n          continue;\n        }\n        hash = hash || {};\n        hash[name] = attr.value;\n      }\n    }\n    return hash;\n  }\n\n  exports.textOfNode = textOfNode;\n  exports.unwrapNode = unwrapNode;\n  exports.attributesForNode = attributesForNode;\n});","define(\"content-kit-utils/object-utils\", [\"exports\"], function (exports) {\n  /**\n   * Merges defaults/options into an Object\n   * Useful for constructors\n   */\n  \"use strict\";\n\n  function mergeWithOptions(original, updates, options) {\n    options = options || {};\n    for (var prop in updates) {\n      if (options.hasOwnProperty(prop)) {\n        original[prop] = options[prop];\n      } else if (updates.hasOwnProperty(prop)) {\n        original[prop] = updates[prop];\n      }\n    }\n    return original;\n  }\n\n  /**\n   * Merges properties of one object into another\n   */\n  function merge(original, updates) {\n    return mergeWithOptions(original, updates);\n  }\n\n  /**\n   * Prototype inheritance helper\n   */\n  function inherit(Subclass, Superclass) {\n    for (var key in Superclass) {\n      if (Superclass.hasOwnProperty(key)) {\n        Subclass[key] = Superclass[key];\n      }\n    }\n    Subclass.prototype = new Superclass();\n    Subclass.constructor = Subclass;\n    Subclass._super = Superclass;\n  }\n\n  exports.mergeWithOptions = mergeWithOptions;\n  exports.merge = merge;\n  exports.inherit = inherit;\n});","define('content-kit-utils/string-utils', ['exports'], function (exports) {\n  'use strict';\n\n  var RegExpTrim = /^\\s+|\\s+$/g;\n  var RegExpTrimLeft = /^\\s+/;\n  var RegExpWSChars = /(\\r\\n|\\n|\\r|\\t)/gm;\n  var RegExpMultiWS = /\\s+/g;\n  var RegExpNonAlphaNum = /[^a-zA-Z\\d]/g;\n\n  /**\n   * String.prototype.trim polyfill\n   * Removes whitespace at beginning and end of string\n   */\n  function trim(string) {\n    return string ? (string + '').replace(RegExpTrim, '') : '';\n  }\n\n  /**\n   * String.prototype.trimLeft polyfill\n   * Removes whitespace at beginning of string\n   */\n  function trimLeft(string) {\n    return string ? (string + '').replace(RegExpTrimLeft, '') : '';\n  }\n\n  /**\n   * Replaces non-alphanumeric chars with underscores\n   */\n  function underscore(string) {\n    return string ? trim(string + '').replace(RegExpNonAlphaNum, '_') : '';\n  }\n\n  /**\n   * Cleans line breaks, tabs, then multiple occuring whitespaces.\n   */\n  function sanitizeWhitespace(string) {\n    return string ? (string + '').replace(RegExpWSChars, '').replace(RegExpMultiWS, ' ') : '';\n  }\n\n  /**\n   * Injects a string into another string at the index specified\n   */\n  function injectIntoString(string, injection, index) {\n    return string.substr(0, index) + injection + string.substr(index);\n  }\n\n  exports.trim = trim;\n  exports.trimLeft = trimLeft;\n  exports.underscore = underscore;\n  exports.sanitizeWhitespace = sanitizeWhitespace;\n  exports.injectIntoString = injectIntoString;\n});"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;","file":"content-kit-editor.js"}