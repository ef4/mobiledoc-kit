{"version":3,"sources":["loader.js/loader.js","content-kit-editor/cards/image.js","content-kit-editor/cards/placeholder-image.js","content-kit-editor/commands/base.js","content-kit-editor/commands/bold.js","content-kit-editor/commands/card.js","content-kit-editor/commands/format-block.js","content-kit-editor/commands/heading.js","content-kit-editor/commands/image.js","content-kit-editor/commands/italic.js","content-kit-editor/commands/link.js","content-kit-editor/commands/list.js","content-kit-editor/commands/ordered-list.js","content-kit-editor/commands/quote.js","content-kit-editor/commands/subheading.js","content-kit-editor/commands/text-format.js","content-kit-editor/commands/unordered-list.js","content-kit-editor/editor/editor.js","content-kit-editor/editor/key-commands.js","content-kit-editor/editor/post.js","content-kit-editor/editor/text-expansions.js","content-kit-editor/index.js","content-kit-editor/models/_markerable.js","content-kit-editor/models/_section.js","content-kit-editor/models/card-node.js","content-kit-editor/models/card.js","content-kit-editor/models/image.js","content-kit-editor/models/list-item.js","content-kit-editor/models/list-section.js","content-kit-editor/models/marker.js","content-kit-editor/models/markup-section.js","content-kit-editor/models/markup.js","content-kit-editor/models/post-node-builder.js","content-kit-editor/models/post.js","content-kit-editor/models/render-node.js","content-kit-editor/models/render-tree.js","content-kit-editor/models/types.js","content-kit-editor/parsers/dom.js","content-kit-editor/parsers/mobiledoc.js","content-kit-editor/parsers/post.js","content-kit-editor/parsers/section.js","content-kit-editor/renderers/editor-dom.js","content-kit-editor/renderers/mobiledoc.js","content-kit-editor/utils/array-utils.js","content-kit-editor/utils/compat.js","content-kit-editor/utils/compiler.js","content-kit-editor/utils/cursor.js","content-kit-editor/utils/cursor/position.js","content-kit-editor/utils/cursor/range.js","content-kit-editor/utils/dom-utils.js","content-kit-editor/utils/element-map.js","content-kit-editor/utils/element-utils.js","content-kit-editor/utils/event-emitter.js","content-kit-editor/utils/event-listener.js","content-kit-editor/utils/http-utils.js","content-kit-editor/utils/key.js","content-kit-editor/utils/keycodes.js","content-kit-editor/utils/linked-item.js","content-kit-editor/utils/linked-list.js","content-kit-editor/utils/mixin.js","content-kit-editor/utils/selection-utils.js","content-kit-editor/utils/set.js","content-kit-editor/utils/string-utils.js","content-kit-editor/views/embed-intent.js","content-kit-editor/views/message.js","content-kit-editor/views/prompt.js","content-kit-editor/views/reversible-prompt-button.js","content-kit-editor/views/reversible-toolbar-button.js","content-kit-editor/views/text-format-toolbar.js","content-kit-editor/views/toolbar-button.js","content-kit-editor/views/toolbar.js","content-kit-editor/views/tooltip.js","content-kit-editor/views/view.js","content-kit-utils/array-utils.js","content-kit-utils/index.js","content-kit-utils/node-utils.js","content-kit-utils/object-utils.js","content-kit-utils/string-utils.js"],"sourcesContent":["var define, requireModule, require, requirejs;\n\n(function() {\n\n  var _isArray;\n  if (!Array.isArray) {\n    _isArray = function (x) {\n      return Object.prototype.toString.call(x) === \"[object Array]\";\n    };\n  } else {\n    _isArray = Array.isArray;\n  }\n\n  var registry = {};\n  var seen = {};\n  var FAILED = false;\n\n  var uuid = 0;\n\n  function tryFinally(tryable, finalizer) {\n    try {\n      return tryable();\n    } finally {\n      finalizer();\n    }\n  }\n\n  function unsupportedModule(length) {\n    throw new Error(\"an unsupported module was defined, expected `define(name, deps, module)` instead got: `\" + length + \"` arguments to define`\");\n  }\n\n  var defaultDeps = ['require', 'exports', 'module'];\n\n  function Module(name, deps, callback, exports) {\n    this.id       = uuid++;\n    this.name     = name;\n    this.deps     = !deps.length && callback.length ? defaultDeps : deps;\n    this.exports  = exports || { };\n    this.callback = callback;\n    this.state    = undefined;\n    this._require  = undefined;\n  }\n\n\n  Module.prototype.makeRequire = function() {\n    var name = this.name;\n\n    return this._require || (this._require = function(dep) {\n      return require(resolve(dep, name));\n    });\n  }\n\n  define = function(name, deps, callback) {\n    if (arguments.length < 2) {\n      unsupportedModule(arguments.length);\n    }\n\n    if (!_isArray(deps)) {\n      callback = deps;\n      deps     =  [];\n    }\n\n    registry[name] = new Module(name, deps, callback);\n  };\n\n  // we don't support all of AMD\n  // define.amd = {};\n  // we will support petals...\n  define.petal = { };\n\n  function Alias(path) {\n    this.name = path;\n  }\n\n  define.alias = function(path) {\n    return new Alias(path);\n  };\n\n  function reify(mod, name, seen) {\n    var deps = mod.deps;\n    var length = deps.length;\n    var reified = new Array(length);\n    var dep;\n    // TODO: new Module\n    // TODO: seen refactor\n    var module = { };\n\n    for (var i = 0, l = length; i < l; i++) {\n      dep = deps[i];\n      if (dep === 'exports') {\n        module.exports = reified[i] = seen;\n      } else if (dep === 'require') {\n        reified[i] = mod.makeRequire();\n      } else if (dep === 'module') {\n        mod.exports = seen;\n        module = reified[i] = mod;\n      } else {\n        reified[i] = requireFrom(resolve(dep, name), name);\n      }\n    }\n\n    return {\n      deps: reified,\n      module: module\n    };\n  }\n\n  function requireFrom(name, origin) {\n    var mod = registry[name];\n    if (!mod) {\n      throw new Error('Could not find module `' + name + '` imported from `' + origin + '`');\n    }\n    return require(name);\n  }\n\n  function missingModule(name) {\n    throw new Error('Could not find module ' + name);\n  }\n  requirejs = require = requireModule = function(name) {\n    var mod = registry[name];\n\n    if (mod && mod.callback instanceof Alias) {\n      mod = registry[mod.callback.name];\n    }\n\n    if (!mod) { missingModule(name); }\n\n    if (mod.state !== FAILED &&\n        seen.hasOwnProperty(name)) {\n      return seen[name];\n    }\n\n    var reified;\n    var module;\n    var loaded = false;\n\n    seen[name] = { }; // placeholder for run-time cycles\n\n    tryFinally(function() {\n      reified = reify(mod, name, seen[name]);\n      module = mod.callback.apply(this, reified.deps);\n      loaded = true;\n    }, function() {\n      if (!loaded) {\n        mod.state = FAILED;\n      }\n    });\n\n    var obj;\n    if (module === undefined && reified.module.exports) {\n      obj = reified.module.exports;\n    } else {\n      obj = seen[name] = module;\n    }\n\n    if (obj !== null &&\n        (typeof obj === 'object' || typeof obj === 'function') &&\n          obj['default'] === undefined) {\n      obj['default'] = obj;\n    }\n\n    return (seen[name] = obj);\n  };\n\n  function resolve(child, name) {\n    if (child.charAt(0) !== '.') { return child; }\n\n    var parts = child.split('/');\n    var nameParts = name.split('/');\n    var parentBase = nameParts.slice(0, -1);\n\n    for (var i = 0, l = parts.length; i < l; i++) {\n      var part = parts[i];\n\n      if (part === '..') {\n        if (parentBase.length === 0) {\n          throw new Error('Cannot access parent module of root');\n        }\n        parentBase.pop();\n      } else if (part === '.') {\n        continue;\n      } else { parentBase.push(part); }\n    }\n\n    return parentBase.join('/');\n  }\n\n  requirejs.entries = requirejs._eak_seen = registry;\n  requirejs.unsee = function(moduleName) {\n    delete seen[moduleName];\n  };\n\n  requirejs.clear = function() {\n    requirejs.entries = requirejs._eak_seen = registry = {};\n    seen = state = {};\n  };\n})();\n","define('content-kit-editor/cards/image', ['exports', 'content-kit-editor/cards/placeholder-image', 'content-kit-editor/utils/http-utils'], function (exports, _contentKitEditorCardsPlaceholderImage, _contentKitEditorUtilsHttpUtils) {\n  'use strict';\n\n  function buildFileInput() {\n    var input = document.createElement('input');\n    input.type = 'file';\n    input.accept = 'image/*';\n    input.classList.add('ck-file-input');\n    document.body.appendChild(input);\n    return input;\n  }\n\n  function buildButton(text) {\n    var button = document.createElement('button');\n    button.innerHTML = text;\n    return button;\n  }\n\n  function upload(imageOptions, fileInput, success, failure) {\n    var uploader = new _contentKitEditorUtilsHttpUtils.FileUploader({\n      url: imageOptions.uploadUrl,\n      maxFileSize: 5000000\n    });\n    uploader.upload({\n      fileInput: fileInput,\n      complete: function complete(response, error) {\n        if (!error && response && response.url) {\n          success({\n            src: response.url\n          });\n        } else {\n          window.alert('There was a problem uploading the image: ' + error);\n          failure();\n        }\n      }\n    });\n  }\n\n  exports['default'] = {\n    name: 'image',\n\n    display: {\n      setup: function setup(element, options, _ref, payload) {\n        var edit = _ref.edit;\n\n        var img = document.createElement('img');\n        img.src = payload.src || _contentKitEditorCardsPlaceholderImage['default'];\n        if (edit) {\n          img.onclick = edit;\n        }\n        element.appendChild(img);\n        return img;\n      },\n      teardown: function teardown(element) {\n        element.parentNode.removeChild(element);\n      }\n    },\n\n    edit: {\n      setup: function setup(element, options, _ref2) {\n        var save = _ref2.save;\n        var cancel = _ref2.cancel;\n\n        var uploadButton = buildButton('Upload');\n        var cancelButton = buildButton('Cancel');\n        cancelButton.onclick = cancel;\n\n        var imageOptions = options.image;\n\n        if (!imageOptions || imageOptions && !imageOptions.uploadUrl) {\n          window.alert('Image card must have `image.uploadUrl` included in cardOptions');\n          cancel();\n          return;\n        }\n\n        var fileInput = buildFileInput();\n        uploadButton.onclick = function () {\n          fileInput.dispatchEvent(new MouseEvent('click', { bubbles: false }));\n        };\n        element.appendChild(uploadButton);\n        element.appendChild(cancelButton);\n\n        fileInput.onchange = function () {\n          try {\n            if (fileInput.files.length === 0) {\n              cancel();\n            }\n            upload(imageOptions, fileInput, save, cancel);\n          } catch (error) {\n            window.alert('There was a starting the upload: ' + error);\n            cancel();\n          }\n        };\n        return [uploadButton, cancelButton, fileInput];\n      },\n      teardown: function teardown(elements) {\n        elements.forEach(function (element) {\n          return element.parentNode.removeChild(element);\n        });\n      }\n    }\n\n  };\n});","define(\"content-kit-editor/cards/placeholder-image\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var placeholderImage = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAMFBMVEXp7vG6vsHm6+63u77Hy868wMPe4+bO09bh5unr8fTR1djAxMfM0NPX3N/c4eTBxcjXRf5TAAACh0lEQVR4nO3b6ZKqMBSFUSQMYZL3f9tbBq/NEEDiqUqOfusn1ZXKbjcQlGQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACC6RkbsGHuabChEtHmiGYfS3EQYM+Sxw/gMQvmcNnYaj6oTDHi73WPn2eqnj9B8zo3TJXcq5uNjXmVff86VwSR3JtryMa1BYqi7S1hJDCVpSigyLcGhJJEwzlCSNtPKrbVhVwsdCfOhH7uuaG3ARV9DwsaOzxt3N1yPqCHhvXytTUz92VDpmE/LLhZwl++R6Sds6sUa/PL6K/2E2fIhw1xdRKefsFolrPc+xNx/N0k/4fpBsdhL2HfeiN+TsDCms8dDpeRyS3P3QDl6Iqaf8L0rTf+80m6Lmn7Ct+4Wxf+/2RY1/YRv3PHz/u+fsCmqgoTnq7Z+8SGviqoh4dnKu1ieqauiakh4/PQ0r6ivqDoSHj0B97eNRVG1JNxV+L4bnxdVecJtRTdFVZ7QU9F1UXUn9FZ0VVRlCav5ob2KLouqKmFjy676u2HsVnRRVFUJq3J+8KCi86IqSthMvyl209Hjijqm3RsqAZ5pNfa5PJ2KelJRjQmr1/r7cfy0ouoSNvOfvbvhvKLaEr4qOin9kTQnrN7LpDZhE/Zmhp6Eq4p+YcKgiipKGFhRRQkDK6ooYfgLbiSMioQkJGF8P5XwHv4O+7AaKiXzaeXh1kMl5AffTUxiKEm/krD94BR8Gdxl1fceSlR58ZhXKbEpyD2amNiBtmrJLTMHL1LF8/rpXkSZXEmz8K8uvAFFNm6Iq0aBLUFOmeCuJ6exrcCmoLpN7kYx891bSAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgh/wDdr8peyRHLogAAAAASUVORK5CYII=\";\n\n  exports[\"default\"] = placeholderImage;\n});","define(\"content-kit-editor/commands/base\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var Command = (function () {\n    function Command() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, Command);\n\n      var command = this;\n      var name = options.name;\n      var prompt = options.prompt;\n      command.name = name;\n      command.button = options.button || name;\n      if (prompt) {\n        command.prompt = prompt;\n      }\n    }\n\n    _createClass(Command, [{\n      key: \"exec\",\n      value: function exec() {/* override in subclass */}\n    }, {\n      key: \"unexec\",\n      value: function unexec() {/* override in subclass */}\n    }]);\n\n    return Command;\n  })();\n\n  exports[\"default\"] = Command;\n});","define('content-kit-editor/commands/bold', ['exports', 'content-kit-editor/commands/text-format'], function (exports, _contentKitEditorCommandsTextFormat) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var BoldCommand = (function (_TextFormatCommand) {\n    _inherits(BoldCommand, _TextFormatCommand);\n\n    function BoldCommand(editor) {\n      _classCallCheck(this, BoldCommand);\n\n      _get(Object.getPrototypeOf(BoldCommand.prototype), 'constructor', this).call(this, editor, {\n        tag: 'strong',\n        name: 'bold',\n        button: '<i class=\"ck-icon-bold\"></i>'\n      });\n    }\n\n    return BoldCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = BoldCommand;\n});","define('content-kit-editor/commands/card', ['exports', 'content-kit-editor/commands/base'], function (exports, _contentKitEditorCommandsBase) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  function injectCardBlock() /* cardName, cardPayload, editor, index */{\n    throw new Error('Unimplemented: BlockModel and Type.CARD are no longer things');\n  }\n\n  var CardCommand = (function (_Command) {\n    _inherits(CardCommand, _Command);\n\n    function CardCommand() {\n      _classCallCheck(this, CardCommand);\n\n      _get(Object.getPrototypeOf(CardCommand.prototype), 'constructor', this).call(this, {\n        name: 'card',\n        button: '<i>CA</i>'\n      });\n    }\n\n    _createClass(CardCommand, [{\n      key: 'exec',\n      value: function exec() {\n        _get(Object.getPrototypeOf(CardCommand.prototype), 'exec', this).call(this);\n        var editor = this.editor;\n        var currentEditingIndex = editor.getCurrentBlockIndex();\n\n        var cardName = 'pick-color';\n        var cardPayload = { options: ['red', 'blue'] };\n        injectCardBlock(cardName, cardPayload, editor, currentEditingIndex);\n      }\n    }]);\n\n    return CardCommand;\n  })(_contentKitEditorCommandsBase['default']);\n\n  exports['default'] = CardCommand;\n});","define('content-kit-editor/commands/format-block', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var FormatBlockCommand = (function (_TextFormatCommand) {\n    _inherits(FormatBlockCommand, _TextFormatCommand);\n\n    function FormatBlockCommand(editor) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      _classCallCheck(this, FormatBlockCommand);\n\n      _get(Object.getPrototypeOf(FormatBlockCommand.prototype), 'constructor', this).call(this, editor, options);\n    }\n\n    _createClass(FormatBlockCommand, [{\n      key: 'isActive',\n      value: function isActive() {\n        var _this = this;\n\n        return (0, _contentKitEditorUtilsArrayUtils.any)(this.editor.activeSections, function (s) {\n          return s.tagName === _this.tag;\n        });\n      }\n    }, {\n      key: 'exec',\n      value: function exec() {\n        var _this2 = this;\n\n        var editor = this.editor;\n        var activeSections = editor.activeSections;\n\n        activeSections.forEach(function (s) {\n          editor.resetSectionMarkers(s);\n          editor.setSectionTagName(s, _this2.tag);\n        });\n\n        editor.rerender();\n        editor.selectSections(activeSections);\n        this.editor.didUpdate();\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var editor = this.editor;\n        var activeSections = editor.activeSections;\n\n        activeSections.forEach(function (s) {\n          editor.resetSectionTagName(s);\n        });\n\n        editor.rerender();\n        editor.selectSections(activeSections);\n        this.editor.didUpdate();\n      }\n    }]);\n\n    return FormatBlockCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = FormatBlockCommand;\n});","define('content-kit-editor/commands/heading', ['exports', 'content-kit-editor/commands/format-block'], function (exports, _contentKitEditorCommandsFormatBlock) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var HeadingCommand = (function (_FormatBlockCommand) {\n    _inherits(HeadingCommand, _FormatBlockCommand);\n\n    function HeadingCommand(editor) {\n      _classCallCheck(this, HeadingCommand);\n\n      var options = {\n        name: 'heading',\n        tag: 'h2',\n        button: '<i class=\"ck-icon-heading\"></i>2'\n      };\n      _get(Object.getPrototypeOf(HeadingCommand.prototype), 'constructor', this).call(this, editor, options);\n    }\n\n    return HeadingCommand;\n  })(_contentKitEditorCommandsFormatBlock['default']);\n\n  exports['default'] = HeadingCommand;\n});","define('content-kit-editor/commands/image', ['exports', 'content-kit-editor/commands/base'], function (exports, _contentKitEditorCommandsBase) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ImageCommand = (function (_Command) {\n    _inherits(ImageCommand, _Command);\n\n    function ImageCommand() {\n      _classCallCheck(this, ImageCommand);\n\n      _get(Object.getPrototypeOf(ImageCommand.prototype), 'constructor', this).call(this, {\n        name: 'image',\n        button: '<i class=\"ck-icon-image\"></i>'\n      });\n    }\n\n    _createClass(ImageCommand, [{\n      key: 'exec',\n      value: function exec() {\n        var beforeSection = this.editor.cursor.offsets.headSection;\n\n        var afterSection = beforeSection.next;\n        var section = this.editor.builder.createCardSection('image');\n        var collection = beforeSection.parent.sections;\n\n        this.editor.run(function (postEditor) {\n          if (beforeSection.isBlank) {\n            postEditor.removeSection(beforeSection);\n          }\n          postEditor.insertSectionBefore(collection, section, afterSection);\n        });\n      }\n    }]);\n\n    return ImageCommand;\n  })(_contentKitEditorCommandsBase['default']);\n\n  exports['default'] = ImageCommand;\n});","define('content-kit-editor/commands/italic', ['exports', 'content-kit-editor/commands/text-format'], function (exports, _contentKitEditorCommandsTextFormat) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ItalicCommand = (function (_TextFormatCommand) {\n    _inherits(ItalicCommand, _TextFormatCommand);\n\n    function ItalicCommand(editor) {\n      _classCallCheck(this, ItalicCommand);\n\n      _get(Object.getPrototypeOf(ItalicCommand.prototype), 'constructor', this).call(this, editor, {\n        tag: 'em',\n        name: 'italic',\n        button: '<i class=\"ck-icon-italic\"></i>'\n      });\n    }\n\n    return ItalicCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = ItalicCommand;\n});","define('content-kit-editor/commands/link', ['exports', 'content-kit-editor/commands/text-format', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorCommandsTextFormat, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var LinkCommand = (function (_TextFormatCommand) {\n    _inherits(LinkCommand, _TextFormatCommand);\n\n    function LinkCommand(editor) {\n      _classCallCheck(this, LinkCommand);\n\n      _get(Object.getPrototypeOf(LinkCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'link',\n        tag: 'a',\n        button: '<i class=\"ck-icon-link\"></i>'\n      });\n    }\n\n    _createClass(LinkCommand, [{\n      key: 'isActive',\n      value: function isActive() {\n        var _this = this;\n\n        return (0, _contentKitEditorUtilsArrayUtils.any)(this.editor.markupsInSelection, function (m) {\n          return m.hasTag(_this.tag);\n        });\n      }\n    }, {\n      key: 'exec',\n      value: function exec(url) {\n        var range = this.editor.cursor.offsets;\n        this.editor.run(function (postEditor) {\n          var markup = postEditor.builder.createMarkup('a', ['href', url]);\n          postEditor.applyMarkupToRange(range, markup);\n        });\n        this.editor.moveToPosition(range.tail);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var range = this.editor.cursor.offsets;\n        this.editor.run(function (postEditor) {\n          postEditor.removeMarkupFromRange(range, function (markup) {\n            return markup.hasTag('a');\n          });\n        });\n        this.editor.selectRange(range);\n      }\n    }]);\n\n    return LinkCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = LinkCommand;\n});","define('content-kit-editor/commands/list', ['exports', 'content-kit-editor/commands/text-format'], function (exports, _contentKitEditorCommandsTextFormat) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ListCommand = (function (_TextFormatCommand) {\n    _inherits(ListCommand, _TextFormatCommand);\n\n    function ListCommand(editor, options) {\n      _classCallCheck(this, ListCommand);\n\n      _get(Object.getPrototypeOf(ListCommand.prototype), 'constructor', this).call(this, editor, options);\n    }\n\n    _createClass(ListCommand, [{\n      key: 'isActive',\n      value: function isActive() {\n        return false;\n      }\n    }, {\n      key: 'exec',\n      value: function exec() {\n        var _this = this;\n\n        var editor = this.editor;\n        var cursor = editor.cursor;\n        var currentSection = cursor.offsets.head.section;\n\n        var listItem = editor.run(function (postEditor) {\n          var builder = postEditor.builder;\n\n          var tagName = _this.tag;\n          var listSection = builder.createListSection(tagName);\n          var listItem = builder.createListItem();\n          listSection.items.append(listItem);\n\n          postEditor.replaceSection(currentSection, listSection);\n          return listItem;\n        });\n\n        editor.cursor.moveToSection(listItem);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        throw new Error('Cannot unexec a ListCommand');\n      }\n    }]);\n\n    return ListCommand;\n  })(_contentKitEditorCommandsTextFormat['default']);\n\n  exports['default'] = ListCommand;\n});","define('content-kit-editor/commands/ordered-list', ['exports', 'content-kit-editor/commands/list'], function (exports, _contentKitEditorCommandsList) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var UnorderedListCommand = (function (_ListCommand) {\n    _inherits(UnorderedListCommand, _ListCommand);\n\n    function UnorderedListCommand(editor) {\n      _classCallCheck(this, UnorderedListCommand);\n\n      _get(Object.getPrototypeOf(UnorderedListCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'Ordered List',\n        tag: 'ol',\n        button: '<i>ol</i>'\n      });\n    }\n\n    return UnorderedListCommand;\n  })(_contentKitEditorCommandsList['default']);\n\n  exports['default'] = UnorderedListCommand;\n});","define('content-kit-editor/commands/quote', ['exports', 'content-kit-editor/commands/format-block'], function (exports, _contentKitEditorCommandsFormatBlock) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var QuoteCommand = (function (_FormatBlockCommand) {\n    _inherits(QuoteCommand, _FormatBlockCommand);\n\n    function QuoteCommand(editor) {\n      _classCallCheck(this, QuoteCommand);\n\n      _get(Object.getPrototypeOf(QuoteCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'quote',\n        tag: 'blockquote',\n        button: '<i class=\"ck-icon-quote\"></i>'\n      });\n    }\n\n    return QuoteCommand;\n  })(_contentKitEditorCommandsFormatBlock['default']);\n\n  exports['default'] = QuoteCommand;\n});","define('content-kit-editor/commands/subheading', ['exports', 'content-kit-editor/commands/format-block'], function (exports, _contentKitEditorCommandsFormatBlock) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var SubheadingCommand = (function (_FormatBlockCommand) {\n    _inherits(SubheadingCommand, _FormatBlockCommand);\n\n    function SubheadingCommand(editor) {\n      _classCallCheck(this, SubheadingCommand);\n\n      _get(Object.getPrototypeOf(SubheadingCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'subheading',\n        tag: 'h3',\n        button: '<i class=\"ck-icon-heading\"></i>3'\n      });\n    }\n\n    return SubheadingCommand;\n  })(_contentKitEditorCommandsFormatBlock['default']);\n\n  exports['default'] = SubheadingCommand;\n});","define('content-kit-editor/commands/text-format', ['exports', 'content-kit-editor/commands/base', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorCommandsBase, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var TextFormatCommand = (function (_Command) {\n    _inherits(TextFormatCommand, _Command);\n\n    function TextFormatCommand(editor) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      _classCallCheck(this, TextFormatCommand);\n\n      _get(Object.getPrototypeOf(TextFormatCommand.prototype), 'constructor', this).call(this, options);\n      this.editor = editor;\n      this.tag = options.tag;\n    }\n\n    _createClass(TextFormatCommand, [{\n      key: 'isActive',\n      value: function isActive() {\n        var _this = this;\n\n        return (0, _contentKitEditorUtilsArrayUtils.any)(this.editor.markupsInSelection, function (m) {\n          return m === _this.markup;\n        });\n      }\n    }, {\n      key: 'exec',\n      value: function exec() {\n        var range = this.editor.cursor.offsets;var markup = this.markup;\n\n        this.editor.run(function (postEditor) {\n          return postEditor.applyMarkupToRange(range, markup);\n        });\n        this.editor.selectRange(range);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var range = this.editor.cursor.offsets;var markup = this.markup;\n\n        this.editor.run(function (postEditor) {\n          return postEditor.removeMarkupFromRange(range, markup);\n        });\n        this.editor.selectRange(range);\n      }\n    }, {\n      key: 'markup',\n      get: function get() {\n        if (this._markup) {\n          return this._markup;\n        }\n        this._markup = this.editor.builder.createMarkup(this.tag);\n        return this._markup;\n      }\n    }]);\n\n    return TextFormatCommand;\n  })(_contentKitEditorCommandsBase['default']);\n\n  exports['default'] = TextFormatCommand;\n});","define('content-kit-editor/commands/unordered-list', ['exports', 'content-kit-editor/commands/list'], function (exports, _contentKitEditorCommandsList) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var UnorderedListCommand = (function (_ListCommand) {\n    _inherits(UnorderedListCommand, _ListCommand);\n\n    function UnorderedListCommand(editor) {\n      _classCallCheck(this, UnorderedListCommand);\n\n      _get(Object.getPrototypeOf(UnorderedListCommand.prototype), 'constructor', this).call(this, editor, {\n        name: 'Unordered List',\n        tag: 'ul',\n        button: '<i>ul</i>'\n      });\n    }\n\n    return UnorderedListCommand;\n  })(_contentKitEditorCommandsList['default']);\n\n  exports['default'] = UnorderedListCommand;\n});","define('content-kit-editor/editor/editor', ['exports', 'content-kit-editor/views/text-format-toolbar', 'content-kit-editor/views/tooltip', 'content-kit-editor/views/embed-intent', 'content-kit-editor/editor/post', 'content-kit-editor/cards/image', 'content-kit-editor/utils/key', 'content-kit-editor/utils/event-emitter', 'content-kit-editor/parsers/mobiledoc', 'content-kit-editor/parsers/post', 'content-kit-editor/parsers/dom', 'content-kit-editor/renderers/editor-dom', 'content-kit-editor/models/render-tree', 'content-kit-editor/renderers/mobiledoc', 'content-kit-utils', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/element-utils', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener', 'content-kit-editor/utils/cursor', 'content-kit-editor/models/post-node-builder', 'content-kit-editor/editor/text-expansions', 'content-kit-editor/editor/key-commands', 'content-kit-editor/utils/string-utils'], function (exports, _contentKitEditorViewsTextFormatToolbar, _contentKitEditorViewsTooltip, _contentKitEditorViewsEmbedIntent, _contentKitEditorEditorPost, _contentKitEditorCardsImage, _contentKitEditorUtilsKey, _contentKitEditorUtilsEventEmitter, _contentKitEditorParsersMobiledoc, _contentKitEditorParsersPost, _contentKitEditorParsersDom, _contentKitEditorRenderersEditorDom, _contentKitEditorModelsRenderTree, _contentKitEditorRenderersMobiledoc, _contentKitUtils, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsElementUtils, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener, _contentKitEditorUtilsCursor, _contentKitEditorModelsPostNodeBuilder, _contentKitEditorEditorTextExpansions, _contentKitEditorEditorKeyCommands, _contentKitEditorUtilsStringUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var EDITOR_ELEMENT_CLASS_NAME = 'ck-editor';\n\n  exports.EDITOR_ELEMENT_CLASS_NAME = EDITOR_ELEMENT_CLASS_NAME;\n  var defaults = {\n    placeholder: 'Write here...',\n    spellcheck: true,\n    autofocus: true,\n    // FIXME PhantomJS has 'ontouchstart' in window,\n    // causing the stickyToolbar to accidentally be auto-activated\n    // in tests\n    stickyToolbar: false, // !!('ontouchstart' in window),\n    cards: [],\n    cardOptions: {},\n    unknownCardHandler: function unknownCardHandler() {\n      throw new Error('Unknown card encountered');\n    },\n    mobiledoc: null,\n    html: null\n  };\n\n  function runCallbacks(callbacks, args) {\n    var i = undefined;\n    for (i = 0; i < callbacks.length; i++) {\n      callbacks[i].apply(null, args);\n    }\n  }\n\n  /**\n   * @class Editor\n   * An individual Editor\n   * @param element `Element` node\n   * @param options hash of options\n   */\n\n  var Editor = (function () {\n    function Editor() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, Editor);\n\n      if (!options || options.nodeType) {\n        throw new Error('editor create accepts an options object. For legacy usage passing an element for the first argument, consider the `html` option for loading DOM or HTML posts. For other cases call `editor.render(domNode)` after editor creation');\n      }\n      this._elementListeners = [];\n      this._views = [];\n      this.isEditable = null;\n\n      this._didUpdatePostCallbacks = [];\n      this._willRenderCallbacks = [];\n      this._didRenderCallbacks = [];\n\n      // FIXME: This should merge onto this.options\n      (0, _contentKitUtils.mergeWithOptions)(this, defaults, options);\n\n      this.cards.push(_contentKitEditorCardsImage['default']);\n\n      _contentKitEditorEditorTextExpansions.DEFAULT_TEXT_EXPANSIONS.forEach(function (e) {\n        return _this.registerExpansion(e);\n      });\n      _contentKitEditorEditorKeyCommands.DEFAULT_KEY_COMMANDS.forEach(function (kc) {\n        return _this.registerKeyCommand(kc);\n      });\n\n      this._parser = new _contentKitEditorParsersPost['default'](this.builder);\n      this._renderer = new _contentKitEditorRenderersEditorDom['default'](this, this.cards, this.unknownCardHandler, this.cardOptions);\n\n      this.post = this.loadPost();\n      this._renderTree = this.prepareRenderTree(this.post);\n    }\n\n    _createClass(Editor, [{\n      key: 'addView',\n      value: function addView(view) {\n        this._views.push(view);\n      }\n    }, {\n      key: 'prepareRenderTree',\n      value: function prepareRenderTree(post) {\n        var renderTree = new _contentKitEditorModelsRenderTree['default']();\n        var node = renderTree.buildRenderNode(post);\n        renderTree.node = node;\n        return renderTree;\n      }\n    }, {\n      key: 'loadPost',\n      value: function loadPost() {\n        if (this.mobiledoc) {\n          return new _contentKitEditorParsersMobiledoc['default'](this.builder).parse(this.mobiledoc);\n        } else if (this.html) {\n          if (typeof this.html === 'string') {\n            this.html = (0, _contentKitEditorUtilsDomUtils.parseHTML)(this.html);\n          }\n          return new _contentKitEditorParsersDom['default'](this.builder).parse(this.html);\n        } else {\n          return this.builder.createBlankPost();\n        }\n      }\n    }, {\n      key: 'rerender',\n      value: function rerender() {\n        var postRenderNode = this.post.renderNode;\n\n        // if we haven't rendered this post's renderNode before, mark it dirty\n        if (!postRenderNode.element) {\n          if (!this.element) {\n            throw new Error('Initial call to `render` must happen before `rerender` can be called.');\n          }\n          postRenderNode.element = this.element;\n          postRenderNode.markDirty();\n        }\n\n        runCallbacks(this._willRenderCallbacks, []);\n        this._renderer.render(this._renderTree);\n        runCallbacks(this._didRenderCallbacks, []);\n      }\n    }, {\n      key: 'render',\n      value: function render(element) {\n        if (this.element) {\n          throw new Error('Cannot render an editor twice. Use `rerender` to update the rendering of an existing editor instance');\n        }\n\n        this.element = element;\n\n        (0, _contentKitEditorUtilsDomUtils.addClassName)(this.element, EDITOR_ELEMENT_CLASS_NAME);\n        this.applyPlaceholder();\n\n        element.spellcheck = this.spellcheck;\n\n        if (this.isEditable === null) {\n          this.enableEditing();\n        }\n\n        (0, _contentKitEditorUtilsDomUtils.clearChildNodes)(element);\n\n        this._setupListeners();\n\n        this._addEmbedIntent();\n        this._addToolbar();\n        this._addTooltip();\n\n        // A call to `run` will trigger the didUpdatePostCallbacks hooks with a\n        // postEditor.\n        this.run(function () {});\n        this.rerender();\n\n        if (this.autofocus) {\n          element.focus();\n        }\n      }\n    }, {\n      key: '_addToolbar',\n      value: function _addToolbar() {\n        this.addView(new _contentKitEditorViewsTextFormatToolbar['default']({\n          editor: this,\n          rootElement: this.element,\n          commands: [],\n          sticky: this.stickyToolbar\n        }));\n      }\n    }, {\n      key: '_addTooltip',\n      value: function _addTooltip() {\n        this.addView(new _contentKitEditorViewsTooltip['default']({ rootElement: this.element, showForTag: 'a' }));\n      }\n    }, {\n      key: 'registerExpansion',\n      value: function registerExpansion(expansion) {\n        if (!(0, _contentKitEditorEditorTextExpansions.validateExpansion)(expansion)) {\n          throw new Error('Expansion is not valid');\n        }\n        this.expansions.push(expansion);\n      }\n    }, {\n      key: 'registerKeyCommand',\n      value: function registerKeyCommand(keyCommand) {\n        if (!(0, _contentKitEditorEditorKeyCommands.validateKeyCommand)(keyCommand)) {\n          throw new Error('Key Command is not valid');\n        }\n        this.keyCommands.push(keyCommand);\n      }\n    }, {\n      key: 'handleExpansion',\n      value: function handleExpansion(event) {\n        var expansion = (0, _contentKitEditorEditorTextExpansions.findExpansion)(this.expansions, event, this);\n        if (expansion) {\n          event.preventDefault();\n          expansion.run(this);\n        }\n      }\n    }, {\n      key: 'handleDeletion',\n      value: function handleDeletion(event) {\n        var _this2 = this;\n\n        event.preventDefault();\n\n        var range = this.cursor.offsets;\n\n        if (this.cursor.hasSelection()) {\n          this.run(function (postEditor) {\n            return postEditor.deleteRange(range);\n          });\n          this.cursor.moveToPosition(range.head);\n        } else {\n          (function () {\n            var key = _contentKitEditorUtilsKey['default'].fromEvent(event);\n            var nextPosition = _this2.run(function (postEditor) {\n              return postEditor.deleteFrom(range.head, key.direction);\n            });\n            _this2.cursor.moveToPosition(nextPosition);\n          })();\n        }\n      }\n    }, {\n      key: 'handleNewline',\n      value: function handleNewline(event) {\n        if (!this.cursor.hasCursor()) {\n          return;\n        }\n\n        var range = this.cursor.offsets;\n        event.preventDefault();\n\n        var cursorSection = this.run(function (postEditor) {\n          if (!range.isCollapsed) {\n            postEditor.deleteRange(range);\n            if (range.head.section.isBlank) {\n              return range.head.section;\n            }\n          }\n          return postEditor.splitSection(range.head)[1];\n        });\n        this.cursor.moveToSection(cursorSection);\n      }\n\n      // FIXME it might be nice to use the toolbar's prompt instead\n    }, {\n      key: 'showPrompt',\n      value: function showPrompt(message, defaultValue, callback) {\n        callback(window.prompt(message, defaultValue));\n      }\n    }, {\n      key: 'reportSelection',\n      value: function reportSelection() {\n        if (!this._hasSelection) {\n          this.trigger('selection');\n        } else {\n          this.trigger('selectionUpdated');\n        }\n        this._hasSelection = true;\n      }\n    }, {\n      key: 'reportNoSelection',\n      value: function reportNoSelection() {\n        if (this._hasSelection) {\n          this.trigger('selectionEnded');\n        }\n        this._hasSelection = false;\n      }\n    }, {\n      key: 'cancelSelection',\n      value: function cancelSelection() {\n        if (this._hasSelection) {\n          // FIXME perhaps restore cursor position to end of the selection?\n          this.cursor.clearSelection();\n          this.reportNoSelection();\n        }\n      }\n    }, {\n      key: 'didUpdate',\n      value: function didUpdate() {\n        this.trigger('update');\n      }\n    }, {\n      key: 'selectSections',\n      value: function selectSections(sections) {\n        this.cursor.selectSections(sections);\n        this.reportSelection();\n      }\n    }, {\n      key: 'selectRange',\n      value: function selectRange(range) {\n        this.cursor.selectRange(range);\n        if (range.isCollapsed) {\n          this.reportNoSelection();\n        } else {\n          this.reportSelection();\n        }\n      }\n    }, {\n      key: 'moveToPosition',\n      value: function moveToPosition(position) {\n        this.cursor.moveToPosition(position);\n        this.reportNoSelection();\n      }\n    }, {\n      key: 'applyPlaceholder',\n      value: function applyPlaceholder() {\n        var placeholder = this.placeholder;\n        var existingPlaceholder = (0, _contentKitEditorUtilsElementUtils.getData)(this.element, 'placeholder');\n\n        if (placeholder && !existingPlaceholder) {\n          (0, _contentKitEditorUtilsElementUtils.setData)(this.element, 'placeholder', placeholder);\n        }\n      }\n\n      /**\n       * types of input to handle:\n       *   * delete from beginning of section\n       *       joins 2 sections\n       *   * delete when multiple sections selected\n       *       removes wholly-selected sections,\n       *       joins the partially-selected sections\n       *   * hit enter (handled by capturing 'keydown' for enter key and `handleNewline`)\n       *       if anything is selected, delete it first, then\n       *       split the current marker at the cursor position,\n       *         schedule removal of every marker after the split,\n       *         create new section, append it to post\n       *         append the after-split markers onto the new section\n       *         rerender -- this should render the new section at the appropriate spot\n       */\n    }, {\n      key: 'handleInput',\n      value: function handleInput() {\n        this.reparse();\n        this.trigger('update');\n      }\n    }, {\n      key: 'reparse',\n      value: function reparse() {\n        var _cursor$offsets = this.cursor.offsets;\n        var headSection = _cursor$offsets.headSection;\n        var headSectionOffset = _cursor$offsets.headSectionOffset;\n\n        if (headSectionOffset === 0) {\n          // FIXME if the offset is 0, the user is typing the first character\n          // in an empty section, so we need to move the cursor 1 letter forward\n          headSectionOffset = 1;\n        }\n\n        this._reparseCurrentSection();\n        this._removeDetachedSections();\n\n        // A call to `run` will trigger the didUpdatePostCallbacks hooks with a\n        // postEditor.\n        this.run(function () {});\n        this.rerender();\n        this.trigger('update');\n\n        this.cursor.moveToSection(headSection, headSectionOffset);\n      }\n    }, {\n      key: '_removeDetachedSections',\n      value: function _removeDetachedSections() {\n        (0, _contentKitEditorUtilsArrayUtils.forEach)((0, _contentKitEditorUtilsArrayUtils.filter)(this.post.sections, function (s) {\n          return !s.renderNode.isAttached();\n        }), function (s) {\n          return s.renderNode.scheduleForRemoval();\n        });\n      }\n\n      /*\n       * Returns the active sections. If the cursor selection is collapsed this will be\n       * an array of 1 item. Else will return an array containing each section that is either\n       * wholly or partly contained by the cursor selection.\n       *\n       * @return {array} The sections from the cursor's selection start to the selection end\n       */\n    }, {\n      key: 'resetSectionMarkers',\n\n      /*\n       * Clear the markups from each of the section's markers\n       */\n      value: function resetSectionMarkers(section) {\n        section.markers.forEach(function (m) {\n          m.clearMarkups();\n          m.renderNode.markDirty();\n        });\n      }\n\n      /*\n       * Change the tag name for the given section\n       */\n    }, {\n      key: 'setSectionTagName',\n      value: function setSectionTagName(section, tagName) {\n        section.setTagName(tagName);\n        section.renderNode.markDirty();\n      }\n    }, {\n      key: 'resetSectionTagName',\n      value: function resetSectionTagName(section) {\n        section.resetTagName();\n        section.renderNode.markDirty();\n      }\n    }, {\n      key: '_reparseCurrentSection',\n      value: function _reparseCurrentSection() {\n        var currentSection = this.cursor.offsets.headSection;\n\n        this._parser.reparseSection(currentSection, this._renderTree);\n      }\n    }, {\n      key: 'serialize',\n      value: function serialize() {\n        return _contentKitEditorRenderersMobiledoc['default'].render(this.post);\n      }\n    }, {\n      key: 'removeAllViews',\n      value: function removeAllViews() {\n        this._views.forEach(function (v) {\n          return v.destroy();\n        });\n        this._views = [];\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this._isDestroyed = true;\n        this.removeAllEventListeners();\n        this.removeAllViews();\n      }\n\n      /**\n       * Keep the user from directly editing the post. Modification via the\n       * programmatic API is still permitted.\n       *\n       * @method disableEditing\n       * @return undefined\n       * @public\n       */\n    }, {\n      key: 'disableEditing',\n      value: function disableEditing() {\n        this.isEditable = false;\n        if (this.element) {\n          this.element.setAttribute('contentEditable', false);\n        }\n      }\n\n      /**\n       * Allow the user to directly interact with editing a post via a cursor.\n       *\n       * @method enableEditing\n       * @return undefined\n       * @public\n       */\n    }, {\n      key: 'enableEditing',\n      value: function enableEditing() {\n        this.isEditable = true;\n        if (this.element) {\n          this.element.setAttribute('contentEditable', true);\n        }\n      }\n\n      /**\n       * Run a new post editing session. Yields a block with a new `postEditor`\n       * instance. This instance can be used to interact with the post abstract,\n       * and defers rendering until the end of all changes.\n       *\n       * Usage:\n       *\n       *     let markerRange = this.cursor.offsets;\n       *     editor.run((postEditor) => {\n       *       postEditor.deleteRange(markerRange);\n       *       // editing surface not updated yet\n       *       postEditor.schedule(() => {\n       *         console.log('logs during rerender flush');\n       *       });\n       *       // logging not yet flushed\n       *     });\n       *     // editing surface now updated.\n       *     // logging now flushed\n       *\n       * The return value of `run` is whatever was returned from the callback.\n       *\n       * @method run\n       * @param {Function} callback Function to handle post editing with, provided the `postEditor` as an argument.\n       * @return {} Whatever the return value of `callback` is.\n       * @public\n       */\n    }, {\n      key: 'run',\n      value: function run(callback) {\n        var postEditor = new _contentKitEditorEditorPost['default'](this);\n        var result = callback(postEditor);\n        runCallbacks(this._didUpdatePostCallbacks, [postEditor]);\n        postEditor.complete();\n        return result;\n      }\n    }, {\n      key: 'didUpdatePost',\n      value: function didUpdatePost(callback) {\n        this._didUpdatePostCallbacks.push(callback);\n      }\n    }, {\n      key: 'willRender',\n      value: function willRender(callback) {\n        this._willRenderCallbacks.push(callback);\n      }\n    }, {\n      key: 'didRender',\n      value: function didRender(callback) {\n        this._didRenderCallbacks.push(callback);\n      }\n    }, {\n      key: '_addEmbedIntent',\n      value: function _addEmbedIntent() {\n        this.addView(new _contentKitEditorViewsEmbedIntent['default']({\n          editor: this,\n          rootElement: this.element\n        }));\n      }\n    }, {\n      key: '_setupListeners',\n      value: function _setupListeners() {\n        var _this3 = this;\n\n        var elementEvents = ['keydown', 'keyup', 'input', 'dragover', 'drop', 'paste'];\n        var documentEvents = ['mouseup'];\n\n        elementEvents.forEach(function (eventName) {\n          _this3.addEventListener(_this3.element, eventName, function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return _this3.handleEvent.apply(_this3, [eventName].concat(args));\n          });\n        });\n\n        documentEvents.forEach(function (eventName) {\n          _this3.addEventListener(document, eventName, function () {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            return _this3.handleEvent.apply(_this3, [eventName].concat(args));\n          });\n        });\n      }\n    }, {\n      key: 'handleEvent',\n      value: function handleEvent(eventName) {\n        if (this.cursor.isInCard()) {\n          return;\n        }\n\n        var methodName = 'handle' + (0, _contentKitEditorUtilsStringUtils.capitalize)(eventName);\n        if (!this[methodName]) {\n          throw new Error('No handler for ' + eventName);\n        }\n\n        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          args[_key3 - 1] = arguments[_key3];\n        }\n\n        this[methodName].apply(this, args);\n      }\n    }, {\n      key: 'handleMouseup',\n      value: function handleMouseup() {\n        var _this4 = this;\n\n        // mouseup does not correctly report a selection until the next tick\n        setTimeout(function () {\n          return _this4._reportSelectionState();\n        });\n      }\n    }, {\n      key: 'handleKeyup',\n      value: function handleKeyup(event) {\n        var key = _contentKitEditorUtilsKey['default'].fromEvent(event);\n\n        if (key.isEscape()) {\n          this.trigger('escapeKey');\n        }\n        this._reportSelectionState();\n      }\n\n      /*\n         The following events/sequences can create a selection and are handled:\n           * mouseup -- can happen anywhere in document, must wait until next tick to read selection\n           * keyup when key is a movement key and shift is pressed -- in editor element\n           * keyup when key combo was cmd-A (alt-A) aka \"select all\"\n           * keyup when key combo was cmd-Z (browser may restore selection)\n         These cases can create a selection and are not handled:\n           * ctrl-click -> context menu -> click \"select all\"\n       */\n    }, {\n      key: '_reportSelectionState',\n      value: function _reportSelectionState() {\n        if (this.cursor.hasSelection()) {\n          this.reportSelection();\n        } else {\n          this.reportNoSelection();\n        }\n      }\n    }, {\n      key: 'handleDragover',\n      value: function handleDragover(e) {\n        e.preventDefault(); // FIXME for now, just prevent default\n      }\n    }, {\n      key: 'handleDrop',\n      value: function handleDrop(e) {\n        e.preventDefault(); // FIXME for now, just prevent default\n      }\n    }, {\n      key: '_insertEmptyMarkupSectionAtCursor',\n      value: function _insertEmptyMarkupSectionAtCursor() {\n        var _this5 = this;\n\n        var section = this.run(function (postEditor) {\n          var section = postEditor.builder.createMarkupSection('p');\n          postEditor.insertSectionBefore(_this5.post.sections, section);\n          return section;\n        });\n        this.cursor.moveToSection(section);\n      }\n    }, {\n      key: 'handleKeydown',\n      value: function handleKeydown(event) {\n        var _this6 = this;\n\n        if (!this.isEditable) {\n          return;\n        }\n        if (this.post.isBlank) {\n          this._insertEmptyMarkupSectionAtCursor();\n        }\n\n        var key = _contentKitEditorUtilsKey['default'].fromEvent(event);\n\n        if (key.isDelete()) {\n          this.handleDeletion(event);\n          event.preventDefault();\n        } else if (key.isEnter()) {\n          this.handleNewline(event);\n        } else if (key.isPrintable()) {\n          if (this.cursor.hasSelection()) {\n            (function () {\n              var range = _this6.cursor.offsets;\n              _this6.run(function (postEditor) {\n                return postEditor.deleteRange(range);\n              });\n              _this6.cursor.moveToPosition(range.head);\n            })();\n          }\n        }\n\n        this.handleExpansion(event);\n        this.handleKeyCommand(event);\n      }\n    }, {\n      key: 'handleKeyCommand',\n      value: function handleKeyCommand(event) {\n        var keyCommand = (0, _contentKitEditorEditorKeyCommands.findKeyCommand)(this.keyCommands, event);\n        if (keyCommand) {\n          event.preventDefault();\n          keyCommand.run(this);\n        }\n      }\n    }, {\n      key: 'handlePaste',\n      value: function handlePaste(event) {\n        event.preventDefault(); // FIXME for now, just prevent pasting\n      }\n    }, {\n      key: 'builder',\n      get: function get() {\n        if (!this._builder) {\n          this._builder = new _contentKitEditorModelsPostNodeBuilder['default']();\n        }\n        return this._builder;\n      }\n    }, {\n      key: 'expansions',\n      get: function get() {\n        if (!this._expansions) {\n          this._expansions = [];\n        }\n        return this._expansions;\n      }\n    }, {\n      key: 'keyCommands',\n      get: function get() {\n        if (!this._keyCommands) {\n          this._keyCommands = [];\n        }\n        return this._keyCommands;\n      }\n    }, {\n      key: 'cursor',\n      get: function get() {\n        return new _contentKitEditorUtilsCursor['default'](this);\n      }\n    }, {\n      key: 'activeSections',\n      get: function get() {\n        return this.cursor.activeSections;\n      }\n    }, {\n      key: 'markupsInSelection',\n      get: function get() {\n        if (this.cursor.hasSelection()) {\n          var range = this.cursor.offsets;\n          return this.post.markupsInRange(range);\n        } else {\n          return [];\n        }\n      }\n    }]);\n\n    return Editor;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(Editor, _contentKitEditorUtilsEventEmitter['default']);\n  (0, _contentKitEditorUtilsMixin['default'])(Editor, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = Editor;\n});","define('content-kit-editor/editor/key-commands', ['exports', 'content-kit-editor/utils/key', 'content-kit-editor/utils/array-utils', 'content-kit-editor/commands/link', 'content-kit-editor/commands/bold', 'content-kit-editor/commands/italic'], function (exports, _contentKitEditorUtilsKey, _contentKitEditorUtilsArrayUtils, _contentKitEditorCommandsLink, _contentKitEditorCommandsBold, _contentKitEditorCommandsItalic) {\n  'use strict';\n\n  exports.validateKeyCommand = validateKeyCommand;\n  exports.findKeyCommand = findKeyCommand;\n\n  function runSelectionCommand(editor, CommandKlass) {\n    if (editor.cursor.hasSelection()) {\n      var cmd = new CommandKlass(editor);\n      if (cmd.isActive()) {\n        cmd.unexec();\n      } else {\n        cmd.exec();\n      }\n    }\n  }\n\n  var DEFAULT_KEY_COMMANDS = [{\n    modifier: _contentKitEditorUtilsKey.MODIFIERS.META,\n    str: 'B',\n    run: function run(editor) {\n      runSelectionCommand(editor, _contentKitEditorCommandsBold['default']);\n    }\n  }, {\n    modifier: _contentKitEditorUtilsKey.MODIFIERS.CTRL,\n    str: 'B',\n    run: function run(editor) {\n      runSelectionCommand(editor, _contentKitEditorCommandsBold['default']);\n    }\n  }, {\n    modifier: _contentKitEditorUtilsKey.MODIFIERS.META,\n    str: 'I',\n    run: function run(editor) {\n      runSelectionCommand(editor, _contentKitEditorCommandsItalic['default']);\n    }\n  }, {\n    modifier: _contentKitEditorUtilsKey.MODIFIERS.CTRL,\n    str: 'I',\n    run: function run(editor) {\n      runSelectionCommand(editor, _contentKitEditorCommandsItalic['default']);\n    }\n  }, {\n    modifier: _contentKitEditorUtilsKey.MODIFIERS.META,\n    str: 'K',\n    run: function run(editor) {\n      if (!editor.cursor.hasSelection()) {\n        return;\n      }\n\n      var selectedText = editor.cursor.selectedText();\n      var defaultUrl = '';\n      if (selectedText.indexOf('http') !== -1) {\n        defaultUrl = selectedText;\n      }\n\n      editor.showPrompt('Enter a URL', defaultUrl, function (url) {\n        if (!url) {\n          return;\n        }\n\n        var linkCommand = new _contentKitEditorCommandsLink['default'](editor);\n        linkCommand.exec(url);\n      });\n    }\n  }];\n\n  exports.DEFAULT_KEY_COMMANDS = DEFAULT_KEY_COMMANDS;\n\n  function validateKeyCommand(keyCommand) {\n    return !!keyCommand.modifier && !!keyCommand.str && !!keyCommand.run;\n  }\n\n  function findKeyCommand(keyCommands, keyEvent) {\n    var key = _contentKitEditorUtilsKey['default'].fromEvent(keyEvent);\n\n    return (0, _contentKitEditorUtilsArrayUtils.detect)(keyCommands, function (_ref) {\n      var modifier = _ref.modifier;\n      var str = _ref.str;\n\n      return key.hasModifier(modifier) && key.isChar(str);\n    });\n  }\n});","define('content-kit-editor/editor/post', ['exports', 'content-kit-editor/models/types', 'content-kit-editor/utils/cursor/position', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/key'], function (exports, _contentKitEditorModelsTypes, _contentKitEditorUtilsCursorPosition, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsKey) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function isMarkupSection(section) {\n    return section.type === _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE;\n  }\n\n  function isListItem(section) {\n    return section.type === _contentKitEditorModelsTypes.LIST_ITEM_TYPE;\n  }\n\n  function isBlankAndListItem(section) {\n    return isListItem(section) && section.isBlank;\n  }\n\n  function isMarkerable(section) {\n    return !!section.markers;\n  }\n\n  var PostEditor = (function () {\n    function PostEditor(editor) {\n      _classCallCheck(this, PostEditor);\n\n      this.editor = editor;\n      this.builder = this.editor.builder;\n      this._completionWorkQueue = [];\n      this._didRerender = false;\n      this._didUpdate = false;\n      this._didComplete = false;\n    }\n\n    /**\n     * Remove a range from the post\n     *\n     * Usage:\n     *\n     *     const range = editor.cursor.offsets;\n     *     editor.run((postEditor) => {\n     *       postEditor.deleteRange(range);\n     *     });\n     *\n     * @method deleteRange\n     * @param {Range} range Cursor Range object with head and tail Positions\n     * @public\n     */\n\n    _createClass(PostEditor, [{\n      key: 'deleteRange',\n      value: function deleteRange(range) {\n        var _this = this;\n\n        // types of selection deletion:\n        //   * a selection starts at the beginning of a section\n        //     -- cursor should end up at the beginning of that section\n        //     -- if the section not longer has markers, add a blank one for the cursor to focus on\n        //   * a selection is entirely within a section\n        //     -- split the markers with the selection, remove those new markers from their section\n        //     -- cursor goes at end of the marker before the selection start, or if the\n        //     -- selection was at the start of the section, cursor goes at section start\n        //   * a selection crosses multiple sections\n        //     -- remove all the sections that are between (exclusive) selection start and end\n        //     -- join the start and end sections\n        //     -- mark the end section for removal\n        //     -- cursor goes at end of marker before the selection start\n\n        var _range$head = range.head;\n        var headSection = _range$head.section;\n        var headSectionOffset = _range$head.offset;\n        var _range$tail = range.tail;\n        var tailSection = _range$tail.section;\n        var tailSectionOffset = _range$tail.offset;\n        var post = this.editor.post;\n\n        if (headSection === tailSection) {\n          this.cutSection(headSection, headSectionOffset, tailSectionOffset);\n        } else {\n          (function () {\n            var removedSections = post.sectionsContainedBy(range);\n            post.walkMarkerableSections(range, function (section) {\n              switch (section) {\n                case headSection:\n                  _this.cutSection(section, headSectionOffset, section.text.length);\n                  break;\n                case tailSection:\n                  section.markersFor(tailSectionOffset, section.text.length).forEach(function (m) {\n                    headSection.markers.append(m);\n                  });\n                  headSection.renderNode.markDirty(); // May have added nodes\n                  removedSections.push(section);\n                  break;\n                default:\n                  if (removedSections.indexOf(section) === -1) {\n                    removedSections.push(section);\n                  }\n              }\n            });\n            removedSections.forEach(function (section) {\n              return _this.removeSection(section);\n            });\n          })();\n        }\n\n        this._coalesceMarkers(headSection);\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n    }, {\n      key: 'cutSection',\n      value: function cutSection(section, headSectionOffset, tailSectionOffset) {\n        if (section.markers.isEmpty) {\n          return;\n        }\n\n        var adjustedHead = 0,\n            marker = section.markers.head,\n            adjustedTail = marker.length;\n\n        // Walk to the first node inside the headSectionOffset, splitting\n        // a marker if needed. Leave marker as the first node inside.\n        while (marker) {\n          if (adjustedTail >= headSectionOffset) {\n            var splitOffset = headSectionOffset - adjustedHead;\n\n            var _splitMarker = this.splitMarker(marker, splitOffset);\n\n            var afterMarker = _splitMarker.afterMarker;\n\n            adjustedHead = adjustedHead + splitOffset;\n            // FIXME: That these two loops cannot agree on adjustedTail being\n            // incremented at the start or end seems prime for refactoring.\n            adjustedTail = adjustedHead;\n            marker = afterMarker;\n            break;\n          }\n          adjustedHead += marker.length;\n          marker = marker.next;\n          if (marker) {\n            adjustedTail += marker.length;\n          }\n        }\n\n        // Walk each marker inside, removing it if needed. when the last is\n        // reached split it and remove the part inside the tailSectionOffset\n        while (marker) {\n          adjustedTail += marker.length;\n          if (adjustedTail >= tailSectionOffset) {\n            var splitOffset = marker.length - (adjustedTail - tailSectionOffset);\n\n            var _splitMarker2 = this.splitMarker(marker, splitOffset);\n\n            var beforeMarker = _splitMarker2.beforeMarker;\n\n            if (beforeMarker) {\n              this.removeMarker(beforeMarker);\n            }\n            break;\n          }\n          adjustedHead += marker.length;\n          var nextMarker = marker.next;\n          this.removeMarker(marker);\n          marker = nextMarker;\n        }\n      }\n    }, {\n      key: '_coalesceMarkers',\n      value: function _coalesceMarkers(section) {\n        var _this2 = this;\n\n        (0, _contentKitEditorUtilsArrayUtils.filter)(section.markers, function (m) {\n          return m.isEmpty;\n        }).forEach(function (marker) {\n          _this2.removeMarker(marker);\n        });\n      }\n    }, {\n      key: 'removeMarker',\n      value: function removeMarker(marker) {\n        var didChange = false;\n        if (marker.renderNode) {\n          marker.renderNode.scheduleForRemoval();\n          didChange = true;\n        }\n        if (marker.section) {\n          marker.section.markers.remove(marker);\n          didChange = true;\n        }\n\n        if (didChange) {\n          this.scheduleRerender();\n          this.scheduleDidUpdate();\n        }\n      }\n\n      /**\n       * Remove a character from a {marker, offset} position, in either\n       * forward or backward (default) direction.\n       *\n       * Usage:\n       *\n       *     let marker = editor.post.sections.head.markers.head;\n       *     // marker has text of \"Howdy!\"\n       *     editor.run((postEditor) => {\n       *       postEditor.deleteFrom({section, offset: 3});\n       *     });\n       *     // marker has text of \"Hody!\"\n       *\n       * `deleteFrom` may remove a character from a different marker or join the\n       * marker's section with the previous/next section (depending on the\n       * deletion direction) if direction is `BACKWARD` and the offset is 0,\n       * or direction is `FORWARD` and the offset is equal to the length of the\n       * marker.\n       *\n       * @method deleteFrom\n       * @param {Position} position object with {section, offset} the marker and offset to delete from\n       * @param {Number} direction The direction to delete in (default is BACKWARD)\n       * @return {Position} for positioning the cursor\n       * @public\n       */\n    }, {\n      key: 'deleteFrom',\n      value: function deleteFrom(position) {\n        var direction = arguments.length <= 1 || arguments[1] === undefined ? _contentKitEditorUtilsKey.DIRECTION.BACKWARD : arguments[1];\n\n        if (direction === _contentKitEditorUtilsKey.DIRECTION.BACKWARD) {\n          return this._deleteBackwardFrom(position);\n        } else {\n          return this._deleteForwardFrom(position);\n        }\n      }\n    }, {\n      key: '_joinPositionToPreviousSection',\n      value: function _joinPositionToPreviousSection(position) {\n        var section = position.section;\n\n        var nextPosition = position.clone();\n\n        if (!isMarkerable(section)) {\n          throw new Error('Cannot join non-markerable section to previous section');\n        } else if (isListItem(section)) {\n          nextPosition = this._convertListItemToMarkupSection(section);\n        } else {\n          var prevSection = section.immediatelyPreviousMarkerableSection();\n\n          if (prevSection) {\n            var _prevSection$join = prevSection.join(section);\n\n            var beforeMarker = _prevSection$join.beforeMarker;\n\n            prevSection.renderNode.markDirty();\n            this.removeSection(section);\n\n            nextPosition.section = prevSection;\n            nextPosition.offset = beforeMarker ? prevSection.offsetOfMarker(beforeMarker, beforeMarker.length) : 0;\n          }\n        }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return nextPosition;\n      }\n\n      /**\n       * delete 1 character in the FORWARD direction from the given position\n       * @method _deleteForwardFrom\n       * @param {Position} position\n       * @private\n       */\n    }, {\n      key: '_deleteForwardFrom',\n      value: function _deleteForwardFrom(position) {\n        var section = position.section;\n        var offset = position.offset;\n\n        if (section.isBlank) {\n          // remove this section, focus on start of next markerable section\n          var nextPosition = position.clone();\n          var next = section.immediatelyNextMarkerableSection();\n          if (next) {\n            this.removeSection(section);\n            nextPosition.section = next;\n            nextPosition.offset = 0;\n          }\n          return nextPosition;\n        } else if (offset === section.length) {\n          // join next markerable section to this one\n          return this._joinPositionToNextSection(position);\n        } else {\n          return this._deleteForwardFromMarkerPosition(position.markerPosition);\n        }\n      }\n    }, {\n      key: '_joinPositionToNextSection',\n      value: function _joinPositionToNextSection(position) {\n        var section = position.section;\n\n        var nextPosition = position.clone();\n\n        if (!isMarkerable(section)) {\n          throw new Error('Cannot join non-markerable section to next section');\n        } else {\n          var next = section.immediatelyNextMarkerableSection();\n          if (next) {\n            section.join(next);\n            section.renderNode.markDirty();\n            this.removeSection(next);\n\n            this.scheduleRerender();\n            this.scheduleDidUpdate();\n          }\n        }\n\n        return nextPosition;\n      }\n    }, {\n      key: '_deleteForwardFromMarkerPosition',\n      value: function _deleteForwardFromMarkerPosition(markerPosition) {\n        var marker = markerPosition.marker;\n        var offset = markerPosition.offset;\n        var section = marker.section;\n\n        var nextPosition = new _contentKitEditorUtilsCursorPosition['default'](section, section.offsetOfMarker(marker, offset));\n\n        if (offset === marker.length) {\n          var nextMarker = marker.next;\n\n          if (nextMarker) {\n            var nextMarkerPosition = { marker: nextMarker, offset: 0 };\n            return this._deleteForwardFromMarkerPosition(nextMarkerPosition);\n          } else {\n            var nextSection = marker.section.next;\n            if (nextSection && isMarkupSection(nextSection)) {\n              var currentSection = marker.section;\n\n              currentSection.join(nextSection);\n              currentSection.renderNode.markDirty();\n\n              this.removeSection(nextSection);\n            }\n          }\n        } else {\n          marker.deleteValueAtOffset(offset);\n          marker.renderNode.markDirty();\n          this._coalesceMarkers(marker.section);\n        }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return nextPosition;\n      }\n    }, {\n      key: '_convertListItemToMarkupSection',\n      value: function _convertListItemToMarkupSection(listItem) {\n        var listSection = listItem.parent;\n\n        var newSections = listItem.splitIntoSections();\n        var newMarkupSection = newSections[1];\n\n        this._replaceSection(listSection, (0, _contentKitEditorUtilsArrayUtils.compact)(newSections));\n\n        return new _contentKitEditorUtilsCursorPosition['default'](newMarkupSection, 0);\n      }\n\n      /**\n       * delete 1 character in the BACKWARD direction from the given position\n       * @method _deleteBackwardFrom\n       * @param {Position} position\n       * @private\n       */\n    }, {\n      key: '_deleteBackwardFrom',\n      value: function _deleteBackwardFrom(position) {\n        var sectionOffset = position.offset;\n\n        if (sectionOffset === 0) {\n          return this._joinPositionToPreviousSection(position);\n        }\n\n        var nextPosition = position.clone();\n        var _position$markerPosition = position.markerPosition;\n        var marker = _position$markerPosition.marker;\n        var markerOffset = _position$markerPosition.offset;\n\n        var offsetToDeleteAt = markerOffset - 1;\n\n        marker.deleteValueAtOffset(offsetToDeleteAt);\n        nextPosition.offset -= 1;\n        marker.renderNode.markDirty();\n        this._coalesceMarkers(marker.section);\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return nextPosition;\n      }\n\n      /**\n       * Split markers at two positions, once at the head, and if necessary once\n       * at the tail. This method is designed to accept a range\n       * (e.g. `editor.cursor.offsets`) as an argument.\n       *\n       * Usage:\n       *\n       *     let markerRange = this.cursor.offsets;\n       *     editor.run((postEditor) => {\n       *       postEditor.splitMarkers(markerRange);\n       *     });\n       *\n       * The return value will be marker object completely inside the offsets\n       * provided. Markers on the outside of the split may also have been modified.\n       *\n       * @method splitMarkers\n       * @param {Range} markerRange\n       * @return {Array} of markers that are inside the split\n       * @public\n       */\n    }, {\n      key: 'splitMarkers',\n      value: function splitMarkers(range) {\n        var post = this.editor.post;\n        var headSection = range.headSection;\n        var tailSection = range.tailSection;\n        var headMarker = range.headMarker;\n        var headMarkerOffset = range.headMarkerOffset;\n        var tailMarker = range.tailMarker;\n        var tailMarkerOffset = range.tailMarkerOffset;\n\n        // These render nodes will be removed by the split functions. Mark them\n        // for removal before doing that. FIXME this seems prime for\n        // refactoring onto the postEditor as a split function\n        headMarker.renderNode.scheduleForRemoval();\n        tailMarker.renderNode.scheduleForRemoval();\n        headMarker.section.renderNode.markDirty();\n        tailMarker.section.renderNode.markDirty();\n\n        if (headMarker === tailMarker) {\n          headSection.splitMarker(headMarker, headMarkerOffset, tailMarkerOffset);\n        } else {\n          headSection.splitMarker(headMarker, headMarkerOffset);\n          tailSection.splitMarker(tailMarker, 0, tailMarkerOffset);\n        }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return post.markersContainedByRange(range);\n      }\n    }, {\n      key: 'splitMarker',\n      value: function splitMarker(marker, offset) {\n        var beforeMarker = undefined,\n            afterMarker = undefined;\n\n        if (offset === 0) {\n          beforeMarker = marker.prev;\n          afterMarker = marker;\n        } else if (offset === marker.length) {\n          beforeMarker = marker;\n          afterMarker = marker.next;\n        } else {\n          var builder = this.editor.builder;\n          var section = marker.section;\n\n          beforeMarker = builder.createMarker(marker.value.substring(0, offset), marker.markups);\n          afterMarker = builder.createMarker(marker.value.substring(offset, marker.length), marker.markups);\n          section.markers.splice(marker, 1, [beforeMarker, afterMarker]);\n          if (marker.renderNode) {\n            marker.renderNode.scheduleForRemoval();\n          }\n          if (section.renderNode) {\n            section.renderNode.markDirty();\n          }\n        }\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n        return { beforeMarker: beforeMarker, afterMarker: afterMarker };\n      }\n\n      /**\n       * Split a section at one position. This method is designed to accept\n       * `editor.cursor.offsets` as an argument, but will only split at the\n       * head of the cursor position.\n       *\n       * Usage:\n       *\n       *     let marker = editor.post.sections.head.marker.head;\n       *     editor.run((postEditor) => {\n       *       postEditor.splitSection({\n       *         headSection: section,\n       *         headSectionOffset: 3\n       *       });\n       *     });\n       *     // Will result in the marker and its old section being removed from\n       *     // the post and rendered DOM, and in the creation of two new sections\n       *     // replacing the old one.\n       *\n       * The return value will be the two new sections. One or both of these\n       * sections can be blank (contain only a blank marker), for example if the\n       * headMarkerOffset is 0.\n       *\n       * @method splitSection\n       * @param {Position} position\n       * @return {Array} new sections, one for the first half and one for the second\n       * @public\n       */\n    }, {\n      key: 'splitSection',\n      value: function splitSection(position) {\n        var section = position.section;\n\n        var _section$splitAtPosition = section.splitAtPosition(position);\n\n        var _section$splitAtPosition2 = _slicedToArray(_section$splitAtPosition, 2);\n\n        var beforeSection = _section$splitAtPosition2[0];\n        var afterSection = _section$splitAtPosition2[1];\n\n        this._coalesceMarkers(beforeSection);\n        this._coalesceMarkers(afterSection);\n\n        var newSections = [beforeSection, afterSection];\n        var replacementSections = [beforeSection, afterSection];\n\n        if (isBlankAndListItem(beforeSection) && isBlankAndListItem(section)) {\n          var isLastItemInList = section === section.parent.sections.tail;\n\n          if (isLastItemInList) {\n            // when hitting enter in a final empty list item, do not insert a new\n            // empty item\n            replacementSections.shift();\n          }\n        }\n\n        this._replaceSection(section, replacementSections);\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        // FIXME we must return 2 sections because other code expects this to always return 2\n        return newSections;\n      }\n\n      /**\n       * @method replaceSection\n       * @param {Section} section\n       * @param {Section} newSection\n       * @return null\n       * @public\n       */\n    }, {\n      key: 'replaceSection',\n      value: function replaceSection(section, newSection) {\n        if (!section) {\n          // The section may be undefined if the user used the embed intent\n          // (\"+\" icon) to insert a new \"ul\" section in a blank post\n          this.insertSectionBefore(this.editor.post.sections, newSection);\n        } else {\n          this._replaceSection(section, [newSection]);\n        }\n      }\n    }, {\n      key: '_replaceSection',\n      value: function _replaceSection(section, newSections) {\n        var _this3 = this;\n\n        var nextSection = section.next;\n        var collection = section.parent.sections;\n\n        var nextNewSection = newSections[0];\n        if (isMarkupSection(nextNewSection) && isListItem(section)) {\n          // put the new section after the ListSection (section.parent) instead of after the ListItem\n          collection = section.parent.parent.sections;\n          nextSection = section.parent.next;\n        }\n\n        newSections.forEach(function (s) {\n          return _this3.insertSectionBefore(collection, s, nextSection);\n        });\n        this.removeSection(section);\n      }\n\n      /**\n       * Given a markerRange (for example `editor.cursor.offsets`) mark all markers\n       * inside it as a given markup. The markup must be provided as a post\n       * abstract node.\n       *\n       * Usage:\n       *\n       *     const range = editor.cursor.offsets;\n       *     const strongMarkup = editor.builder.createMarkup('strong');\n       *     editor.run((postEditor) => {\n       *       postEditor.applyMarkupToRange(range, strongMarkup);\n       *     });\n       *     // Will result some markers possibly being split, and the markup\n       *     // being applied to all markers between the split.\n       *\n       * The return value will be all markers between the split, the same return\n       * value as `splitMarkers`.\n       *\n       * @method applyMarkupToRange\n       * @param {Range} markerRange\n       * @param {Markup} markup A markup post abstract node\n       * @return {Array} of markers that are inside the split\n       * @public\n       */\n    }, {\n      key: 'applyMarkupToRange',\n      value: function applyMarkupToRange(markerRange, markup) {\n        var markers = this.splitMarkers(markerRange);\n        markers.forEach(function (marker) {\n          marker.addMarkup(markup);\n          marker.section.renderNode.markDirty();\n        });\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return markers;\n      }\n\n      /**\n       * Given a markerRange (for example `editor.cursor.offsets`) remove the given\n       * markup from all contained markers. The markup must be provided as a post\n       * abstract node.\n       *\n       * Usage:\n       *\n       *     const range = editor.cursor.offsets;\n       *     const markup = markerRange.headMarker.markups[0];\n       *     editor.run((postEditor) => {\n       *       postEditor.removeMarkupFromRange(range, markup);\n       *     });\n       *     // Will result some markers possibly being split, and the markup\n       *     // being removed from all markers between the split.\n       *\n       * The return value will be all markers between the split, the same return\n       * value as `splitMarkers`.\n       *\n       * @method removeMarkupFromRange\n       * @param {Range} range Object with offsets\n       * @param {Markup} markup A markup post abstract node\n       * @return {Array} of markers that are inside the split\n       * @public\n       */\n    }, {\n      key: 'removeMarkupFromRange',\n      value: function removeMarkupFromRange(range, markupOrMarkupCallback) {\n        var markers = this.splitMarkers(range);\n        markers.forEach(function (marker) {\n          marker.removeMarkup(markupOrMarkupCallback);\n          marker.section.renderNode.markDirty();\n        });\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n\n        return markers;\n      }\n\n      /**\n       * Insert a given section before another one, updating the post abstract\n       * and the rendered UI.\n       *\n       * Usage:\n       *\n       *     let markerRange = editor.cursor.offsets;\n       *     let sectionWithCursor = markerRange.headMarker.section;\n       *     let section = editor.builder.createCardSection('my-image');\n       *     let collection = sectionWithCursor.parent.sections;\n       *     editor.run((postEditor) => {\n       *       postEditor.insertSectionBefore(collection, section, sectionWithCursor);\n       *     });\n       *\n       * @method insertSectionBefore\n       * @param {LinkedList} collection The list of sections to insert into\n       * @param {Object} section The new section\n       * @param {Object} beforeSection Optional The section \"before\" is relative to,\n       * if falsy the new section will be appended to the collection\n       * @public\n       */\n    }, {\n      key: 'insertSectionBefore',\n      value: function insertSectionBefore(collection, section, beforeSection) {\n        collection.insertBefore(section, beforeSection);\n        section.parent.renderNode.markDirty();\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n\n      /**\n       * Remove a given section from the post abstract and the rendered UI.\n       *\n       * Usage:\n       *\n       *     const range = editor.cursor.offsets;\n       *     const sectionWithCursor = range.head.section;\n       *     editor.run((postEditor) => {\n       *       postEditor.removeSection(sectionWithCursor);\n       *     });\n       *\n       * @method removeSection\n       * @param {Object} section The section to remove\n       * @public\n       */\n    }, {\n      key: 'removeSection',\n      value: function removeSection(section) {\n        var parent = section.parent;\n        var parentIsRemoved = parent.renderNode.isRemoved;\n\n        if (parentIsRemoved) {\n          // This can happen if we remove a list section and later\n          // try to remove one of the section's list items;\n          return;\n        }\n\n        section.renderNode.scheduleForRemoval();\n\n        parent.sections.remove(section);\n\n        if (parent.isBlank && parent.type !== _contentKitEditorModelsTypes.POST_TYPE) {\n          // If we removed the last child from a parent (e.g. the last li in a ul),\n          // also remove the parent\n          this.removeSection(parent);\n        }\n\n        this.scheduleRerender();\n        this.scheduleDidUpdate();\n      }\n\n      /**\n       * A method for adding work the deferred queue\n       *\n       * @method schedule\n       * @param {Function} callback to run during completion\n       * @public\n       */\n    }, {\n      key: 'schedule',\n      value: function schedule(callback) {\n        if (this._didComplete) {\n          throw new Error('Work can only be scheduled before a post edit has completed');\n        }\n        this._completionWorkQueue.push(callback);\n      }\n\n      /**\n       * Add a rerender job to the queue\n       *\n       * @method scheduleRerender\n       * @public\n       */\n    }, {\n      key: 'scheduleRerender',\n      value: function scheduleRerender() {\n        var _this4 = this;\n\n        this.schedule(function () {\n          if (!_this4._didRerender) {\n            _this4._didRerender = true;\n            _this4.editor.rerender();\n          }\n        });\n      }\n\n      /**\n       * Add a didUpdate job to the queue\n       *\n       * @method scheduleDidRender\n       * @public\n       */\n    }, {\n      key: 'scheduleDidUpdate',\n      value: function scheduleDidUpdate() {\n        var _this5 = this;\n\n        this.schedule(function () {\n          if (!_this5._didUpdate) {\n            _this5._didUpdate = true;\n            _this5.editor.didUpdate();\n          }\n        });\n      }\n\n      /**\n       * Flush any work on the queue. `editor.run` already does this, calling this\n       * method directly should not be needed outside `editor.run`.\n       *\n       * @method complete\n       * @private\n       */\n    }, {\n      key: 'complete',\n      value: function complete() {\n        if (this._didComplete) {\n          throw new Error('Post editing can only be completed once');\n        }\n        this._didComplete = true;\n        this._completionWorkQueue.forEach(function (callback) {\n          callback();\n        });\n      }\n    }]);\n\n    return PostEditor;\n  })();\n\n  exports['default'] = PostEditor;\n});","define('content-kit-editor/editor/text-expansions', ['exports', 'content-kit-editor/utils/keycodes', 'content-kit-editor/utils/key', 'content-kit-editor/utils/array-utils', 'content-kit-editor/models/types'], function (exports, _contentKitEditorUtilsKeycodes, _contentKitEditorUtilsKey, _contentKitEditorUtilsArrayUtils, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  exports.validateExpansion = validateExpansion;\n  exports.findExpansion = findExpansion;\n  var SPACE = _contentKitEditorUtilsKeycodes['default'].SPACE;\n\n  function replaceWithListSection(editor, listTagName) {\n    var section = editor.cursor.offsets.head.section;\n\n    var newSection = editor.run(function (postEditor) {\n      var builder = postEditor.builder;\n\n      var listItem = builder.createListItem();\n      var listSection = builder.createListSection(listTagName, [listItem]);\n\n      postEditor.replaceSection(section, listSection);\n      return listItem;\n    });\n\n    editor.cursor.moveToSection(newSection);\n  }\n\n  function replaceWithHeaderSection(editor, headingTagName) {\n    var section = editor.cursor.offsets.head.section;\n\n    var newSection = editor.run(function (postEditor) {\n      var builder = postEditor.builder;\n\n      var newSection = builder.createMarkupSection(headingTagName);\n      postEditor.replaceSection(section, newSection);\n      return newSection;\n    });\n\n    editor.cursor.moveToSection(newSection);\n  }\n\n  function validateExpansion(expansion) {\n    return !!expansion.trigger && !!expansion.text && !!expansion.run;\n  }\n\n  var DEFAULT_TEXT_EXPANSIONS = [{\n    trigger: SPACE,\n    text: '*',\n    run: function run(editor) {\n      replaceWithListSection(editor, 'ul');\n    }\n  }, {\n    trigger: SPACE,\n    text: '1',\n    run: function run(editor) {\n      replaceWithListSection(editor, 'ol');\n    }\n  }, {\n    trigger: SPACE,\n    text: '1.',\n    run: function run(editor) {\n      replaceWithListSection(editor, 'ol');\n    }\n  }, {\n    trigger: SPACE,\n    text: '##',\n    run: function run(editor) {\n      replaceWithHeaderSection(editor, 'h2');\n    }\n  }, {\n    trigger: SPACE,\n    text: '###',\n    run: function run(editor) {\n      replaceWithHeaderSection(editor, 'h3');\n    }\n  }];\n\n  exports.DEFAULT_TEXT_EXPANSIONS = DEFAULT_TEXT_EXPANSIONS;\n\n  function findExpansion(expansions, keyEvent, editor) {\n    var key = _contentKitEditorUtilsKey['default'].fromEvent(keyEvent);\n    if (!key.isPrintable()) {\n      return;\n    }\n\n    var _editor$cursor$offsets$head = editor.cursor.offsets.head;\n    var section = _editor$cursor$offsets$head.section;\n    var offset = _editor$cursor$offsets$head.offset;\n\n    if (section.type !== _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE) {\n      return;\n    }\n\n    // FIXME this is potentially expensive to calculate and might be better\n    // perf to first find expansions matching the trigger and only if matches\n    // are found then calculating the _text\n    var _text = section.textUntil(offset);\n    return (0, _contentKitEditorUtilsArrayUtils.detect)(expansions, function (_ref) {\n      var trigger = _ref.trigger;\n      var text = _ref.text;\n      return key.keyCode === trigger && _text === text;\n    });\n  }\n});","define('content-kit-editor', ['exports', 'content-kit-editor/editor/editor', 'content-kit-editor/commands/bold', 'content-kit-editor/cards/image'], function (exports, _contentKitEditorEditorEditor, _contentKitEditorCommandsBold, _contentKitEditorCardsImage) {\n  'use strict';\n\n  exports.registerGlobal = registerGlobal;\n\n  var ContentKit = {\n    Editor: _contentKitEditorEditorEditor['default'],\n    ImageCard: _contentKitEditorCardsImage['default'],\n    BoldCommand: _contentKitEditorCommandsBold['default']\n  };\n\n  function registerGlobal(global) {\n    global.ContentKit = ContentKit;\n  }\n\n  exports.Editor = _contentKitEditorEditorEditor['default'];\n  exports['default'] = ContentKit;\n});","define('content-kit-editor/models/_markerable', ['exports', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/set', 'content-kit-editor/utils/linked-list', 'content-kit-editor/models/_section'], function (exports, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsSet, _contentKitEditorUtilsLinkedList, _contentKitEditorModels_section) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var Markerable = (function (_Section) {\n    _inherits(Markerable, _Section);\n\n    function Markerable(type, tagName) {\n      var _this = this;\n\n      var markers = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n      _classCallCheck(this, Markerable);\n\n      _get(Object.getPrototypeOf(Markerable.prototype), 'constructor', this).call(this, type);\n      this.tagName = tagName;\n      this.markers = new _contentKitEditorUtilsLinkedList['default']({\n        adoptItem: function adoptItem(m) {\n          return m.section = m.parent = _this;\n        },\n        freeItem: function freeItem(m) {\n          return m.section = m.parent = null;\n        }\n      });\n\n      markers.forEach(function (m) {\n        return _this.markers.append(m);\n      });\n    }\n\n    _createClass(Markerable, [{\n      key: 'offsetOfMarker',\n\n      /**\n       * @param {Marker}\n       * @param {Number} markerOffset The offset relative to the start of the marker\n       *\n       * @return {Number} The offset relative to the start of this section\n       */\n      value: function offsetOfMarker(marker, markerOffset) {\n        if (marker.section !== this) {\n          throw new Error('Cannot get offsetOfMarker for marker that is not child of this');\n        }\n        // FIXME it is possible, when we get a cursor position before having finished reparsing,\n        // for markerOffset to be > marker.length. We shouldn't rely on this functionality.\n\n        var offset = 0;\n        var currentMarker = this.markers.head;\n        while (currentMarker && currentMarker !== marker.next) {\n          var _length = currentMarker === marker ? markerOffset : currentMarker.length;\n          offset += _length;\n          currentMarker = currentMarker.next;\n        }\n\n        return offset;\n      }\n\n      /**\n       * Splits the marker at the offset, filters empty markers from the result,\n       * and replaces this marker with the new non-empty ones\n       * @param {Marker} marker the marker to split\n       * @return {Array} the new markers that replaced `marker`\n       */\n    }, {\n      key: 'splitMarker',\n      value: function splitMarker(marker, offset) {\n        var endOffset = arguments.length <= 2 || arguments[2] === undefined ? marker.length : arguments[2];\n        return (function () {\n          var newMarkers = (0, _contentKitEditorUtilsArrayUtils.filter)(marker.split(offset, endOffset), function (m) {\n            return !m.isEmpty;\n          });\n          this.markers.splice(marker, 1, newMarkers);\n          return newMarkers;\n        }).apply(this, arguments);\n      }\n\n      // puts clones of this.markers into beforeSection and afterSection,\n      // all markers before the marker/offset split go in beforeSection, and all\n      // after the marker/offset split go in afterSection\n      // @return {Array} [beforeSection, afterSection], two new sections\n    }, {\n      key: '_redistributeMarkers',\n      value: function _redistributeMarkers(beforeSection, afterSection, marker) {\n        var offset = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n\n        var currentSection = beforeSection;\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(this.markers, function (m) {\n          if (m === marker) {\n            var _marker$split = marker.split(offset);\n\n            var _marker$split2 = _toArray(_marker$split);\n\n            var beforeMarker = _marker$split2[0];\n\n            var afterMarkers = _marker$split2.slice(1);\n\n            beforeSection.markers.append(beforeMarker);\n            (0, _contentKitEditorUtilsArrayUtils.forEach)(afterMarkers, function (_m) {\n              return afterSection.markers.append(_m);\n            });\n            currentSection = afterSection;\n          } else {\n            currentSection.markers.append(m.clone());\n          }\n        });\n\n        return [beforeSection, afterSection];\n      }\n    }, {\n      key: 'splitAtMarker',\n      value: function splitAtMarker() /*marker, offset=0*/{\n        throw new Error('splitAtMarker must be implemented by sub-class');\n      }\n    }, {\n      key: 'splitAtPosition',\n      value: function splitAtPosition(position) {\n        var marker = position.marker;\n        var offsetInMarker = position.offsetInMarker;\n\n        return this.splitAtMarker(marker, offsetInMarker);\n      }\n    }, {\n      key: 'markerPositionAtOffset',\n      value: function markerPositionAtOffset(offset) {\n        var currentOffset = 0;\n        var currentMarker = undefined;\n        var remaining = offset;\n        this.markers.detect(function (marker) {\n          currentOffset = Math.min(remaining, marker.length);\n          remaining -= currentOffset;\n          if (remaining === 0) {\n            currentMarker = marker;\n            return true; // break out of detect\n          }\n        });\n\n        return { marker: currentMarker, offset: currentOffset };\n      }\n    }, {\n      key: 'textUntil',\n      value: function textUntil(offset) {\n        return this.text.slice(0, offset);\n      }\n    }, {\n      key: 'markersFor',\n\n      /**\n       * @return {Array} New markers that match the boundaries of the\n       * range.\n       */\n      value: function markersFor(headOffset, tailOffset) {\n        var range = { head: { section: this, offset: headOffset },\n          tail: { section: this, offset: tailOffset } };\n\n        var markers = [];\n        this._markersInRange(range, function (marker, _ref) {\n          var markerHead = _ref.markerHead;\n          var markerTail = _ref.markerTail;\n\n          var cloned = marker.clone();\n          cloned.value = marker.value.slice(markerHead, markerTail);\n          markers.push(cloned);\n        });\n        return markers;\n      }\n    }, {\n      key: 'markupsInRange',\n      value: function markupsInRange(range) {\n        var markups = new _contentKitEditorUtilsSet['default']();\n        this._markersInRange(range, function (marker) {\n          marker.markups.forEach(function (m) {\n            return markups.add(m);\n          });\n        });\n        return markups.toArray();\n      }\n\n      // calls the callback with (marker, {markerHead, markerTail, isContained})\n      // for each marker that is wholly or partially contained in the range.\n    }, {\n      key: '_markersInRange',\n      value: function _markersInRange(range, callback) {\n        var head = range.head;\n        var tail = range.tail;\n\n        if (head.section !== this || tail.section !== this) {\n          throw new Error('Cannot call #_markersInRange if range expands beyond this');\n        }\n        var headOffset = head.offset;var tailOffset = tail.offset;\n\n        var currentHead = 0,\n            currentTail = 0,\n            currentMarker = this.markers.head;\n\n        while (currentMarker) {\n          currentTail += currentMarker.length;\n\n          if (currentTail > headOffset && currentHead < tailOffset) {\n            var markerHead = Math.max(headOffset - currentHead, 0);\n            var markerTail = currentMarker.length - Math.max(currentTail - tailOffset, 0);\n            var isContained = markerHead === 0 && markerTail === currentMarker.length;\n\n            callback(currentMarker, { markerHead: markerHead, markerTail: markerTail, isContained: isContained });\n          }\n\n          currentHead += currentMarker.length;\n          currentMarker = currentMarker.next;\n\n          if (currentHead > tailOffset) {\n            break;\n          }\n        }\n      }\n\n      // mutates this by appending the other section's (cloned) markers to it\n    }, {\n      key: 'join',\n      value: function join(otherSection) {\n        var _this2 = this;\n\n        var beforeMarker = this.markers.tail;\n        var afterMarker = null;\n\n        otherSection.markers.forEach(function (m) {\n          if (!m.isEmpty) {\n            m = m.clone();\n            _this2.markers.append(m);\n            if (!afterMarker) {\n              afterMarker = m;\n            }\n          }\n        });\n\n        return { beforeMarker: beforeMarker, afterMarker: afterMarker };\n      }\n    }, {\n      key: 'isBlank',\n      get: function get() {\n        if (!this.markers.length) {\n          return true;\n        }\n        var markerWithLength = this.markers.detect(function (marker) {\n          return !!marker.length;\n        });\n        return !markerWithLength;\n      }\n    }, {\n      key: 'text',\n      get: function get() {\n        return (0, _contentKitEditorUtilsArrayUtils.reduce)(this.markers, function (prev, m) {\n          return prev + m.value;\n        }, '');\n      }\n    }, {\n      key: 'length',\n      get: function get() {\n        return this.text.length;\n      }\n    }]);\n\n    return Markerable;\n  })(_contentKitEditorModels_section['default']);\n\n  exports['default'] = Markerable;\n});","define('content-kit-editor/models/_section', ['exports', 'content-kit-editor/models/types', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/linked-item'], function (exports, _contentKitEditorModelsTypes, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsLinkedItem) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  function isMarkerable(section) {\n    return !!section.markers;\n  }\n\n  function getParentSection(section) {\n    return section.parent;\n  }\n\n  function hasSubsections(section) {\n    return !!section.sections;\n  }\n\n  function isSubsection(section) {\n    return section.type === _contentKitEditorModelsTypes.LIST_ITEM_TYPE;\n  }\n\n  function firstMarkerableChild(section) {\n    return section.items.head;\n  }\n\n  function lastMarkerableChild(section) {\n    return section.items.tail;\n  }\n\n  var Section = (function (_LinkedItem) {\n    _inherits(Section, _LinkedItem);\n\n    function Section(type) {\n      _classCallCheck(this, Section);\n\n      _get(Object.getPrototypeOf(Section.prototype), 'constructor', this).call(this);\n      if (!type) {\n        throw new Error('Cannot create section without type');\n      }\n      this.type = type;\n    }\n\n    _createClass(Section, [{\n      key: 'immediatelyNextMarkerableSection',\n      value: function immediatelyNextMarkerableSection() {\n        var next = this.next;\n        if (next) {\n          if (isMarkerable(next)) {\n            return next;\n          } else if (hasSubsections(next)) {\n            var firstChild = firstMarkerableChild(next);\n            return firstChild;\n          }\n        } else if (isSubsection(this)) {\n          var parentSection = getParentSection(this);\n          return parentSection.immediatelyNextMarkerableSection();\n        }\n      }\n    }, {\n      key: 'immediatelyPreviousMarkerableSection',\n      value: function immediatelyPreviousMarkerableSection() {\n        var prev = this.prev;\n        if (!prev) {\n          return null;\n        }\n        if (isMarkerable(prev)) {\n          return prev;\n        } else if (hasSubsections(prev)) {\n          var lastChild = lastMarkerableChild(prev);\n          return lastChild;\n        }\n      }\n    }, {\n      key: 'tagName',\n      set: function set(val) {\n        this._tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(val);\n      },\n      get: function get() {\n        return this._tagName;\n      }\n    }]);\n\n    return Section;\n  })(_contentKitEditorUtilsLinkedItem['default']);\n\n  exports['default'] = Section;\n});","define('content-kit-editor/models/card-node', ['exports'], function (exports) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var CardNode = (function () {\n    function CardNode(editor, card, section, element, cardOptions) {\n      _classCallCheck(this, CardNode);\n\n      this.editor = editor;\n      this.card = card;\n      this.section = section;\n      this.cardOptions = cardOptions;\n      this.element = element;\n\n      this.mode = null;\n      this.setupResult = null;\n    }\n\n    _createClass(CardNode, [{\n      key: 'render',\n      value: function render(mode) {\n        if (this.mode === mode) {\n          return;\n        }\n\n        this.teardown();\n\n        this.mode = mode;\n        this.setupResult = this.card[mode].setup(this.element, this.cardOptions, this.env, this.section.payload);\n      }\n    }, {\n      key: 'display',\n      value: function display() {\n        this.render('display');\n      }\n    }, {\n      key: 'edit',\n      value: function edit() {\n        this.render('edit');\n      }\n    }, {\n      key: 'remove',\n      value: function remove() {\n        var _this = this;\n\n        this.editor.run(function (postEditor) {\n          return postEditor.removeSection(_this.section);\n        });\n      }\n    }, {\n      key: 'teardown',\n      value: function teardown() {\n        if (this.mode) {\n          if (this.card[this.mode].teardown) {\n            this.card[this.mode].teardown(this.setupResult);\n          }\n        }\n      }\n    }, {\n      key: 'env',\n      get: function get() {\n        var _this2 = this;\n\n        return {\n          name: this.card.name,\n          edit: function edit() {\n            return _this2.edit();\n          },\n          save: function save(payload) {\n            _this2.section.payload = payload;\n\n            _this2.editor.didUpdate();\n            _this2.display();\n          },\n          cancel: function cancel() {\n            return _this2.display();\n          },\n          remove: function remove() {\n            return _this2.remove();\n          }\n        };\n      }\n    }]);\n\n    return CardNode;\n  })();\n\n  exports['default'] = CardNode;\n});","define('content-kit-editor/models/card', ['exports', 'content-kit-editor/models/_section', 'content-kit-editor/models/types'], function (exports, _contentKitEditorModels_section, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var Card = (function (_Section) {\n    _inherits(Card, _Section);\n\n    function Card(name, payload) {\n      _classCallCheck(this, Card);\n\n      _get(Object.getPrototypeOf(Card.prototype), 'constructor', this).call(this, _contentKitEditorModelsTypes.CARD_TYPE);\n      this.name = name;\n      this.payload = payload;\n    }\n\n    return Card;\n  })(_contentKitEditorModels_section['default']);\n\n  exports['default'] = Card;\n});","define('content-kit-editor/models/image', ['exports', 'content-kit-editor/models/types', 'content-kit-editor/models/_section'], function (exports, _contentKitEditorModelsTypes, _contentKitEditorModels_section) {\n  'use strict';\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var Image = (function (_Section) {\n    _inherits(Image, _Section);\n\n    function Image() {\n      _classCallCheck(this, Image);\n\n      _get(Object.getPrototypeOf(Image.prototype), 'constructor', this).call(this, _contentKitEditorModelsTypes.IMAGE_SECTION_TYPE);\n      this.src = null;\n    }\n\n    return Image;\n  })(_contentKitEditorModels_section['default']);\n\n  exports['default'] = Image;\n});","define('content-kit-editor/models/list-item', ['exports', 'content-kit-editor/models/_markerable', 'content-kit-editor/models/types'], function (exports, _contentKitEditorModels_markerable, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ListItem = (function (_Markerable) {\n    _inherits(ListItem, _Markerable);\n\n    function ListItem(tagName) {\n      var markers = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, ListItem);\n\n      _get(Object.getPrototypeOf(ListItem.prototype), 'constructor', this).call(this, _contentKitEditorModelsTypes.LIST_ITEM_TYPE, tagName, markers);\n    }\n\n    _createClass(ListItem, [{\n      key: 'splitAtMarker',\n      value: function splitAtMarker(marker) {\n        var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n        // FIXME need to check if we are going to split into two list items\n        // or a list item and a new markup section:\n        var isLastItem = !this.next;\n        var createNewSection = !marker && offset === 0 && isLastItem;\n\n        var beforeSection = this.builder.createListItem();\n        var afterSection = createNewSection ? this.builder.createMarkupSection() : this.builder.createListItem();\n\n        return this._redistributeMarkers(beforeSection, afterSection, marker, offset);\n      }\n    }, {\n      key: 'splitIntoSections',\n      value: function splitIntoSections() {\n        return this.parent.splitAtListItem(this);\n      }\n    }, {\n      key: 'clone',\n      value: function clone() {\n        var item = this.builder.createListItem();\n        this.markers.forEach(function (m) {\n          return item.markers.append(m.clone());\n        });\n        return item;\n      }\n    }]);\n\n    return ListItem;\n  })(_contentKitEditorModels_markerable['default']);\n\n  exports['default'] = ListItem;\n});","define('content-kit-editor/models/list-section', ['exports', 'content-kit-editor/utils/linked-list', 'content-kit-editor/models/types', 'content-kit-editor/models/_section'], function (exports, _contentKitEditorUtilsLinkedList, _contentKitEditorModelsTypes, _contentKitEditorModels_section) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var DEFAULT_TAG_NAME = 'ul';\n\n  exports.DEFAULT_TAG_NAME = DEFAULT_TAG_NAME;\n\n  var ListSection = (function (_Section) {\n    _inherits(ListSection, _Section);\n\n    function ListSection() {\n      var _this = this;\n\n      var tagName = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_TAG_NAME : arguments[0];\n      var items = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, ListSection);\n\n      _get(Object.getPrototypeOf(ListSection.prototype), 'constructor', this).call(this, _contentKitEditorModelsTypes.LIST_SECTION_TYPE);\n\n      this.tagName = tagName;\n\n      this.items = new _contentKitEditorUtilsLinkedList['default']({\n        adoptItem: function adoptItem(i) {\n          return i.section = i.parent = _this;\n        },\n        freeItem: function freeItem(i) {\n          return i.section = i.parent = null;\n        }\n      });\n      this.sections = this.items;\n\n      items.forEach(function (i) {\n        return _this.items.append(i);\n      });\n    }\n\n    _createClass(ListSection, [{\n      key: 'splitAtListItem',\n\n      // returns [prevListSection, newMarkupSection, nextListSection]\n      // prevListSection and nextListSection may be undefined\n      value: function splitAtListItem(listItem) {\n        if (listItem.parent !== this) {\n          throw new Error('Cannot split list section at item that is not a child');\n        }\n        var prevItem = listItem.prev,\n            nextItem = listItem.next;\n        var listSection = this;\n\n        var prevListSection = undefined,\n            nextListSection = undefined,\n            newSection = undefined;\n\n        newSection = this.builder.createMarkupSection('p');\n        listItem.markers.forEach(function (m) {\n          return newSection.markers.append(m.clone());\n        });\n\n        // If there were previous list items, add them to a new list section `prevListSection`\n        if (prevItem) {\n          prevListSection = this.builder.createListSection(this.tagName);\n          var currentItem = listSection.items.head;\n          while (currentItem !== listItem) {\n            prevListSection.items.append(currentItem.clone());\n            currentItem = currentItem.next;\n          }\n        }\n\n        // if there is a next item, add it and all after it to the `nextListSection`\n        if (nextItem) {\n          nextListSection = this.builder.createListSection(this.tagName);\n          var currentItem = nextItem;\n          while (currentItem) {\n            nextListSection.items.append(currentItem.clone());\n            currentItem = currentItem.next;\n          }\n        }\n\n        return [prevListSection, newSection, nextListSection];\n      }\n    }, {\n      key: 'isBlank',\n      get: function get() {\n        return this.items.isEmpty;\n      }\n    }]);\n\n    return ListSection;\n  })(_contentKitEditorModels_section['default']);\n\n  exports['default'] = ListSection;\n});","define('content-kit-editor/models/marker', ['exports', 'content-kit-editor/models/types', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/linked-item'], function (exports, _contentKitEditorModelsTypes, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsLinkedItem) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var Marker = (function (_LinkedItem) {\n    _inherits(Marker, _LinkedItem);\n\n    function Marker() {\n      var _this = this;\n\n      var value = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n      var markups = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, Marker);\n\n      _get(Object.getPrototypeOf(Marker.prototype), 'constructor', this).call(this);\n      this.value = value;\n      this.markups = [];\n      this.type = _contentKitEditorModelsTypes.MARKER_TYPE;\n      markups.forEach(function (m) {\n        return _this.addMarkup(m);\n      });\n    }\n\n    _createClass(Marker, [{\n      key: 'clone',\n      value: function clone() {\n        var clonedMarkups = this.markups.slice();\n        return this.builder.createMarker(this.value, clonedMarkups);\n      }\n    }, {\n      key: 'truncateFrom',\n      value: function truncateFrom(offset) {\n        this.value = this.value.substr(0, offset);\n      }\n    }, {\n      key: 'truncateTo',\n      value: function truncateTo(offset) {\n        this.value = this.value.substr(offset);\n      }\n    }, {\n      key: 'clearMarkups',\n      value: function clearMarkups() {\n        this.markups = [];\n      }\n    }, {\n      key: 'addMarkup',\n      value: function addMarkup(markup) {\n        this.markups.push(markup);\n      }\n    }, {\n      key: 'removeMarkup',\n      value: function removeMarkup(markupOrMarkupCallback) {\n        var _this2 = this;\n\n        var callback = undefined;\n        if (typeof markupOrMarkupCallback === 'function') {\n          callback = markupOrMarkupCallback;\n        } else {\n          (function () {\n            var markup = markupOrMarkupCallback;\n            callback = function (_markup) {\n              return _markup === markup;\n            };\n          })();\n        }\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)((0, _contentKitEditorUtilsArrayUtils.filter)(this.markups, callback), function (m) {\n          return _this2._removeMarkup(m);\n        });\n      }\n    }, {\n      key: '_removeMarkup',\n      value: function _removeMarkup(markup) {\n        var index = this.markups.indexOf(markup);\n        if (index !== -1) {\n          this.markups.splice(index, 1);\n        }\n      }\n\n      // delete the character at this offset,\n      // update the value with the new value\n    }, {\n      key: 'deleteValueAtOffset',\n      value: function deleteValueAtOffset(offset) {\n        if (offset < 0 || offset > this.length) {\n          throw new Error('Invalid offset \"' + offset + '\"');\n        }\n        var left = this.value.slice(0, offset);\n        var right = this.value.slice(offset + 1);\n\n        this.value = left + right;\n      }\n    }, {\n      key: 'hasMarkup',\n      value: function hasMarkup(tagNameOrMarkup) {\n        return !!this.getMarkup(tagNameOrMarkup);\n      }\n    }, {\n      key: 'getMarkup',\n      value: function getMarkup(tagNameOrMarkup) {\n        var _this3 = this;\n\n        if (typeof tagNameOrMarkup === 'string') {\n          var _ret2 = (function () {\n            var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagNameOrMarkup);\n            return {\n              v: (0, _contentKitEditorUtilsArrayUtils.detect)(_this3.markups, function (markup) {\n                return markup.tagName === tagName;\n              })\n            };\n          })();\n\n          if (typeof _ret2 === 'object') return _ret2.v;\n        } else {\n          var _ret3 = (function () {\n            var targetMarkup = tagNameOrMarkup;\n            return {\n              v: (0, _contentKitEditorUtilsArrayUtils.detect)(_this3.markups, function (markup) {\n                return markup === targetMarkup;\n              })\n            };\n          })();\n\n          if (typeof _ret3 === 'object') return _ret3.v;\n        }\n      }\n    }, {\n      key: 'join',\n      value: function join(other) {\n        var joined = this.builder.createMarker(this.value + other.value);\n        this.markups.forEach(function (m) {\n          return joined.addMarkup(m);\n        });\n        other.markups.forEach(function (m) {\n          return joined.addMarkup(m);\n        });\n\n        return joined;\n      }\n    }, {\n      key: 'split',\n      value: function split() {\n        var offset = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n        var endOffset = arguments.length <= 1 || arguments[1] === undefined ? this.length : arguments[1];\n\n        var markers = [];\n\n        markers = [this.builder.createMarker(this.value.substring(0, offset)), this.builder.createMarker(this.value.substring(offset, endOffset)), this.builder.createMarker(this.value.substring(endOffset))];\n\n        this.markups.forEach(function (mu) {\n          return markers.forEach(function (m) {\n            return m.addMarkup(mu);\n          });\n        });\n        return markers;\n      }\n    }, {\n      key: 'isEmpty',\n      get: function get() {\n        return this.length === 0;\n      }\n    }, {\n      key: 'length',\n      get: function get() {\n        return this.value.length;\n      }\n    }, {\n      key: 'openedMarkups',\n      get: function get() {\n        var count = 0;\n        if (this.prev) {\n          count = (0, _contentKitEditorUtilsArrayUtils.commonItemLength)(this.markups, this.prev.markups);\n        }\n\n        return this.markups.slice(count);\n      }\n    }, {\n      key: 'closedMarkups',\n      get: function get() {\n        var count = 0;\n        if (this.next) {\n          count = (0, _contentKitEditorUtilsArrayUtils.commonItemLength)(this.markups, this.next.markups);\n        }\n\n        return this.markups.slice(count);\n      }\n    }]);\n\n    return Marker;\n  })(_contentKitEditorUtilsLinkedItem['default']);\n\n  exports['default'] = Marker;\n});","define('content-kit-editor/models/markup-section', ['exports', 'content-kit-editor/models/_markerable', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/models/types'], function (exports, _contentKitEditorModels_markerable, _contentKitEditorUtilsDomUtils, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var VALID_MARKUP_SECTION_TAGNAMES = ['p', 'h3', 'h2', 'h1', 'blockquote', 'ul', 'ol'].map(_contentKitEditorUtilsDomUtils.normalizeTagName);\n  exports.VALID_MARKUP_SECTION_TAGNAMES = VALID_MARKUP_SECTION_TAGNAMES;\n  var DEFAULT_TAG_NAME = VALID_MARKUP_SECTION_TAGNAMES[0];\n\n  exports.DEFAULT_TAG_NAME = DEFAULT_TAG_NAME;\n  var MarkupSection = (function (_Markerable) {\n    _inherits(MarkupSection, _Markerable);\n\n    function MarkupSection() {\n      var tagName = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_TAG_NAME : arguments[0];\n      var markers = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, MarkupSection);\n\n      _get(Object.getPrototypeOf(MarkupSection.prototype), 'constructor', this).call(this, _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE, tagName, markers);\n    }\n\n    _createClass(MarkupSection, [{\n      key: 'setTagName',\n      value: function setTagName(newTagName) {\n        newTagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(newTagName);\n        if (VALID_MARKUP_SECTION_TAGNAMES.indexOf(newTagName) === -1) {\n          throw new Error('Cannot change section tagName to \"' + newTagName);\n        }\n        this.tagName = newTagName;\n      }\n    }, {\n      key: 'resetTagName',\n      value: function resetTagName() {\n        this.tagName = DEFAULT_TAG_NAME;\n      }\n    }, {\n      key: 'splitAtMarker',\n      value: function splitAtMarker(marker) {\n        var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var beforeSection = this.builder.createMarkupSection(this.tagName, []);\n        var afterSection = this.builder.createMarkupSection();\n\n        return this._redistributeMarkers(beforeSection, afterSection, marker, offset);\n      }\n    }]);\n\n    return MarkupSection;\n  })(_contentKitEditorModels_markerable['default']);\n\n  exports['default'] = MarkupSection;\n});","define('content-kit-editor/models/markup', ['exports', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/models/types'], function (exports, _contentKitEditorUtilsDomUtils, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var VALID_MARKUP_TAGNAMES = ['b', 'i', 'strong', 'em', 'a', 'li'].map(_contentKitEditorUtilsDomUtils.normalizeTagName);\n\n  exports.VALID_MARKUP_TAGNAMES = VALID_MARKUP_TAGNAMES;\n\n  var Markup = (function () {\n    /*\n     * @param {attributes} array flat array of key1,value1,key2,value2,...\n     */\n\n    function Markup(tagName) {\n      var attributes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n      _classCallCheck(this, Markup);\n\n      this.tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n      this.attributes = attributes;\n      this.type = _contentKitEditorModelsTypes.MARKUP_TYPE;\n\n      if (VALID_MARKUP_TAGNAMES.indexOf(this.tagName) === -1) {\n        throw new Error('Cannot create markup of tagName ' + tagName);\n      }\n    }\n\n    _createClass(Markup, [{\n      key: 'hasTag',\n      value: function hasTag(tagName) {\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        return this.tagName === tagName;\n      }\n    }], [{\n      key: 'isValidElement',\n      value: function isValidElement(element) {\n        var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n        return VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1;\n      }\n    }]);\n\n    return Markup;\n  })();\n\n  exports['default'] = Markup;\n});","define('content-kit-editor/models/post-node-builder', ['exports', 'content-kit-editor/models/post', 'content-kit-editor/models/markup-section', 'content-kit-editor/models/list-section', 'content-kit-editor/models/list-item', 'content-kit-editor/models/image', 'content-kit-editor/models/marker', 'content-kit-editor/models/markup', 'content-kit-editor/models/card', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorModelsPost, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsListSection, _contentKitEditorModelsListItem, _contentKitEditorModelsImage, _contentKitEditorModelsMarker, _contentKitEditorModelsMarkup, _contentKitEditorModelsCard, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var PostNodeBuilder = (function () {\n    function PostNodeBuilder() {\n      _classCallCheck(this, PostNodeBuilder);\n\n      this.markupCache = {};\n    }\n\n    _createClass(PostNodeBuilder, [{\n      key: 'createPost',\n      value: function createPost() {\n        var sections = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        var post = new _contentKitEditorModelsPost['default']();\n        post.builder = this;\n\n        sections.forEach(function (s) {\n          return post.sections.append(s);\n        });\n\n        return post;\n      }\n    }, {\n      key: 'createBlankPost',\n      value: function createBlankPost() {\n        return this.createPost([this.createMarkupSection()]);\n      }\n    }, {\n      key: 'createMarkupSection',\n      value: function createMarkupSection() {\n        var tagName = arguments.length <= 0 || arguments[0] === undefined ? _contentKitEditorModelsMarkupSection.DEFAULT_TAG_NAME : arguments[0];\n        var markers = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n        var isGenerated = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        var section = new _contentKitEditorModelsMarkupSection['default'](tagName, markers);\n        if (isGenerated) {\n          section.isGenerated = true;\n        }\n        section.builder = this;\n        return section;\n      }\n    }, {\n      key: 'createListSection',\n      value: function createListSection() {\n        var tagName = arguments.length <= 0 || arguments[0] === undefined ? _contentKitEditorModelsListSection.DEFAULT_TAG_NAME : arguments[0];\n        var items = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        var section = new _contentKitEditorModelsListSection['default'](tagName, items);\n        section.builder = this;\n        return section;\n      }\n    }, {\n      key: 'createListItem',\n      value: function createListItem() {\n        var markers = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)('li');\n        var item = new _contentKitEditorModelsListItem['default'](tagName, markers);\n        item.builder = this;\n        return item;\n      }\n    }, {\n      key: 'createImageSection',\n      value: function createImageSection(url) {\n        var section = new _contentKitEditorModelsImage['default']();\n        if (url) {\n          section.src = url;\n        }\n        return section;\n      }\n    }, {\n      key: 'createCardSection',\n      value: function createCardSection(name) {\n        var payload = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n        return new _contentKitEditorModelsCard['default'](name, payload);\n      }\n    }, {\n      key: 'createMarker',\n      value: function createMarker(value) {\n        var markups = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        var marker = new _contentKitEditorModelsMarker['default'](value, markups);\n        marker.builder = this;\n        return marker;\n      }\n\n      // Attributes is an array of [key1, value1, key2, value2, ...]\n    }, {\n      key: 'createMarkup',\n      value: function createMarkup(tagName) {\n        var attributes = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n\n        var markup = undefined;\n\n        if (attributes.length) {\n          // FIXME: This could also be cached\n          markup = new _contentKitEditorModelsMarkup['default'](tagName, attributes);\n        } else {\n          markup = this.markupCache[tagName];\n\n          if (!markup) {\n            markup = new _contentKitEditorModelsMarkup['default'](tagName, attributes);\n            this.markupCache[tagName] = markup;\n          }\n        }\n\n        markup.builder = this;\n        return markup;\n      }\n    }]);\n\n    return PostNodeBuilder;\n  })();\n\n  exports['default'] = PostNodeBuilder;\n});","define('content-kit-editor/models/post', ['exports', 'content-kit-editor/models/types', 'content-kit-editor/utils/linked-list', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/set'], function (exports, _contentKitEditorModelsTypes, _contentKitEditorUtilsLinkedList, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsSet) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var Post = (function () {\n    function Post() {\n      var _this = this;\n\n      _classCallCheck(this, Post);\n\n      this.type = _contentKitEditorModelsTypes.POST_TYPE;\n      this.sections = new _contentKitEditorUtilsLinkedList['default']({\n        adoptItem: function adoptItem(s) {\n          return s.post = s.parent = _this;\n        },\n        freeItem: function freeItem(s) {\n          return s.post = s.parent = null;\n        }\n      });\n    }\n\n    _createClass(Post, [{\n      key: 'markersContainedByRange',\n\n      /**\n       * @param {Range} range\n       * @return {Array} markers that are completely contained by the range\n       */\n      value: function markersContainedByRange(range) {\n        var markers = [];\n\n        this.walkMarkerableSections(range, function (section) {\n          section._markersInRange(range.trimTo(section), function (m, _ref) {\n            var isContained = _ref.isContained;\n            if (isContained) {\n              markers.push(m);\n            }\n          });\n        });\n\n        return markers;\n      }\n    }, {\n      key: 'cutMarkers',\n      value: function cutMarkers(markers) {\n        var firstSection = markers.length && markers[0].section,\n            lastSection = markers.length && markers[markers.length - 1].section;\n\n        var currentSection = firstSection;\n        var removedSections = [],\n            changedSections = (0, _contentKitEditorUtilsArrayUtils.compact)([firstSection, lastSection]);\n\n        if (markers.length !== 0) {\n          markers.forEach(function (marker) {\n            if (marker.section !== currentSection) {\n              // this marker is in a section we haven't seen yet\n              if (marker.section !== firstSection && marker.section !== lastSection) {\n                // section is wholly contained by markers, and can be removed\n                removedSections.push(marker.section);\n              }\n            }\n\n            currentSection = marker.section;\n            currentSection.markers.remove(marker);\n          });\n\n          if (firstSection !== lastSection) {\n            firstSection.join(lastSection);\n            removedSections.push(lastSection);\n          }\n        }\n\n        return { changedSections: changedSections, removedSections: removedSections };\n      }\n\n      /**\n       * Invoke `callbackFn` for all markers between the headMarker and tailMarker (inclusive),\n       * across sections\n       */\n    }, {\n      key: 'markersFrom',\n      value: function markersFrom(headMarker, tailMarker, callbackFn) {\n        var currentMarker = headMarker;\n        while (currentMarker) {\n          callbackFn(currentMarker);\n\n          if (currentMarker === tailMarker) {\n            currentMarker = null;\n          } else if (currentMarker.next) {\n            currentMarker = currentMarker.next;\n          } else {\n            var nextSection = this._nextMarkerableSection(currentMarker.section);\n            // FIXME: This will fail across cards\n            currentMarker = nextSection && nextSection.markers.head;\n          }\n        }\n      }\n    }, {\n      key: 'markupsInRange',\n      value: function markupsInRange(range) {\n        var markups = new _contentKitEditorUtilsSet['default']();\n\n        this.walkMarkerableSections(range, function (section) {\n          (0, _contentKitEditorUtilsArrayUtils.forEach)(section.markupsInRange(range.trimTo(section)), function (m) {\n            return markups.add(m);\n          });\n        });\n\n        return markups.toArray();\n      }\n    }, {\n      key: 'walkMarkerableSections',\n      value: function walkMarkerableSections(range, callback) {\n        var head = range.head;\n        var tail = range.tail;\n\n        var currentSection = head.section;\n        while (currentSection) {\n          callback(currentSection);\n\n          if (currentSection === tail.section) {\n            break;\n          } else {\n            currentSection = this._nextMarkerableSection(currentSection);\n          }\n        }\n      }\n\n      // return an array of all top-level sections (direct children of `post`)\n      // that are wholly contained by the range.\n    }, {\n      key: 'sectionsContainedBy',\n      value: function sectionsContainedBy(range) {\n        var head = range.head;\n        var tail = range.tail;\n\n        var containedSections = [];\n\n        var findParent = function findParent(child, conditionFn) {\n          while (child) {\n            if (conditionFn(child)) {\n              return child;\n            }\n            child = child.parent;\n          }\n        };\n\n        var headTopLevelSection = findParent(head.section, function (s) {\n          return !!s.post;\n        });\n        var tailTopLevelSection = findParent(tail.section, function (s) {\n          return !!s.post;\n        });\n\n        var currentSection = headTopLevelSection.next;\n        while (currentSection && currentSection !== tailTopLevelSection) {\n          containedSections.push(currentSection);\n          currentSection = currentSection.next;\n        }\n\n        return containedSections;\n      }\n\n      // return the next section that has markers after this one\n    }, {\n      key: '_nextMarkerableSection',\n      value: function _nextMarkerableSection(section) {\n        if (!section) {\n          return null;\n        }\n        var isMarkerable = function isMarkerable(s) {\n          return !!s.markers;\n        };\n        var hasChildren = function hasChildren(s) {\n          return !!s.items;\n        };\n        var firstChild = function firstChild(s) {\n          return s.items.head;\n        };\n        var isChild = function isChild(s) {\n          return s.parent && !s.post;\n        };\n        var parent = function parent(s) {\n          return s.parent;\n        };\n\n        var next = section.next;\n        if (next) {\n          if (isMarkerable(next)) {\n            return next;\n          } else if (hasChildren(next)) {\n            // e.g. a ListSection\n            return firstChild(next);\n          } else {\n            // e.g. a cardSection that has no children or parent but\n            // may have a markerable after it in the AT\n            return this._nextMarkerableSection(next);\n          }\n        } else {\n          if (isChild(section)) {\n            // if there is no section after this, but this section is a child\n            // (e.g. a ListItem inside a ListSection), check for a markerable\n            // section after its parent\n            return this._nextMarkerableSection(parent(section));\n          }\n        }\n      }\n    }, {\n      key: 'isBlank',\n      get: function get() {\n        return this.sections.isEmpty;\n      }\n    }]);\n\n    return Post;\n  })();\n\n  exports['default'] = Post;\n});","define('content-kit-editor/models/render-node', ['exports', 'content-kit-editor/utils/linked-item', 'content-kit-editor/utils/linked-list', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsLinkedItem, _contentKitEditorUtilsLinkedList, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var RenderNode = (function (_LinkedItem) {\n    _inherits(RenderNode, _LinkedItem);\n\n    function RenderNode(postNode) {\n      _classCallCheck(this, RenderNode);\n\n      _get(Object.getPrototypeOf(RenderNode.prototype), 'constructor', this).call(this);\n      this.parent = null;\n      this.isDirty = true;\n      this.isRemoved = false;\n      this.postNode = postNode;\n      this._childNodes = null;\n      this.element = null;\n    }\n\n    _createClass(RenderNode, [{\n      key: 'isAttached',\n      value: function isAttached() {\n        var rootElement = this.renderTree.node.element;\n        if (!this.element) {\n          throw new Error('Cannot check if a renderNode is attached without an element.');\n        }\n        return (0, _contentKitEditorUtilsDomUtils.containsNode)(rootElement, this.element);\n      }\n    }, {\n      key: 'scheduleForRemoval',\n      value: function scheduleForRemoval() {\n        this.isRemoved = true;\n        if (this.parent) {\n          this.parent.markDirty();\n        }\n      }\n    }, {\n      key: 'markDirty',\n      value: function markDirty() {\n        this.isDirty = true;\n        if (this.parent) {\n          this.parent.markDirty();\n        }\n      }\n    }, {\n      key: 'markClean',\n      value: function markClean() {\n        this.isDirty = false;\n      }\n    }, {\n      key: 'childNodes',\n      get: function get() {\n        var _this = this;\n\n        if (!this._childNodes) {\n          this._childNodes = new _contentKitEditorUtilsLinkedList['default']({\n            adoptItem: function adoptItem(item) {\n              item.parent = _this;\n              item.renderTree = _this.renderTree;\n            },\n            freeItem: function freeItem(item) {\n              item.parent = null;\n              item.renderTree = null;\n            }\n          });\n        }\n        return this._childNodes;\n      }\n    }]);\n\n    return RenderNode;\n  })(_contentKitEditorUtilsLinkedItem['default']);\n\n  exports['default'] = RenderNode;\n});","define(\"content-kit-editor/models/render-tree\", [\"exports\", \"content-kit-editor/models/render-node\", \"content-kit-editor/utils/element-map\"], function (exports, _contentKitEditorModelsRenderNode, _contentKitEditorUtilsElementMap) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var RenderTree = (function () {\n    function RenderTree(node) {\n      _classCallCheck(this, RenderTree);\n\n      this.node = node;\n      this.elements = new _contentKitEditorUtilsElementMap[\"default\"]();\n    }\n\n    _createClass(RenderTree, [{\n      key: \"getElementRenderNode\",\n      value: function getElementRenderNode(element) {\n        return this.elements.get(element);\n      }\n    }, {\n      key: \"buildRenderNode\",\n      value: function buildRenderNode(section) {\n        var renderNode = new _contentKitEditorModelsRenderNode[\"default\"](section);\n        renderNode.renderTree = this;\n        section.renderNode = renderNode;\n        return renderNode;\n      }\n    }, {\n      key: \"rootElement\",\n      get: function get() {\n        return this.node.element;\n      }\n    }]);\n\n    return RenderTree;\n  })();\n\n  exports[\"default\"] = RenderTree;\n});","define('content-kit-editor/models/types', ['exports'], function (exports) {\n  'use strict';\n\n  var MARKUP_SECTION_TYPE = 'markup-section';\n  exports.MARKUP_SECTION_TYPE = MARKUP_SECTION_TYPE;\n  var LIST_SECTION_TYPE = 'list-section';\n  exports.LIST_SECTION_TYPE = LIST_SECTION_TYPE;\n  var MARKUP_TYPE = 'markup';\n  exports.MARKUP_TYPE = MARKUP_TYPE;\n  var MARKER_TYPE = 'marker';\n  exports.MARKER_TYPE = MARKER_TYPE;\n  var POST_TYPE = 'post';\n  exports.POST_TYPE = POST_TYPE;\n  var LIST_ITEM_TYPE = 'list-item';\n  exports.LIST_ITEM_TYPE = LIST_ITEM_TYPE;\n  var CARD_TYPE = 'card-section';\n  exports.CARD_TYPE = CARD_TYPE;\n  var IMAGE_SECTION_TYPE = 'image-section';\n  exports.IMAGE_SECTION_TYPE = IMAGE_SECTION_TYPE;\n});","define('content-kit-editor/parsers/dom', ['exports', 'content-kit-utils', 'content-kit-editor/models/markup-section', 'content-kit-editor/models/markup', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitUtils, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsMarkup, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var ELEMENT_NODE = 1;\n  var TEXT_NODE = 3;\n\n  var ALLOWED_ATTRIBUTES = ['href', 'rel', 'src'];\n\n  function isEmptyTextNode(node) {\n    return node.nodeType === TEXT_NODE && (0, _contentKitUtils.trim)(node.textContent) === '';\n  }\n\n  // FIXME we need sorted attributes for deterministic tests. This is not\n  // a particularly elegant method, since it loops at least 3 times.\n  function sortAttributes(attributes) {\n    var keyValueAttributes = [];\n    var currentKey = undefined;\n    attributes.forEach(function (keyOrValue, index) {\n      if (index % 2 === 0) {\n        currentKey = keyOrValue;\n      } else {\n        keyValueAttributes.push({ key: currentKey, value: keyOrValue });\n      }\n    });\n    keyValueAttributes.sort(function (a, b) {\n      return a.key === b.key ? 0 : a.key > b.key ? 1 : -1;\n    });\n    var sortedAttributes = [];\n    keyValueAttributes.forEach(function (_ref) {\n      var key = _ref.key;\n      var value = _ref.value;\n\n      sortedAttributes.push(key, value);\n    });\n    return sortedAttributes;\n  }\n\n  /**\n   * @return {array} attributes as key1,value1,key2,value2,etc\n   */\n  function readAttributes(node) {\n    var attributes = [];\n\n    if (node.hasAttributes()) {\n      var i, l;\n      for (i = 0, l = node.attributes.length; i < l; i++) {\n        if (ALLOWED_ATTRIBUTES.indexOf(node.attributes[i].name) !== -1) {\n          attributes.push(node.attributes[i].name);\n          attributes.push(node.attributes[i].value);\n        }\n      }\n    }\n\n    return sortAttributes(attributes);\n  }\n\n  function isValidMarkerElement(element) {\n    var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n    return _contentKitEditorModelsMarkup.VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1;\n  }\n\n  function parseMarkers(section, builder, topNode) {\n    var markups = [];\n    var text = null;\n    var currentNode = topNode;\n    while (currentNode) {\n      switch (currentNode.nodeType) {\n        case ELEMENT_NODE:\n          if (isValidMarkerElement(currentNode)) {\n            markups.push(builder.createMarkup(currentNode.tagName, readAttributes(currentNode)));\n          }\n          break;\n        case TEXT_NODE:\n          text = (text || '') + currentNode.textContent;\n          break;\n      }\n\n      if (currentNode.firstChild) {\n        if (isValidMarkerElement(currentNode) && text !== null) {\n          section.markers.append(builder.createMarker(text, markups.slice()));\n          text = null;\n        }\n        currentNode = currentNode.firstChild;\n      } else if (currentNode.nextSibling) {\n        if (currentNode === topNode) {\n          section.markers.append(builder.createMarker(text, markups.slice()));\n          break;\n        } else {\n          currentNode = currentNode.nextSibling;\n          if (currentNode.nodeType === ELEMENT_NODE && isValidMarkerElement(currentNode) && text !== null) {\n            section.markers.append(builder.createMarker(text, markups.slice()));\n            text = null;\n          }\n        }\n      } else {\n        section.markers.append(builder.createMarker(text, markups.slice()));\n\n        while (currentNode && !currentNode.nextSibling && currentNode !== topNode) {\n          currentNode = currentNode.parentNode;\n          if (isValidMarkerElement(currentNode)) {\n            markups.pop();\n          }\n        }\n\n        text = null;\n\n        if (currentNode === topNode) {\n          break;\n        } else {\n          currentNode = currentNode.nextSibling;\n          if (currentNode === topNode) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function NewHTMLParser(builder) {\n    this.builder = builder;\n  }\n\n  NewHTMLParser.prototype = {\n    parseSection: function parseSection(previousSection, sectionElement) {\n      var builder = this.builder;\n      var section;\n      switch (sectionElement.nodeType) {\n        case ELEMENT_NODE:\n          var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(sectionElement.tagName);\n          // <p> <h2>, etc\n          if (_contentKitEditorModelsMarkupSection.VALID_MARKUP_SECTION_TAGNAMES.indexOf(tagName) !== -1) {\n            section = builder.createMarkupSection(tagName);\n            var node = sectionElement.firstChild;\n            while (node) {\n              parseMarkers(section, builder, node);\n              node = node.nextSibling;\n            }\n            // <strong> <b>, etc\n          } else {\n              if (previousSection && previousSection.isGenerated) {\n                section = previousSection;\n              } else {\n                section = builder.createMarkupSection('P', [], true);\n              }\n              parseMarkers(section, builder, sectionElement);\n            }\n          break;\n        case TEXT_NODE:\n          if (previousSection && previousSection.isGenerated) {\n            section = previousSection;\n          } else {\n            section = builder.createMarkupSection('P', [], true);\n          }\n          parseMarkers(section, builder, sectionElement);\n          break;\n      }\n      return section;\n    },\n    parse: function parse(postElement) {\n      var post = this.builder.createPost();\n      var i, l, section, previousSection, sectionElement;\n      // FIXME: Instead of storing isGenerated on sections, and passing\n      // the previous section to the parser, we could instead do a two-pass\n      // parse. The first pass identifies sections and gathers a list of\n      // dom nodes that can be parsed for markers, the second pass parses\n      // for markers.\n      for (i = 0, l = postElement.childNodes.length; i < l; i++) {\n        sectionElement = postElement.childNodes[i];\n        if (!isEmptyTextNode(sectionElement)) {\n          section = this.parseSection(previousSection, sectionElement);\n          if (section !== previousSection) {\n            post.sections.append(section);\n            previousSection = section;\n          }\n        }\n      }\n\n      if (post.sections.isEmpty) {\n        section = this.builder.createMarkupSection('p');\n        post.sections.append(section);\n      }\n\n      return post;\n    }\n  };\n\n  exports['default'] = NewHTMLParser;\n});","define(\"content-kit-editor/parsers/mobiledoc\", [\"exports\", \"content-kit-editor/renderers/mobiledoc\", \"content-kit-editor/utils/array-utils\"], function (exports, _contentKitEditorRenderersMobiledoc, _contentKitEditorUtilsArrayUtils) {\n  \"use strict\";\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  /*\n   * input mobiledoc: [ markers, elements ]\n   * output: Post\n   *\n   */\n\n  var MobiledocParser = (function () {\n    function MobiledocParser(builder) {\n      _classCallCheck(this, MobiledocParser);\n\n      this.builder = builder;\n    }\n\n    _createClass(MobiledocParser, [{\n      key: \"parse\",\n      value: function parse(_ref) {\n        var version = _ref.version;\n        var sectionData = _ref.sections;\n\n        var markerTypes = sectionData[0];\n        var sections = sectionData[1];\n\n        var post = this.builder.createPost();\n\n        this.markups = [];\n        this.markerTypes = this.parseMarkerTypes(markerTypes);\n        this.parseSections(sections, post);\n\n        return post;\n      }\n    }, {\n      key: \"parseMarkerTypes\",\n      value: function parseMarkerTypes(markerTypes) {\n        var _this = this;\n\n        return markerTypes.map(function (markerType) {\n          return _this.parseMarkerType(markerType);\n        });\n      }\n    }, {\n      key: \"parseMarkerType\",\n      value: function parseMarkerType(_ref2) {\n        var _ref22 = _slicedToArray(_ref2, 2);\n\n        var tagName = _ref22[0];\n        var attributes = _ref22[1];\n\n        return this.builder.createMarkup(tagName, attributes);\n      }\n    }, {\n      key: \"parseSections\",\n      value: function parseSections(sections, post) {\n        var _this2 = this;\n\n        sections.forEach(function (section) {\n          return _this2.parseSection(section, post);\n        });\n      }\n    }, {\n      key: \"parseSection\",\n      value: function parseSection(section, post) {\n        var _section = _slicedToArray(section, 1);\n\n        var type = _section[0];\n\n        switch (type) {\n          case _contentKitEditorRenderersMobiledoc.MOBILEDOC_MARKUP_SECTION_TYPE:\n            this.parseMarkupSection(section, post);\n            break;\n          case _contentKitEditorRenderersMobiledoc.MOBILEDOC_IMAGE_SECTION_TYPE:\n            this.parseImageSection(section, post);\n            break;\n          case _contentKitEditorRenderersMobiledoc.MOBILEDOC_CARD_SECTION_TYPE:\n            this.parseCardSection(section, post);\n            break;\n          case _contentKitEditorRenderersMobiledoc.MOBILEDOC_LIST_SECTION_TYPE:\n            this.parseListSection(section, post);\n            break;\n          default:\n            throw new Error(\"Unexpected section type \" + type);\n        }\n      }\n    }, {\n      key: \"parseCardSection\",\n      value: function parseCardSection(_ref3, post) {\n        var _ref32 = _slicedToArray(_ref3, 3);\n\n        var type = _ref32[0];\n        var name = _ref32[1];\n        var payload = _ref32[2];\n\n        var section = this.builder.createCardSection(name, payload);\n        post.sections.append(section);\n      }\n    }, {\n      key: \"parseImageSection\",\n      value: function parseImageSection(_ref4, post) {\n        var _ref42 = _slicedToArray(_ref4, 2);\n\n        var type = _ref42[0];\n        var src = _ref42[1];\n\n        var section = this.builder.createImageSection(src);\n        post.sections.append(section);\n      }\n    }, {\n      key: \"parseMarkupSection\",\n      value: function parseMarkupSection(_ref5, post) {\n        var _ref52 = _slicedToArray(_ref5, 3);\n\n        var type = _ref52[0];\n        var tagName = _ref52[1];\n        var markers = _ref52[2];\n\n        var section = this.builder.createMarkupSection(tagName);\n        post.sections.append(section);\n        this.parseMarkers(markers, section);\n        // Strip blank markers after the have been created. This ensures any\n        // markup they include has been correctly populated.\n        (0, _contentKitEditorUtilsArrayUtils.filter)(section.markers, function (m) {\n          return m.isEmpty;\n        }).forEach(function (m) {\n          section.markers.remove(m);\n        });\n      }\n    }, {\n      key: \"parseListSection\",\n      value: function parseListSection(_ref6, post) {\n        var _ref62 = _slicedToArray(_ref6, 3);\n\n        var type = _ref62[0];\n        var tagName = _ref62[1];\n        var items = _ref62[2];\n\n        var section = this.builder.createListSection(tagName);\n        post.sections.append(section);\n        this.parseListItems(items, section);\n      }\n    }, {\n      key: \"parseListItems\",\n      value: function parseListItems(items, section) {\n        var _this3 = this;\n\n        items.forEach(function (i) {\n          return _this3.parseListItem(i, section);\n        });\n      }\n    }, {\n      key: \"parseListItem\",\n      value: function parseListItem(markers, section) {\n        var item = this.builder.createListItem();\n        this.parseMarkers(markers, item);\n        section.items.append(item);\n      }\n    }, {\n      key: \"parseMarkers\",\n      value: function parseMarkers(markers, parent) {\n        var _this4 = this;\n\n        markers.forEach(function (m) {\n          return _this4.parseMarker(m, parent);\n        });\n      }\n    }, {\n      key: \"parseMarker\",\n      value: function parseMarker(_ref7, parent) {\n        var _this5 = this;\n\n        var _ref72 = _slicedToArray(_ref7, 3);\n\n        var markerTypeIndexes = _ref72[0];\n        var closeCount = _ref72[1];\n        var value = _ref72[2];\n\n        markerTypeIndexes.forEach(function (index) {\n          _this5.markups.push(_this5.markerTypes[index]);\n        });\n        var marker = this.builder.createMarker(value, this.markups.slice());\n        parent.markers.append(marker);\n        this.markups = this.markups.slice(0, this.markups.length - closeCount);\n      }\n    }]);\n\n    return MobiledocParser;\n  })();\n\n  exports[\"default\"] = MobiledocParser;\n});","define('content-kit-editor/parsers/post', ['exports', 'content-kit-editor/models/types', 'content-kit-editor/parsers/section', 'content-kit-editor/utils/array-utils', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/models/markup'], function (exports, _contentKitEditorModelsTypes, _contentKitEditorParsersSection, _contentKitEditorUtilsArrayUtils, _contentKitEditorUtilsDomUtils, _contentKitEditorModelsMarkup) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var PostParser = (function () {\n    function PostParser(builder) {\n      _classCallCheck(this, PostParser);\n\n      this.builder = builder;\n      this.sectionParser = new _contentKitEditorParsersSection['default'](this.builder);\n    }\n\n    _createClass(PostParser, [{\n      key: 'parse',\n      value: function parse(element) {\n        var _this = this;\n\n        var post = this.builder.createPost();\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(element.childNodes, function (child) {\n          post.sections.append(_this.sectionParser.parse(child));\n        });\n\n        return post;\n      }\n    }, {\n      key: 'parseSection',\n      value: function parseSection(element, otherArg) {\n        if (!!otherArg) {\n          element = otherArg; // hack to deal with passed previousSection\n        }\n        return this.sectionParser.parse(element);\n      }\n\n      // walk up from the textNode until the rootNode, converting each\n      // parentNode into a markup\n    }, {\n      key: 'collectMarkups',\n      value: function collectMarkups(textNode, rootNode) {\n        var markups = [];\n        var currentNode = textNode.parentNode;\n        while (currentNode && currentNode !== rootNode) {\n          var markup = this.markupFromNode(currentNode);\n          if (markup) {\n            markups.push(markup);\n          }\n\n          currentNode = currentNode.parentNode;\n        }\n        return markups;\n      }\n\n      // Turn an element node into a markup\n    }, {\n      key: 'markupFromNode',\n      value: function markupFromNode(node) {\n        if (_contentKitEditorModelsMarkup['default'].isValidElement(node)) {\n          var tagName = node.tagName;\n          var attributes = (0, _contentKitEditorUtilsDomUtils.getAttributesArray)(node);\n\n          return this.builder.createMarkup(tagName, attributes);\n        }\n      }\n\n      // FIXME should move to the section parser?\n      // FIXME the `collectMarkups` logic could simplify the section parser?\n    }, {\n      key: 'reparseSection',\n      value: function reparseSection(section, renderTree) {\n        switch (section.type) {\n          case _contentKitEditorModelsTypes.LIST_SECTION_TYPE:\n            return this.reparseListSection(section, renderTree);\n          case _contentKitEditorModelsTypes.LIST_ITEM_TYPE:\n            return this.reparseListItem(section, renderTree);\n          case _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE:\n            return this.reparseMarkupSection(section, renderTree);\n          default:\n            return; // can only parse the above types\n        }\n      }\n    }, {\n      key: 'reparseMarkupSection',\n      value: function reparseMarkupSection(section, renderTree) {\n        return this._reparseSectionContainingMarkers(section, renderTree);\n      }\n    }, {\n      key: 'reparseListItem',\n      value: function reparseListItem(listItem, renderTree) {\n        return this._reparseSectionContainingMarkers(listItem, renderTree);\n      }\n    }, {\n      key: 'reparseListSection',\n      value: function reparseListSection(listSection, renderTree) {\n        var _this2 = this;\n\n        listSection.items.forEach(function (li) {\n          return _this2.reparseListItem(li, renderTree);\n        });\n      }\n    }, {\n      key: '_reparseSectionContainingMarkers',\n      value: function _reparseSectionContainingMarkers(section, renderTree) {\n        var _this3 = this;\n\n        var element = section.renderNode.element;\n        var seenRenderNodes = [];\n        var previousMarker = undefined;\n\n        (0, _contentKitEditorUtilsDomUtils.walkTextNodes)(element, function (textNode) {\n          var text = textNode.textContent;\n          var markups = _this3.collectMarkups(textNode, element);\n\n          var marker = undefined;\n\n          var renderNode = renderTree.getElementRenderNode(textNode);\n          if (renderNode) {\n            if (text.length) {\n              marker = renderNode.postNode;\n              marker.value = text;\n              marker.markups = markups;\n            } else {\n              renderNode.scheduleForRemoval();\n            }\n          } else {\n            marker = _this3.builder.createMarker(text, markups);\n\n            renderNode = renderTree.buildRenderNode(marker);\n            renderNode.element = textNode;\n            renderNode.renderTree.elements.set(textNode, renderNode);\n            renderNode.markClean();\n\n            var previousRenderNode = previousMarker && previousMarker.renderNode;\n            section.markers.insertAfter(marker, previousMarker);\n            section.renderNode.childNodes.insertAfter(renderNode, previousRenderNode);\n\n            var parentNodeCount = marker.closedMarkups.length;\n            var nextMarkerElement = textNode.parentNode;\n            while (parentNodeCount--) {\n              nextMarkerElement = nextMarkerElement.parentNode;\n            }\n            renderNode.nextMarkerElement = nextMarkerElement;\n          }\n\n          seenRenderNodes.push(renderNode);\n          previousMarker = marker;\n        });\n\n        var renderNode = section.renderNode.childNodes.head;\n        while (renderNode) {\n          if (seenRenderNodes.indexOf(renderNode) === -1) {\n            renderNode.scheduleForRemoval();\n          }\n          renderNode = renderNode.next;\n        }\n      }\n    }]);\n\n    return PostParser;\n  })();\n\n  exports['default'] = PostParser;\n});","define('content-kit-editor/parsers/section', ['exports', 'content-kit-editor/models/markup-section', 'content-kit-editor/models/markup', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorModelsMarkupSection, _contentKitEditorModelsMarkup, _contentKitEditorUtilsDomUtils, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var TEXT_NODE = 3;\n  var ELEMENT_NODE = 1;\n\n  /**\n   * parses an element into a section, ignoring any non-markup\n   * elements contained within\n   * @return {Section}\n   */\n\n  var SectionParser = (function () {\n    function SectionParser(builder) {\n      _classCallCheck(this, SectionParser);\n\n      this.builder = builder;\n    }\n\n    _createClass(SectionParser, [{\n      key: 'parse',\n      value: function parse(element) {\n        var _this = this;\n\n        var tagName = this.sectionTagNameFromElement(element);\n        var section = this.builder.createMarkupSection(tagName);\n        var state = { section: section, markups: [], text: '' };\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(element.childNodes, function (el) {\n          _this.parseNode(el, state);\n        });\n\n        // close a trailing text nodes if it exists\n        if (state.text.length) {\n          var marker = this.builder.createMarker(state.text, state.markups);\n          state.section.markers.append(marker);\n        }\n\n        return section;\n      }\n    }, {\n      key: 'parseNode',\n      value: function parseNode(node, state) {\n        switch (node.nodeType) {\n          case TEXT_NODE:\n            this.parseTextNode(node, state);\n            break;\n          case ELEMENT_NODE:\n            this.parseElementNode(node, state);\n            break;\n          default:\n            throw new Error('parseNode got unexpected element type ' + node.nodeType + ' ' + node);\n        }\n      }\n    }, {\n      key: 'parseElementNode',\n      value: function parseElementNode(element, state) {\n        var _this2 = this;\n\n        var markup = this.markupFromElement(element);\n        if (markup) {\n          if (state.text.length) {\n            // close previous text marker\n            var marker = this.builder.createMarker(state.text, state.markups);\n            state.section.markers.append(marker);\n            state.text = '';\n          }\n\n          state.markups.push(markup);\n        }\n\n        (0, _contentKitEditorUtilsArrayUtils.forEach)(element.childNodes, function (node) {\n          _this2.parseNode(node, state);\n        });\n\n        if (markup) {\n          // close the marker started for this node and pop\n          // its markup from the stack\n          var marker = this.builder.createMarker(state.text, state.markups);\n          state.section.markers.append(marker);\n          state.markups.pop();\n          state.text = '';\n        }\n      }\n    }, {\n      key: 'parseTextNode',\n      value: function parseTextNode(textNode, state) {\n        state.text += textNode.textContent;\n      }\n    }, {\n      key: 'isSectionElement',\n      value: function isSectionElement(element) {\n        return element.nodeType === ELEMENT_NODE && _contentKitEditorModelsMarkupSection.VALID_MARKUP_SECTION_TAGNAMES.indexOf((0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName)) !== -1;\n      }\n    }, {\n      key: 'markupFromElement',\n      value: function markupFromElement(element) {\n        var tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(element.tagName);\n        if (_contentKitEditorModelsMarkup.VALID_MARKUP_TAGNAMES.indexOf(tagName) === -1) {\n          return null;\n        }\n\n        return this.builder.createMarkup(tagName, (0, _contentKitEditorUtilsDomUtils.getAttributes)(element));\n      }\n    }, {\n      key: 'sectionTagNameFromElement',\n      value: function sectionTagNameFromElement(element) {\n        var tagName = element.tagName;\n        tagName = tagName && (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n        if (_contentKitEditorModelsMarkupSection.VALID_MARKUP_SECTION_TAGNAMES.indexOf(tagName) === -1) {\n          tagName = _contentKitEditorModelsMarkupSection.DEFAULT_TAG_NAME;\n        }\n        return tagName;\n      }\n    }]);\n\n    return SectionParser;\n  })();\n\n  exports['default'] = SectionParser;\n});","define('content-kit-editor/renderers/editor-dom', ['exports', 'content-kit-editor/models/render-node', 'content-kit-editor/models/card-node', 'content-kit-editor/utils/array-utils', 'content-kit-editor/models/types', 'content-kit-editor/utils/string-utils', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorModelsRenderNode, _contentKitEditorModelsCardNode, _contentKitEditorUtilsArrayUtils, _contentKitEditorModelsTypes, _contentKitEditorUtilsStringUtils, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _destroyHooks;\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var NO_BREAK_SPACE = ' ';\n  exports.NO_BREAK_SPACE = NO_BREAK_SPACE;\n  var SPACE = ' ';\n\n  exports.SPACE = SPACE;\n  function createElementFromMarkup(doc, markup) {\n    var element = doc.createElement(markup.tagName);\n    if (markup.attributes) {\n      for (var i = 0, l = markup.attributes.length; i < l; i = i + 2) {\n        element.setAttribute(markup.attributes[i], markup.attributes[i + 1]);\n      }\n    }\n    return element;\n  }\n\n  // ascends from element upward, returning the last parent node that is not\n  // parentElement\n  function penultimateParentOf(element, parentElement) {\n    while (parentElement && element.parentNode !== parentElement && element.parentNode !== document.body // ensure the while loop stops\n    ) {\n      element = element.parentNode;\n    }\n    return element;\n  }\n\n  function renderMarkupSection(section) {\n    return document.createElement(section.tagName);\n  }\n\n  function renderListSection(section) {\n    return document.createElement(section.tagName);\n  }\n\n  function renderListItem() {\n    return document.createElement('li');\n  }\n\n  function renderCard() {\n    var element = document.createElement('div');\n    element.contentEditable = false;\n    (0, _contentKitEditorUtilsDomUtils.addClassName)(element, 'ck-card');\n    return element;\n  }\n\n  function getNextMarkerElement(renderNode) {\n    var element = renderNode.element.parentNode;\n    var marker = renderNode.postNode;\n    var closedCount = marker.closedMarkups.length;\n\n    while (closedCount--) {\n      element = element.parentNode;\n    }\n    return element;\n  }\n\n  function renderMarker(marker, element, previousRenderNode) {\n    var text = marker.value;\n\n    // If the first marker has a leading space or the last marker has a\n    // trailing space, the browser will collapse the space when we position\n    // the cursor.\n    // See https://github.com/bustlelabs/content-kit-editor/issues/68\n    //   and https://github.com/bustlelabs/content-kit-editor/issues/75\n    if (!marker.next && (0, _contentKitEditorUtilsStringUtils.endsWith)(text, SPACE)) {\n      text = text.substr(0, text.length - 1) + NO_BREAK_SPACE;\n    } else if (!marker.prev && (0, _contentKitEditorUtilsStringUtils.startsWith)(text, SPACE)) {\n      text = NO_BREAK_SPACE + text.substr(1);\n    }\n\n    var textNode = document.createTextNode(text);\n    var currentElement = textNode;\n    var markup = undefined;\n\n    var openTypes = marker.openedMarkups;\n    for (var j = openTypes.length - 1; j >= 0; j--) {\n      markup = openTypes[j];\n      var openedElement = createElementFromMarkup(document, markup);\n      openedElement.appendChild(currentElement);\n      currentElement = openedElement;\n    }\n\n    if (previousRenderNode) {\n      var previousSibling = previousRenderNode.element;\n      var previousSiblingPenultimate = penultimateParentOf(previousSibling, element);\n      element.insertBefore(currentElement, previousSiblingPenultimate.nextSibling);\n    } else {\n      element.insertBefore(currentElement, element.firstChild);\n    }\n\n    return textNode;\n  }\n\n  function attachRenderNodeElementToDOM(renderNode, element, originalElement) {\n    var hasRendered = !!originalElement;\n\n    if (hasRendered) {\n      var parentElement = renderNode.parent.element;\n      parentElement.replaceChild(element, originalElement);\n    } else {\n      var parentElement = undefined,\n          nextSiblingElement = undefined;\n      if (renderNode.prev) {\n        var previousElement = renderNode.prev.element;\n        parentElement = previousElement.parentNode;\n        nextSiblingElement = previousElement.nextSibling;\n      } else {\n        parentElement = renderNode.parent.element;\n        nextSiblingElement = parentElement.firstChild;\n      }\n      parentElement.insertBefore(element, nextSiblingElement);\n    }\n  }\n\n  function removeRenderNodeSectionFromParent(renderNode, section) {\n    var parent = renderNode.parent.postNode;\n    parent.sections.remove(section);\n  }\n\n  function removeRenderNodeElementFromParent(renderNode) {\n    if (renderNode.element.parentNode) {\n      renderNode.element.parentNode.removeChild(renderNode.element);\n    }\n  }\n\n  var Visitor = (function () {\n    function Visitor(editor, cards, unknownCardHandler, options) {\n      _classCallCheck(this, Visitor);\n\n      this.editor = editor;\n      this.cards = cards;\n      this.unknownCardHandler = unknownCardHandler;\n      this.options = options;\n    }\n\n    _createClass(Visitor, [{\n      key: _contentKitEditorModelsTypes.POST_TYPE,\n      value: function value(renderNode, post, visit) {\n        if (!renderNode.element) {\n          var element = document.createElement('div');\n          renderNode.element = element;\n        }\n        visit(renderNode, post.sections);\n      }\n    }, {\n      key: _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE,\n      value: function value(renderNode, section, visit) {\n        var originalElement = renderNode.element;\n\n        // Always rerender the section -- its tag name or attributes may have changed.\n        // TODO make this smarter, only rerendering and replacing the element when necessary\n        var element = renderMarkupSection(section);\n        renderNode.element = element;\n\n        attachRenderNodeElementToDOM(renderNode, element, originalElement);\n        renderNode.renderTree.elements.set(element, renderNode);\n\n        if (section.markers.length) {\n          var visitAll = true;\n          visit(renderNode, section.markers, visitAll);\n        } else {\n          renderNode.renderTree.elements.set(renderNode.element, renderNode);\n          var br = document.createElement('br');\n          renderNode.element.appendChild(br);\n        }\n      }\n    }, {\n      key: _contentKitEditorModelsTypes.LIST_SECTION_TYPE,\n      value: function value(renderNode, section, visit) {\n        var originalElement = renderNode.element;\n        var element = renderListSection(section);\n        renderNode.element = element;\n\n        attachRenderNodeElementToDOM(renderNode, element, originalElement);\n\n        var visitAll = true;\n        visit(renderNode, section.items, visitAll);\n      }\n    }, {\n      key: _contentKitEditorModelsTypes.LIST_ITEM_TYPE,\n      value: function value(renderNode, item, visit) {\n        // FIXME do we need to do anything special for rerenders?\n        var element = renderListItem();\n        renderNode.element = element;\n\n        attachRenderNodeElementToDOM(renderNode, element, null);\n\n        if (item.markers.length) {\n          var visitAll = true;\n          visit(renderNode, item.markers, visitAll);\n        } else {\n          renderNode.renderTree.elements.set(renderNode.element, renderNode);\n          var br = document.createElement('br');\n          renderNode.element.appendChild(br);\n        }\n      }\n    }, {\n      key: _contentKitEditorModelsTypes.MARKER_TYPE,\n      value: function value(renderNode, marker) {\n        var parentElement = undefined;\n\n        if (renderNode.prev) {\n          parentElement = getNextMarkerElement(renderNode.prev);\n        } else {\n          parentElement = renderNode.parent.element;\n        }\n\n        var element = renderMarker(marker, parentElement, renderNode.prev);\n        renderNode.renderTree.elements.set(element, renderNode);\n        renderNode.element = element;\n      }\n    }, {\n      key: _contentKitEditorModelsTypes.IMAGE_SECTION_TYPE,\n      value: function value(renderNode, section) {\n        if (renderNode.element) {\n          if (renderNode.element.src !== section.src) {\n            renderNode.element.src = section.src;\n          }\n        } else {\n          var element = document.createElement('img');\n          element.src = section.src;\n          if (renderNode.prev) {\n            var previousElement = renderNode.prev.element;\n            var nextElement = previousElement.nextSibling;\n            if (nextElement) {\n              nextElement.parentNode.insertBefore(element, nextElement);\n            }\n          }\n          if (!element.parentNode) {\n            renderNode.parent.element.appendChild(element);\n          }\n          renderNode.element = element;\n        }\n      }\n    }, {\n      key: _contentKitEditorModelsTypes.CARD_TYPE,\n      value: function value(renderNode, section) {\n        var originalElement = renderNode.element;\n        var editor = this.editor;\n        var options = this.options;\n\n        var card = (0, _contentKitEditorUtilsArrayUtils.detect)(this.cards, function (card) {\n          return card.name === section.name;\n        });\n        var element = renderCard();\n        renderNode.element = element;\n\n        attachRenderNodeElementToDOM(renderNode, element, originalElement);\n\n        renderNode.renderTree.elements.set(element, renderNode);\n        if (card) {\n          var cardNode = new _contentKitEditorModelsCardNode['default'](editor, card, section, element, options);\n          renderNode.cardNode = cardNode;\n          cardNode.display();\n        } else {\n          var env = { name: section.name };\n          this.unknownCardHandler(element, options, env, section.payload);\n        }\n      }\n    }]);\n\n    return Visitor;\n  })();\n\n  var destroyHooks = (_destroyHooks = {}, _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.POST_TYPE, function () /*renderNode, post*/{\n    throw new Error('post destruction is not supported by the renderer');\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE, function (renderNode, section) {\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.LIST_SECTION_TYPE, function (renderNode, section) {\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.LIST_ITEM_TYPE, function (renderNode, li) {\n    removeRenderNodeSectionFromParent(renderNode, li);\n    removeRenderNodeElementFromParent(renderNode);\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.MARKER_TYPE, function (renderNode, marker) {\n    // FIXME before we render marker, should delete previous renderNode's element\n    // and up until the next marker element\n\n    var element = renderNode.element;\n    var nextMarkerElement = getNextMarkerElement(renderNode);\n    while (element.parentNode && element.parentNode !== nextMarkerElement) {\n      element = element.parentNode;\n    }\n\n    if (marker.section) {\n      marker.section.markers.remove(marker);\n    }\n\n    if (element.parentNode) {\n      // if no parentNode, the browser already removed this element\n      element.parentNode.removeChild(element);\n    }\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.IMAGE_SECTION_TYPE, function (renderNode, section) {\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  }), _defineProperty(_destroyHooks, _contentKitEditorModelsTypes.CARD_TYPE, function (renderNode, section) {\n    if (renderNode.cardNode) {\n      renderNode.cardNode.teardown();\n    }\n    removeRenderNodeSectionFromParent(renderNode, section);\n    removeRenderNodeElementFromParent(renderNode);\n  }), _destroyHooks);\n\n  // removes children from parentNode that are scheduled for removal\n  function removeChildren(parentNode) {\n    var child = parentNode.childNodes.head;\n    var nextChild = undefined,\n        method = undefined;\n    while (child) {\n      nextChild = child.next;\n      if (child.isRemoved) {\n        method = child.postNode.type;\n        if (!destroyHooks[method]) {\n          throw new Error('editor-dom cannot destroy \"' + method + '\"');\n        }\n        destroyHooks[method](child, child.postNode);\n        parentNode.childNodes.remove(child);\n      }\n      child = nextChild;\n    }\n  }\n\n  // Find an existing render node for the given postNode, or\n  // create one, insert it into the tree, and return it\n  function lookupNode(renderTree, parentNode, postNode, previousNode) {\n    if (postNode.renderNode) {\n      return postNode.renderNode;\n    } else {\n      var renderNode = new _contentKitEditorModelsRenderNode['default'](postNode);\n      parentNode.childNodes.insertAfter(renderNode, previousNode);\n      postNode.renderNode = renderNode;\n      return renderNode;\n    }\n  }\n\n  var Renderer = (function () {\n    function Renderer(editor, cards, unknownCardHandler, options) {\n      _classCallCheck(this, Renderer);\n\n      this.editor = editor;\n      this.visitor = new Visitor(editor, cards, unknownCardHandler, options);\n      this.nodes = [];\n    }\n\n    _createClass(Renderer, [{\n      key: 'visit',\n      value: function visit(renderTree, parentNode, postNodes) {\n        var _this = this;\n\n        var visitAll = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        var previousNode = undefined;\n        postNodes.forEach(function (postNode) {\n          var node = lookupNode(renderTree, parentNode, postNode, previousNode);\n          if (node.isDirty || visitAll) {\n            _this.nodes.push(node);\n          }\n          previousNode = node;\n        });\n      }\n    }, {\n      key: 'render',\n      value: function render(renderTree) {\n        var _this2 = this;\n\n        var node = renderTree.node;\n        var method = undefined,\n            postNode = undefined;\n\n        while (node) {\n          removeChildren(node);\n          postNode = node.postNode;\n\n          method = postNode.type;\n          if (!this.visitor[method]) {\n            throw new Error('EditorDom visitor cannot handle type ' + method);\n          }\n          this.visitor[node.postNode.type](node, postNode, function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return _this2.visit.apply(_this2, [renderTree].concat(args));\n          });\n          node.markClean();\n          node = this.nodes.shift();\n        }\n      }\n    }]);\n\n    return Renderer;\n  })();\n\n  exports['default'] = Renderer;\n});","define('content-kit-editor/renderers/mobiledoc', ['exports', 'content-kit-editor/utils/compiler', 'content-kit-editor/models/types'], function (exports, _contentKitEditorUtilsCompiler, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  var _visitor;\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n  var MOBILEDOC_VERSION = '0.2.0';\n  exports.MOBILEDOC_VERSION = MOBILEDOC_VERSION;\n  var MOBILEDOC_MARKUP_SECTION_TYPE = 1;\n  exports.MOBILEDOC_MARKUP_SECTION_TYPE = MOBILEDOC_MARKUP_SECTION_TYPE;\n  var MOBILEDOC_IMAGE_SECTION_TYPE = 2;\n  exports.MOBILEDOC_IMAGE_SECTION_TYPE = MOBILEDOC_IMAGE_SECTION_TYPE;\n  var MOBILEDOC_LIST_SECTION_TYPE = 3;\n  exports.MOBILEDOC_LIST_SECTION_TYPE = MOBILEDOC_LIST_SECTION_TYPE;\n  var MOBILEDOC_CARD_SECTION_TYPE = 10;\n\n  exports.MOBILEDOC_CARD_SECTION_TYPE = MOBILEDOC_CARD_SECTION_TYPE;\n  var visitor = (_visitor = {}, _defineProperty(_visitor, _contentKitEditorModelsTypes.POST_TYPE, function (node, opcodes) {\n    opcodes.push(['openPost']);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.sections, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE, function (node, opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName]);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.markers, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.LIST_SECTION_TYPE, function (node, opcodes) {\n    opcodes.push(['openListSection', node.tagName]);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.items, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.LIST_ITEM_TYPE, function (node, opcodes) {\n    opcodes.push(['openListItem']);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.markers, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.IMAGE_SECTION_TYPE, function (node, opcodes) {\n    opcodes.push(['openImageSection', node.src]);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.CARD_TYPE, function (node, opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload]);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.MARKER_TYPE, function (node, opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);\n    (0, _contentKitEditorUtilsCompiler.visitArray)(visitor, node.openedMarkups, opcodes);\n  }), _defineProperty(_visitor, _contentKitEditorModelsTypes.MARKUP_TYPE, function (node, opcodes) {\n    opcodes.push(['openMarkup', node.tagName, node.attributes]);\n  }), _visitor);\n\n  var postOpcodeCompiler = {\n    openMarker: function openMarker(closeCount, value) {\n      this.markupMarkerIds = [];\n      this.markers.push([this.markupMarkerIds, closeCount, value || '']);\n    },\n    openMarkupSection: function openMarkupSection(tagName) {\n      this.markers = [];\n      this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE, tagName, this.markers]);\n    },\n    openListSection: function openListSection(tagName) {\n      this.items = [];\n      this.sections.push([MOBILEDOC_LIST_SECTION_TYPE, tagName, this.items]);\n    },\n    openListItem: function openListItem() {\n      this.markers = [];\n      this.items.push(this.markers);\n    },\n    openImageSection: function openImageSection(url) {\n      this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE, url]);\n    },\n    openCardSection: function openCardSection(name, payload) {\n      this.sections.push([MOBILEDOC_CARD_SECTION_TYPE, name, payload]);\n    },\n    openPost: function openPost() {\n      this.markerTypes = [];\n      this.sections = [];\n      this.result = {\n        version: MOBILEDOC_VERSION,\n        sections: [this.markerTypes, this.sections]\n      };\n    },\n    openMarkup: function openMarkup(tagName, attributes) {\n      if (!this._seenMarkerTypes) {\n        this._seenMarkerTypes = {};\n      }\n      var index = undefined;\n      if (attributes.length) {\n        this.markerTypes.push([tagName, attributes]);\n        index = this.markerTypes.length - 1;\n      } else {\n        index = this._seenMarkerTypes[tagName];\n        if (index === undefined) {\n          this.markerTypes.push([tagName]);\n          this._seenMarkerTypes[tagName] = index = this.markerTypes.length - 1;\n        }\n      }\n      this.markupMarkerIds.push(index);\n    }\n  };\n\n  exports['default'] = {\n    render: function render(post) {\n      var opcodes = [];\n      (0, _contentKitEditorUtilsCompiler.visit)(visitor, post, opcodes);\n      var compiler = Object.create(postOpcodeCompiler);\n      (0, _contentKitEditorUtilsCompiler.compile)(compiler, opcodes);\n      return compiler.result;\n    }\n  };\n});","define(\"content-kit-editor/utils/array-utils\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  function detect(enumerable, callback) {\n    if (enumerable.detect) {\n      return enumerable.detect(callback);\n    } else {\n      for (var i = 0; i < enumerable.length; i++) {\n        if (callback(enumerable[i])) {\n          return enumerable[i];\n        }\n      }\n    }\n  }\n\n  function any(array, callback) {\n    for (var i = 0; i < array.length; i++) {\n      if (callback(array[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Useful for array-like things that aren't\n   * actually arrays, like NodeList\n   */\n  function forEach(enumerable, callback) {\n    if (enumerable.forEach) {\n      enumerable.forEach(callback);\n    } else {\n      for (var i = 0; i < enumerable.length; i++) {\n        callback(enumerable[i], i);\n      }\n    }\n  }\n\n  function filter(enumerable, conditionFn) {\n    var filtered = [];\n    forEach(enumerable, function (i) {\n      if (conditionFn(i)) {\n        filtered.push(i);\n      }\n    });\n    return filtered;\n  }\n\n  /**\n   * @return {Integer} the number of items that are the same, starting from the 0th index, in a and b\n   */\n  function commonItemLength(listA, listB) {\n    var offset = 0;\n    while (offset < listA.length && offset < listB.length) {\n      if (listA[offset] !== listB[offset]) {\n        break;\n      }\n      offset++;\n    }\n    return offset;\n  }\n\n  // return new array without falsy items like ruby's `compact`\n  function compact(enumerable) {\n    return filter(enumerable, function (i) {\n      return !!i;\n    });\n  }\n\n  function reduce(enumerable, callback, initialValue) {\n    var previousValue = initialValue;\n    forEach(enumerable, function (val, index) {\n      previousValue = callback(previousValue, val, index);\n    });\n    return previousValue;\n  }\n\n  exports.detect = detect;\n  exports.forEach = forEach;\n  exports.any = any;\n  exports.filter = filter;\n  exports.commonItemLength = commonItemLength;\n  exports.compact = compact;\n  exports.reduce = reduce;\n});","define('content-kit-editor/utils/compat', ['exports', 'content-kit-editor/utils/doc', 'content-kit-editor/utils/win'], function (exports, _contentKitEditorUtilsDoc, _contentKitEditorUtilsWin) {\n  'use strict';\n\n  exports.doc = _contentKitEditorUtilsDoc['default'];\n  exports.win = _contentKitEditorUtilsWin['default'];\n});","define(\"content-kit-editor/utils/compiler\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  exports.visit = visit;\n  exports.compile = compile;\n  exports.visitArray = visitArray;\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  function visit(visitor, node, opcodes) {\n    var method = node.type;\n    if (!visitor[method]) {\n      throw new Error(\"Cannot visit unknown type \" + method);\n    }\n    visitor[method](node, opcodes);\n  }\n\n  function compile(compiler, opcodes) {\n    for (var i = 0, l = opcodes.length; i < l; i++) {\n      var _opcodes$i = _toArray(opcodes[i]);\n\n      var method = _opcodes$i[0];\n\n      var params = _opcodes$i.slice(1);\n\n      if (params.length) {\n        compiler[method].apply(compiler, params);\n      } else {\n        compiler[method].call(compiler);\n      }\n    }\n  }\n\n  function visitArray(visitor, nodes, opcodes) {\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n    nodes.forEach(function (node) {\n      visit(visitor, node, opcodes);\n    });\n  }\n});","define('content-kit-editor/utils/cursor', ['exports', 'content-kit-editor/utils/selection-utils', 'content-kit-editor/utils/cursor/position', 'content-kit-editor/utils/cursor/range'], function (exports, _contentKitEditorUtilsSelectionUtils, _contentKitEditorUtilsCursorPosition, _contentKitEditorUtilsCursorRange) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  exports.Position = _contentKitEditorUtilsCursorPosition['default'];\n  exports.Range = _contentKitEditorUtilsCursorRange['default'];\n\n  var Cursor = (function () {\n    function Cursor(editor) {\n      _classCallCheck(this, Cursor);\n\n      this.editor = editor;\n      this.renderTree = editor._renderTree;\n      this.post = editor.post;\n    }\n\n    _createClass(Cursor, [{\n      key: 'clearSelection',\n      value: function clearSelection() {\n        (0, _contentKitEditorUtilsSelectionUtils.clearSelection)();\n      }\n\n      /**\n       * @return {Boolean} true when there is either a collapsed cursor in the\n       * editor's element or a selection that is contained in the editor's element\n       */\n    }, {\n      key: 'hasCursor',\n      value: function hasCursor() {\n        return this._hasCollapsedSelection() || this._hasSelection();\n      }\n    }, {\n      key: 'isInCard',\n      value: function isInCard() {\n        if (!this.hasCursor()) {\n          return false;\n        }\n\n        var _offsets = this.offsets;\n        var head = _offsets.head;\n        var tail = _offsets.tail;\n\n        return head && tail && (head._inCard || tail._inCard);\n      }\n    }, {\n      key: 'hasSelection',\n      value: function hasSelection() {\n        return this._hasSelection();\n      }\n\n      /*\n       * @return {Range} Cursor#Range object\n       */\n    }, {\n      key: 'moveToSection',\n\n      // moves cursor to the start of the section\n      value: function moveToSection(section) {\n        var offsetInSection = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n        this.moveToPosition(new _contentKitEditorUtilsCursorPosition['default'](section, offsetInSection));\n      }\n    }, {\n      key: 'selectSections',\n      value: function selectSections(sections) {\n        var headSection = sections[0],\n            tailSection = sections[sections.length - 1];\n        var range = _contentKitEditorUtilsCursorRange['default'].create(headSection, 0, tailSection, tailSection.length);\n        this.selectRange(range);\n      }\n    }, {\n      key: '_findNodeForPosition',\n      value: function _findNodeForPosition(position) {\n        var section = position.section;\n\n        var node = undefined,\n            offset = undefined;\n        if (section.isBlank) {\n          node = section.renderNode.element;\n          offset = 0;\n        } else {\n          var marker = position.marker;\n          var offsetInMarker = position.offsetInMarker;\n\n          node = marker.renderNode.element;\n          offset = offsetInMarker;\n        }\n\n        return { node: node, offset: offset };\n      }\n    }, {\n      key: 'selectRange',\n      value: function selectRange(range) {\n        var head = range.head;\n        var tail = range.tail;\n\n        var _findNodeForPosition2 = this._findNodeForPosition(head);\n\n        var headNode = _findNodeForPosition2.node;\n        var headOffset = _findNodeForPosition2.offset;\n\n        var _findNodeForPosition3 = this._findNodeForPosition(tail);\n\n        var tailNode = _findNodeForPosition3.node;\n        var tailOffset = _findNodeForPosition3.offset;\n\n        this._moveToNode(headNode, headOffset, tailNode, tailOffset);\n      }\n    }, {\n      key: 'selectedText',\n      value: function selectedText() {\n        return this.selection.toString();\n      }\n    }, {\n      key: 'moveToPosition',\n      value: function moveToPosition(position) {\n        this.selectRange(new _contentKitEditorUtilsCursorRange['default'](position, position));\n      }\n\n      /**\n       * @private\n       * @param {textNode} node\n       * @param {integer} offset\n       * @param {textNode} endNode (default: node)\n       * @param {integer} endOffset (default: offset)\n       */\n    }, {\n      key: '_moveToNode',\n      value: function _moveToNode(node) {\n        var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var endNode = arguments.length <= 2 || arguments[2] === undefined ? node : arguments[2];\n        var endOffset = arguments.length <= 3 || arguments[3] === undefined ? offset : arguments[3];\n        return (function () {\n          this.clearSelection();\n\n          var range = document.createRange();\n          range.setStart(node, offset);\n          range.setEnd(endNode, endOffset);\n\n          this.selection.addRange(range);\n        }).apply(this, arguments);\n      }\n    }, {\n      key: '_hasSelection',\n      value: function _hasSelection() {\n        var element = this.editor.element;\n        var _selectionRange = this._selectionRange;\n\n        if (!_selectionRange || _selectionRange.collapsed) {\n          return false;\n        }\n\n        return (0, _contentKitEditorUtilsSelectionUtils.containsNode)(element, this.selection.anchorNode) && (0, _contentKitEditorUtilsSelectionUtils.containsNode)(element, this.selection.focusNode);\n      }\n    }, {\n      key: '_hasCollapsedSelection',\n      value: function _hasCollapsedSelection() {\n        var _selectionRange = this._selectionRange;\n\n        if (!_selectionRange) {\n          return false;\n        }\n\n        var element = this.editor.element;\n        return (0, _contentKitEditorUtilsSelectionUtils.containsNode)(element, this.selection.anchorNode);\n      }\n    }, {\n      key: 'offsets',\n      get: function get() {\n        if (!this.hasCursor()) {\n          return _contentKitEditorUtilsCursorRange['default'].emptyRange();\n        }\n\n        var selection = this.selection;\n        var renderTree = this.renderTree;\n\n        var _comparePosition = (0, _contentKitEditorUtilsSelectionUtils.comparePosition)(selection);\n\n        var headNode = _comparePosition.headNode;\n        var headOffset = _comparePosition.headOffset;\n        var tailNode = _comparePosition.tailNode;\n        var tailOffset = _comparePosition.tailOffset;\n\n        var headPosition = _contentKitEditorUtilsCursorPosition['default'].fromNode(renderTree, headNode, headOffset);\n        var tailPosition = _contentKitEditorUtilsCursorPosition['default'].fromNode(renderTree, tailNode, tailOffset);\n\n        return new _contentKitEditorUtilsCursorRange['default'](headPosition, tailPosition);\n      }\n    }, {\n      key: 'activeSections',\n      get: function get() {\n        if (!this.hasCursor()) {\n          return [];\n        }\n\n        var _offsets2 = this.offsets;\n        var head = _offsets2.head;\n        var tail = _offsets2.tail;\n\n        return this.post.sections.readRange(head.section, tail.section);\n      }\n    }, {\n      key: 'selection',\n      get: function get() {\n        return window.getSelection();\n      }\n    }, {\n      key: '_selectionRange',\n      get: function get() {\n        var selection = this.selection;\n\n        if (selection.rangeCount === 0) {\n          return null;\n        }\n        return selection.getRangeAt(0);\n      }\n    }]);\n\n    return Cursor;\n  })();\n\n  exports['default'] = Cursor;\n});","define('content-kit-editor/utils/cursor/position', ['exports', 'content-kit-editor/utils/dom-utils', 'content-kit-editor/models/types'], function (exports, _contentKitEditorUtilsDomUtils, _contentKitEditorModelsTypes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function isSection(postNode) {\n    if (!(postNode && postNode.type)) {\n      return false;\n    }\n    return postNode.type === _contentKitEditorModelsTypes.MARKUP_SECTION_TYPE || postNode.type === _contentKitEditorModelsTypes.LIST_ITEM_TYPE || postNode.type === _contentKitEditorModelsTypes.CARD_TYPE;\n  }\n\n  function isCardSection(section) {\n    return section.type === _contentKitEditorModelsTypes.CARD_TYPE;\n  }\n\n  function findParentSectionFromNode(renderTree, node) {\n    var renderNode = undefined;\n    while (node && node !== renderTree.rootElement) {\n      renderNode = renderTree.getElementRenderNode(node);\n      if (renderNode && isSection(renderNode.postNode)) {\n        return renderNode.postNode;\n      }\n      node = node.parentNode;\n    }\n  }\n\n  var Position = (function () {\n    function Position(section) {\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      _classCallCheck(this, Position);\n\n      this.section = section;\n      this.offset = offset;\n      this._inCard = isCardSection(section);\n    }\n\n    _createClass(Position, [{\n      key: 'clone',\n      value: function clone() {\n        return new Position(this.section, this.offset);\n      }\n    }, {\n      key: 'isEqual',\n      value: function isEqual(position) {\n        return this.section === position.section && this.offset === position.offset;\n      }\n    }, {\n      key: 'marker',\n      get: function get() {\n        return this.markerPosition.marker;\n      }\n    }, {\n      key: 'offsetInMarker',\n      get: function get() {\n        return this.markerPosition.offset;\n      }\n    }, {\n      key: 'markerPosition',\n\n      /**\n       * @private\n       */\n      get: function get() {\n        if (!this.section) {\n          throw new Error('cannot get markerPosition without a section');\n        }\n        return this.section.markerPositionAtOffset(this.offset);\n      }\n    }], [{\n      key: 'emptyPosition',\n      value: function emptyPosition() {\n        return {\n          section: null,\n          offset: 0,\n          _inCard: false,\n          marker: null,\n          offsetInTextNode: 0,\n          _isEmpty: true,\n          isEqual: function isEqual(other) {\n            return other._isEmpty;\n          },\n          markerPosition: {}\n        };\n      }\n    }, {\n      key: 'fromNode',\n      value: function fromNode(renderTree, node, offset) {\n        if ((0, _contentKitEditorUtilsDomUtils.isTextNode)(node)) {\n          return Position.fromTextNode(renderTree, node, offset);\n        } else {\n          return Position.fromElementNode(renderTree, node);\n        }\n      }\n    }, {\n      key: 'fromTextNode',\n      value: function fromTextNode(renderTree, textNode, offsetInNode) {\n        var renderNode = renderTree.getElementRenderNode(textNode);\n        var section = undefined,\n            offsetInSection = undefined;\n\n        if (renderNode) {\n          var marker = renderNode.postNode;\n          section = marker.section;\n\n          if (!section) {\n            throw new Error('Could not find parent section for mapped text node \"' + textNode.textContent + '\"');\n          }\n          offsetInSection = section.offsetOfMarker(marker, offsetInNode);\n        } else {\n          // all text nodes should be rendered by markers except:\n          //   * text nodes inside cards\n          //   * text nodes created by the browser during text input\n          // both of these should have rendered parent sections, though\n          section = findParentSectionFromNode(renderTree, textNode);\n          if (!section) {\n            throw new Error('Could not find parent section for un-mapped text node \"' + textNode.textContent + '\"');\n          }\n\n          if (isCardSection(section)) {\n            offsetInSection = 0; // we don't care about offsets in card sections\n          } else {\n              offsetInSection = (0, _contentKitEditorUtilsDomUtils.findOffsetInElement)(section.renderNode.element, textNode, offsetInNode);\n            }\n        }\n\n        return new Position(section, offsetInSection);\n      }\n    }, {\n      key: 'fromElementNode',\n      value: function fromElementNode(renderTree, elementNode) {\n        // The browser may change the reported selection to equal the editor's root\n        // element if the user clicks an element that is immediately removed,\n        // which can happen when clicking to remove a card.\n        if (elementNode === renderTree.rootElement) {\n          return Position.emptyPosition();\n        }\n\n        var section = undefined,\n            offsetInSection = 0;\n\n        section = findParentSectionFromNode(renderTree, elementNode);\n        if (!section) {\n          throw new Error('Could not find parent section from element node');\n        }\n\n        // FIXME We assume that offsetInSection will always be 0 because we assume\n        // that only empty br tags (offsetInSection=0) will be those that cause\n        // us to call `fromElementNode`. This may not be a reliable assumption.\n        return new Position(section, offsetInSection);\n      }\n    }]);\n\n    return Position;\n  })();\n\n  exports['default'] = Position;\n});","define('content-kit-editor/utils/cursor/range', ['exports', 'content-kit-editor/utils/cursor/position'], function (exports, _contentKitEditorUtilsCursorPosition) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var Range = (function () {\n    function Range(head, tail) {\n      _classCallCheck(this, Range);\n\n      this.head = head;\n      this.tail = tail;\n    }\n\n    _createClass(Range, [{\n      key: 'trimTo',\n\n      /**\n       * @param {Markerable} section\n       * @return {Range} A range that is constrained to only the part that\n       * includes the section.\n       * FIXME -- if the section isn't the head or tail, it's assumed to be\n       * wholly contained. It's possible to call `trimTo` with a selection that is\n       * outside of the range, though, which would invalidate that assumption.\n       */\n      value: function trimTo(section) {\n        var length = section.length;\n\n        var headOffset = section === this.head.section ? Math.min(this.head.offset, length) : 0;\n        var tailOffset = section === this.tail.section ? Math.min(this.tail.offset, length) : length;\n\n        return Range.create(section, headOffset, section, tailOffset);\n      }\n\n      // \"legacy\" APIs\n    }, {\n      key: 'headSection',\n      get: function get() {\n        return this.head.section;\n      }\n    }, {\n      key: 'tailSection',\n      get: function get() {\n        return this.tail.section;\n      }\n    }, {\n      key: 'headSectionOffset',\n      get: function get() {\n        return this.head.offset;\n      }\n    }, {\n      key: 'tailSectionOffset',\n      get: function get() {\n        return this.tail.offset;\n      }\n    }, {\n      key: 'isCollapsed',\n      get: function get() {\n        return this.head.isEqual(this.tail);\n      }\n    }, {\n      key: 'headMarker',\n      get: function get() {\n        return this.head.marker;\n      }\n    }, {\n      key: 'tailMarker',\n      get: function get() {\n        return this.tail.marker;\n      }\n    }, {\n      key: 'headMarkerOffset',\n      get: function get() {\n        return this.head.offsetInMarker;\n      }\n    }, {\n      key: 'tailMarkerOffset',\n      get: function get() {\n        return this.tail.offsetInMarker;\n      }\n    }], [{\n      key: 'create',\n      value: function create(headSection, headOffset, tailSection, tailOffset) {\n        return new Range(new _contentKitEditorUtilsCursorPosition['default'](headSection, headOffset), new _contentKitEditorUtilsCursorPosition['default'](tailSection, tailOffset));\n      }\n    }, {\n      key: 'emptyRange',\n      value: function emptyRange() {\n        return new Range(_contentKitEditorUtilsCursorPosition['default'].emptyPosition(), _contentKitEditorUtilsCursorPosition['default'].emptyPosition());\n      }\n    }]);\n\n    return Range;\n  })();\n\n  exports['default'] = Range;\n});","define('content-kit-editor/utils/dom-utils', ['exports', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var TEXT_NODE_TYPE = 3;\n\n  function detectParentNode(element, callback) {\n    while (element) {\n      var result = callback(element);\n      if (result) {\n        return {\n          element: element,\n          result: result\n        };\n      }\n      element = element.parentNode;\n    }\n\n    return {\n      element: null,\n      result: null\n    };\n  }\n\n  function isTextNode(node) {\n    return node.nodeType === TEXT_NODE_TYPE;\n  }\n\n  // perform a pre-order tree traversal of the dom, calling `callbackFn(node)`\n  // for every node for which `conditionFn(node)` is true\n  function walkDOM(topNode) {\n    var callbackFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n    var conditionFn = arguments.length <= 2 || arguments[2] === undefined ? function () {\n      return true;\n    } : arguments[2];\n\n    var currentNode = topNode;\n\n    if (conditionFn(currentNode)) {\n      callbackFn(currentNode);\n    }\n\n    currentNode = currentNode.firstChild;\n\n    while (currentNode) {\n      walkDOM(currentNode, callbackFn, conditionFn);\n      currentNode = currentNode.nextSibling;\n    }\n  }\n\n  function walkTextNodes(topNode) {\n    var callbackFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    var conditionFn = function conditionFn(node) {\n      return isTextNode(node);\n    };\n    walkDOM(topNode, callbackFn, conditionFn);\n  }\n\n  function clearChildNodes(element) {\n    while (element.childNodes.length) {\n      element.removeChild(element.childNodes[0]);\n    }\n  }\n\n  // walks DOWN the dom from node to childNodes, returning the element\n  // for which `conditionFn(element)` is true\n  function walkDOMUntil(topNode) {\n    var conditionFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    if (!topNode) {\n      throw new Error('Cannot call walkDOMUntil without a node');\n    }\n    var stack = [topNode];\n    var currentElement = undefined;\n\n    while (stack.length) {\n      currentElement = stack.pop();\n\n      if (conditionFn(currentElement)) {\n        return currentElement;\n      }\n\n      (0, _contentKitEditorUtilsArrayUtils.forEach)(currentElement.childNodes, function (el) {\n        return stack.push(el);\n      });\n    }\n  }\n\n  /**\n   * @return {Boolean} true when the child node is contained by (and not\n   * the same as) the parent node\n   *  see https://github.com/webmodules/node-contains/blob/master/index.js\n   */\n  function containsNode(parentNode, childNode) {\n    var position = parentNode.compareDocumentPosition(childNode);\n    return !!(position & Node.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  /**\n   * converts the element's NamedNodeMap of attrs into\n   * an object with key-value pairs\n   * FIXME should add a whitelist as a second arg\n   */\n  function getAttributes(element) {\n    var result = {};\n    if (element.hasAttributes()) {\n      var attributes = element.attributes;\n\n      (0, _contentKitEditorUtilsArrayUtils.forEach)(attributes, function (_ref) {\n        var name = _ref.name;\n        var value = _ref.value;\n        return result[name] = value;\n      });\n    }\n    return result;\n  }\n\n  /**\n   * converts the element's NamedNodeMap of attrs into\n   * an array of key1,value1,key2,value2,...\n   * FIXME should add a whitelist as a second arg\n   */\n  function getAttributesArray(element) {\n    var attributes = getAttributes(element);\n    var result = [];\n    Object.keys(attributes).forEach(function (key) {\n      result.push(key);\n      result.push(attributes[key]);\n    });\n    return result;\n  }\n\n  function addClassName(element, className) {\n    // FIXME-IE IE10+\n    element.classList.add(className);\n  }\n\n  function removeClassName(element, className) {\n    // FIXME-IE IE10+\n    element.classList.remove(className);\n  }\n\n  function normalizeTagName(tagName) {\n    return tagName.toLowerCase();\n  }\n\n  /*\n   * @param {Node} elementNode not a text node\n   * @param {Node} textNode a text node\n   * @param {Number} offsetInTextNode optional, the offset relative to the text node\n   * @return {Number} The offset relative to all the text nodes in the element node\n   */\n  function findOffsetInElement(elementNode, textNode) {\n    var offsetInTextNode = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n    var offset = 0,\n        found = false;\n    walkTextNodes(elementNode, function (_textNode) {\n      if (found) {\n        return;\n      }\n      if (_textNode === textNode) {\n        found = true;\n        offset += offsetInTextNode;\n      } else {\n        offset += _textNode.textContent.length;\n      }\n    });\n    if (!found) {\n      throw new Error('Unable to find offset of text node in element, it is not a child.');\n    }\n    return offset;\n  }\n\n  function parseHTML(html) {\n    var div = document.createElement('div');\n    div.innerHTML = html;\n    return div;\n  }\n\n  exports.detectParentNode = detectParentNode;\n  exports.containsNode = containsNode;\n  exports.clearChildNodes = clearChildNodes;\n  exports.getAttributes = getAttributes;\n  exports.getAttributesArray = getAttributesArray;\n  exports.walkDOMUntil = walkDOMUntil;\n  exports.walkDOM = walkDOM;\n  exports.walkTextNodes = walkTextNodes;\n  exports.addClassName = addClassName;\n  exports.removeClassName = removeClassName;\n  exports.normalizeTagName = normalizeTagName;\n  exports.isTextNode = isTextNode;\n  exports.parseHTML = parseHTML;\n  exports.findOffsetInElement = findOffsetInElement;\n});","define('content-kit-editor/utils/element-map', ['exports'], function (exports) {\n  // start at one to make the falsy semantics easier\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var uuidGenerator = 1;\n\n  var ElementMap = (function () {\n    function ElementMap() {\n      _classCallCheck(this, ElementMap);\n\n      this._map = {};\n    }\n\n    _createClass(ElementMap, [{\n      key: 'set',\n      value: function set(key, value) {\n        var uuid = key._uuid;\n        if (!uuid) {\n          key._uuid = uuid = '' + uuidGenerator++;\n        }\n        this._map[uuid] = value;\n      }\n    }, {\n      key: 'get',\n      value: function get(key) {\n        if (key._uuid) {\n          return this._map[key._uuid];\n        }\n        return null;\n      }\n    }, {\n      key: 'remove',\n      value: function remove(key) {\n        if (!key._uuid) {\n          throw new Error('tried to fetch a value for an element not seen before');\n        }\n        delete this._map[key._uuid];\n      }\n    }]);\n\n    return ElementMap;\n  })();\n\n  exports['default'] = ElementMap;\n});","define('content-kit-editor/utils/element-utils', ['exports', 'content-kit-editor/utils/string-utils', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsStringUtils, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  function createDiv(className) {\n    var div = document.createElement('div');\n    if (className) {\n      div.className = className;\n    }\n    return div;\n  }\n\n  function hideElement(element) {\n    element.style.display = 'none';\n  }\n\n  function showElement(element) {\n    element.style.display = 'block';\n  }\n\n  function swapElements(elementToShow, elementToHide) {\n    hideElement(elementToHide);\n    showElement(elementToShow);\n  }\n\n  function getEventTargetMatchingTag(tagName, target, container) {\n    tagName = (0, _contentKitEditorUtilsDomUtils.normalizeTagName)(tagName);\n    // Traverses up DOM from an event target to find the node matching specifed tag\n    while (target && target !== container) {\n      if ((0, _contentKitEditorUtilsDomUtils.normalizeTagName)(target.tagName) === tagName) {\n        return target;\n      }\n      target = target.parentNode;\n    }\n  }\n\n  function getElementRelativeOffset(element) {\n    var offset = { left: 0, top: -window.pageYOffset };\n    var offsetParent = element.offsetParent;\n    var offsetParentPosition = window.getComputedStyle(offsetParent).position;\n    var offsetParentRect;\n\n    if (offsetParentPosition === 'relative') {\n      offsetParentRect = offsetParent.getBoundingClientRect();\n      offset.left = offsetParentRect.left;\n      offset.top = offsetParentRect.top;\n    }\n    return offset;\n  }\n\n  function getElementComputedStyleNumericProp(element, prop) {\n    return parseFloat(window.getComputedStyle(element)[prop]);\n  }\n\n  function positionElementToRect(element, rect, topOffset, leftOffset) {\n    var relativeOffset = getElementRelativeOffset(element);\n    var style = element.style;\n    var round = Math.round;\n    var left, top;\n\n    topOffset = topOffset || 0;\n    leftOffset = leftOffset || 0;\n    left = round(rect.left - relativeOffset.left - leftOffset);\n    top = round(rect.top - relativeOffset.top - topOffset);\n    style.left = left + 'px';\n    style.top = top + 'px';\n    return { left: left, top: top };\n  }\n\n  function positionElementHorizontallyCenteredToRect(element, rect, topOffset) {\n    var horizontalCenter = element.offsetWidth / 2 - rect.width / 2;\n    return positionElementToRect(element, rect, topOffset, horizontalCenter);\n  }\n\n  function positionElementCenteredAbove(element, aboveElement) {\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginBottom');\n    return positionElementHorizontallyCenteredToRect(element, aboveElement.getBoundingClientRect(), element.offsetHeight + elementMargin);\n  }\n\n  function positionElementCenteredBelow(element, belowElement) {\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginTop');\n    return positionElementHorizontallyCenteredToRect(element, belowElement.getBoundingClientRect(), -element.offsetHeight - elementMargin);\n  }\n\n  function positionElementCenteredIn(element, inElement) {\n    var verticalCenter = inElement.offsetHeight / 2 - element.offsetHeight / 2;\n    return positionElementHorizontallyCenteredToRect(element, inElement.getBoundingClientRect(), -verticalCenter);\n  }\n\n  function positionElementToLeftOf(element, leftOfElement) {\n    var verticalCenter = leftOfElement.offsetHeight / 2 - element.offsetHeight / 2;\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginRight');\n    return positionElementToRect(element, leftOfElement.getBoundingClientRect(), -verticalCenter, element.offsetWidth + elementMargin);\n  }\n\n  function positionElementToRightOf(element, rightOfElement) {\n    var verticalCenter = rightOfElement.offsetHeight / 2 - element.offsetHeight / 2;\n    var elementMargin = getElementComputedStyleNumericProp(element, 'marginLeft');\n    var rightOfElementRect = rightOfElement.getBoundingClientRect();\n    return positionElementToRect(element, rightOfElementRect, -verticalCenter, -rightOfElement.offsetWidth - elementMargin);\n  }\n\n  function getData(element, name) {\n    if (element.dataset) {\n      return element.dataset[name];\n    } else {\n      var dataName = (0, _contentKitEditorUtilsStringUtils.dasherize)(name);\n      return element.getAttribute(dataName);\n    }\n  }\n\n  function setData(element, name, value) {\n    if (element.dataset) {\n      element.dataset[name] = value;\n    } else {\n      var dataName = (0, _contentKitEditorUtilsStringUtils.dasherize)(name);\n      return element.setAttribute(dataName, value);\n    }\n  }\n\n  exports.getData = getData;\n  exports.setData = setData;\n  exports.createDiv = createDiv;\n  exports.hideElement = hideElement;\n  exports.showElement = showElement;\n  exports.swapElements = swapElements;\n  exports.getEventTargetMatchingTag = getEventTargetMatchingTag;\n  exports.getElementRelativeOffset = getElementRelativeOffset;\n  exports.getElementComputedStyleNumericProp = getElementComputedStyleNumericProp;\n  exports.positionElementToRect = positionElementToRect;\n  exports.positionElementHorizontallyCenteredToRect = positionElementHorizontallyCenteredToRect;\n  exports.positionElementCenteredAbove = positionElementCenteredAbove;\n  exports.positionElementCenteredBelow = positionElementCenteredBelow;\n  exports.positionElementCenteredIn = positionElementCenteredIn;\n  exports.positionElementToLeftOf = positionElementToLeftOf;\n  exports.positionElementToRightOf = positionElementToRightOf;\n});","define(\"content-kit-editor/utils/event-emitter\", [\"exports\"], function (exports) {\n  // Based on https://github.com/jeromeetienne/microevent.js/blob/master/microevent.js\n  // See also: https://github.com/allouis/minivents/blob/master/minivents.js\n\n  \"use strict\";\n\n  var EventEmitter = {\n    on: function on(type, handler) {\n      var events = this.__events = this.__events || {};\n      events[type] = events[type] || [];\n      events[type].push(handler);\n    },\n    off: function off(type, handler) {\n      var events = this.__events = this.__events || {};\n      if (type in events) {\n        events[type].splice(events[type].indexOf(handler), 1);\n      }\n    },\n    trigger: function trigger(type) {\n      var events = this.__events = this.__events || {};\n      var eventForTypeCount, i;\n      if (type in events) {\n        eventForTypeCount = events[type].length;\n        for (i = 0; i < eventForTypeCount; i++) {\n          events[type][i].apply(this, Array.prototype.slice.call(arguments, 1));\n        }\n      }\n    }\n  };\n\n  exports[\"default\"] = EventEmitter;\n});","define('content-kit-editor/utils/event-listener', ['exports', 'content-kit-editor/utils/array-utils'], function (exports, _contentKitEditorUtilsArrayUtils) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var EventListenerMixin = (function () {\n    function EventListenerMixin() {\n      _classCallCheck(this, EventListenerMixin);\n    }\n\n    _createClass(EventListenerMixin, [{\n      key: 'addEventListener',\n      value: function addEventListener(context, eventName, listener) {\n        if (!this._eventListeners) {\n          this._eventListeners = [];\n        }\n        context.addEventListener(eventName, listener);\n        this._eventListeners.push([context, eventName, listener]);\n      }\n    }, {\n      key: 'removeAllEventListeners',\n      value: function removeAllEventListeners() {\n        var listeners = this._eventListeners || [];\n        listeners.forEach(function (_ref) {\n          var _ref2 = _toArray(_ref);\n\n          var context = _ref2[0];\n\n          var args = _ref2.slice(1);\n\n          context.removeEventListener.apply(context, _toConsumableArray(args));\n        });\n      }\n\n      // This is primarily useful for programmatically simulating events on the\n      // editor from the tests.\n    }, {\n      key: 'triggerEvent',\n      value: function triggerEvent(context, eventName, event) {\n        var matches = (0, _contentKitEditorUtilsArrayUtils.filter)(this._eventListeners, function (_ref3) {\n          var _ref32 = _slicedToArray(_ref3, 2);\n\n          var _context = _ref32[0];\n          var _eventName = _ref32[1];\n\n          return context === _context && eventName === _eventName;\n        });\n        matches.forEach(function (_ref4) {\n          var _ref42 = _slicedToArray(_ref4, 3);\n\n          var context = _ref42[0];\n          var eventName = _ref42[1];\n          var listener = _ref42[2];\n\n          listener.call(context, event);\n        });\n      }\n    }]);\n\n    return EventListenerMixin;\n  })();\n\n  exports['default'] = EventListenerMixin;\n});","define('content-kit-editor/utils/http-utils', ['exports'], function (exports) {\n  'use strict';\n\n  function createXHR(options) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(options.method, options.url);\n    xhr.onload = function () {\n      var response = xhr.responseText;\n      if (xhr.status === 200) {\n        return options.success.call(this, response);\n      }\n      options.error.call(this, response);\n    };\n    xhr.onerror = function (error) {\n      options.error.call(this, error);\n    };\n    return xhr;\n  }\n\n  function xhrPost(options) {\n    options.method = 'POST';\n    var xhr = createXHR(options);\n    var formData = new FormData();\n    formData.append('file', options.data);\n    try {\n      xhr.send(formData);\n    } catch (error) {}\n  }\n\n  function responseJSON(jsonString) {\n    if (!jsonString) {\n      return null;\n    }\n    try {\n      return window.JSON.parse(jsonString);\n    } catch (e) {\n      return jsonString;\n    }\n  }\n\n  // --------------------------------------------\n\n  function FileUploader(options) {\n    options = options || {};\n    var url = options.url;\n    var maxFileSize = options.maxFileSize;\n    if (url) {\n      this.url = url;\n    } else {\n      throw new Error('FileUploader: setting the `url` to an upload service is required');\n    }\n    if (maxFileSize) {\n      this.maxFileSize = maxFileSize;\n    }\n  }\n\n  FileUploader.prototype.upload = function (options) {\n    if (!options) {\n      return;\n    }\n\n    var fileInput = options.fileInput;\n    var file = options.file || fileInput && fileInput.files && fileInput.files[0];\n    var callback = options.complete;\n    var maxFileSize = this.maxFileSize;\n    if (!file || !(file instanceof window.File)) {\n      return;\n    }\n\n    if (maxFileSize && file.size > maxFileSize) {\n      if (callback) {\n        callback.call(this, null, { message: 'max file size is ' + maxFileSize + ' bytes' });\n      }\n      return;\n    }\n\n    xhrPost({\n      url: this.url,\n      data: file,\n      success: function success(response) {\n        if (callback) {\n          callback.call(this, responseJSON(response));\n        }\n      },\n      error: function error(_error) {\n        if (callback) {\n          callback.call(this, null, responseJSON(_error));\n        }\n      }\n    });\n  };\n\n  exports.FileUploader = FileUploader;\n});","define('content-kit-editor/utils/key', ['exports', 'content-kit-editor/utils/keycodes'], function (exports, _contentKitEditorUtilsKeycodes) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var DIRECTION = {\n    FORWARD: 1,\n    BACKWARD: -1\n  };\n\n  exports.DIRECTION = DIRECTION;\n  var MODIFIERS = {\n    META: 1, // also called \"command\" on OS X\n    CTRL: 2,\n    SHIFT: 3\n  };\n\n  exports.MODIFIERS = MODIFIERS;\n  /**\n   * An abstraction around a KeyEvent\n   * that key listeners in the editor can use\n   * to determine what sort of key was pressed\n   */\n  var Key = (function () {\n    function Key(event) {\n      _classCallCheck(this, Key);\n\n      this.keyCode = event.keyCode;\n      this.event = event;\n    }\n\n    _createClass(Key, [{\n      key: 'isEscape',\n      value: function isEscape() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].ESC;\n      }\n    }, {\n      key: 'isDelete',\n      value: function isDelete() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].BACKSPACE || this.keyCode === _contentKitEditorUtilsKeycodes['default'].DELETE;\n      }\n    }, {\n      key: 'isForwardDelete',\n      value: function isForwardDelete() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].DELETE;\n      }\n    }, {\n      key: 'isSpace',\n      value: function isSpace() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].SPACE;\n      }\n    }, {\n      key: 'isEnter',\n      value: function isEnter() {\n        return this.keyCode === _contentKitEditorUtilsKeycodes['default'].ENTER;\n      }\n    }, {\n      key: 'isShift',\n      value: function isShift() {\n        return this.hasModifier(MODIFIERS.SHIFT);\n      }\n    }, {\n      key: 'hasModifier',\n      value: function hasModifier(modifier) {\n        switch (modifier) {\n          case MODIFIERS.META:\n            return this.metaKey;\n          case MODIFIERS.CTRL:\n            return this.ctrlKey;\n          case MODIFIERS.SHIFT:\n            return this.shiftKey;\n          default:\n            throw new Error('Cannot check for unknown modifier ' + modifier);\n        }\n      }\n    }, {\n      key: 'isChar',\n      value: function isChar(string) {\n        return this.keyCode === string.toUpperCase().charCodeAt(0);\n      }\n\n      /**\n       * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Printable_keys_in_standard_position\n       *   and http://stackoverflow.com/a/12467610/137784\n       */\n    }, {\n      key: 'isPrintable',\n      value: function isPrintable() {\n        if (this.ctrlKey || this.metaKey) {\n          return false;\n        }\n\n        var code = this.keyCode;\n\n        return code >= _contentKitEditorUtilsKeycodes['default']['0'] && code <= _contentKitEditorUtilsKeycodes['default']['9'] || // number keys\n        this.isSpace() || this.isEnter() || code >= _contentKitEditorUtilsKeycodes['default'].A && code <= _contentKitEditorUtilsKeycodes['default'].Z || // letter keys\n        code >= _contentKitEditorUtilsKeycodes['default'].NUMPAD_0 && code <= _contentKitEditorUtilsKeycodes['default'].NUMPAD_9 || // numpad keys\n        code >= _contentKitEditorUtilsKeycodes['default'][';'] && code <= _contentKitEditorUtilsKeycodes['default']['`'] || // punctuation\n        code >= _contentKitEditorUtilsKeycodes['default']['['] && code <= _contentKitEditorUtilsKeycodes['default']['\"'] ||\n        // FIXME the IME action seems to get lost when we issue an `editor.deleteSelection`\n        // before it (in Chrome)\n        code === _contentKitEditorUtilsKeycodes['default'].IME;\n      }\n    }, {\n      key: 'direction',\n      get: function get() {\n        return this.isForwardDelete() ? DIRECTION.FORWARD : DIRECTION.BACKWARD;\n      }\n    }, {\n      key: 'ctrlKey',\n      get: function get() {\n        return this.event.ctrlKey;\n      }\n    }, {\n      key: 'metaKey',\n      get: function get() {\n        return this.event.metaKey;\n      }\n    }], [{\n      key: 'fromEvent',\n      value: function fromEvent(event) {\n        return new Key(event);\n      }\n    }]);\n\n    return Key;\n  })();\n\n  exports['default'] = Key;\n});","define('content-kit-editor/utils/keycodes', ['exports'], function (exports) {\n  'use strict';\n\n  exports['default'] = {\n    BACKSPACE: 8,\n    SPACE: 32,\n    ENTER: 13,\n    ESC: 27,\n    DELETE: 46,\n    '0': 48,\n    '9': 57,\n    A: 65,\n    Z: 90,\n    'NUMPAD_0': 186,\n    'NUMPAD_9': 111,\n    ';': 186,\n    '`': 192,\n    '[': 219,\n    '\"': 222,\n\n    // Input Method Editor uses multiple keystrokes to display characters.\n    // Example on mac: press option-i then i. This fires 2 key events in Chrome\n    // with keyCode 229 and displays ˆ and then î.\n    // See http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html#fixed-virtual-key-codes\n    IME: 229\n  };\n});","define(\"content-kit-editor/utils/linked-item\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var LinkedItem = function LinkedItem() {\n    _classCallCheck(this, LinkedItem);\n\n    this.next = null;\n    this.prev = null;\n  };\n\n  exports[\"default\"] = LinkedItem;\n});","define('content-kit-editor/utils/linked-list', ['exports'], function (exports) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var LinkedList = (function () {\n    function LinkedList(options) {\n      _classCallCheck(this, LinkedList);\n\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n\n      if (options) {\n        var adoptItem = options.adoptItem;\n        var freeItem = options.freeItem;\n\n        this._adoptItem = adoptItem;\n        this._freeItem = freeItem;\n      }\n    }\n\n    _createClass(LinkedList, [{\n      key: 'adoptItem',\n      value: function adoptItem(item) {\n        if (this._adoptItem) {\n          this._adoptItem(item);\n        }\n      }\n    }, {\n      key: 'freeItem',\n      value: function freeItem(item) {\n        if (this._freeItem) {\n          this._freeItem(item);\n        }\n      }\n    }, {\n      key: 'prepend',\n      value: function prepend(item) {\n        this.insertBefore(item, this.head);\n      }\n    }, {\n      key: 'append',\n      value: function append(item) {\n        this.insertBefore(item, null);\n      }\n    }, {\n      key: 'insertAfter',\n      value: function insertAfter(item, prevItem) {\n        var nextItem = null;\n        if (prevItem) {\n          nextItem = prevItem.next;\n        } else {\n          nextItem = this.head;\n        }\n        this.insertBefore(item, nextItem);\n      }\n    }, {\n      key: 'insertBefore',\n      value: function insertBefore(item, nextItem) {\n        if (item.next || item.prev || this.head === item) {\n          throw new Error('Cannot insert an item into a list if it is already in a list');\n        }\n        this.adoptItem(item);\n\n        if (nextItem && nextItem.prev) {\n          // middle of the items\n          var prevItem = nextItem.prev;\n          item.next = nextItem;\n          nextItem.prev = item;\n          item.prev = prevItem;\n          prevItem.next = item;\n        } else if (nextItem) {\n          // first item\n          if (this.head === nextItem) {\n            item.next = nextItem;\n            nextItem.prev = item;\n          } else {\n            this.tail = item;\n          }\n          this.head = item;\n        } else {\n          // last item\n          if (this.tail) {\n            item.prev = this.tail;\n            this.tail.next = item;\n          }\n          if (!this.head) {\n            this.head = item;\n          }\n          this.tail = item;\n        }\n        this.length++;\n      }\n    }, {\n      key: 'remove',\n      value: function remove(item) {\n        this.freeItem(item);\n\n        var didRemove = false;\n        if (item.next && item.prev) {\n          // Middle of the list\n          item.next.prev = item.prev;\n          item.prev.next = item.next;\n          didRemove = true;\n        } else {\n          if (item === this.head) {\n            // Head of the list\n            if (item.next) {\n              item.next.prev = null;\n            }\n            this.head = item.next;\n            didRemove = true;\n          }\n          if (item === this.tail) {\n            // Tail of the list\n            if (item.prev) {\n              item.prev.next = null;\n            }\n            this.tail = item.prev;\n            didRemove = true;\n          }\n        }\n        if (didRemove) {\n          this.length--;\n        }\n        item.prev = null;\n        item.next = null;\n      }\n    }, {\n      key: 'forEach',\n      value: function forEach(callback) {\n        var item = this.head;\n        var index = 0;\n        while (item) {\n          callback(item, index);\n          index++;\n          item = item.next;\n        }\n      }\n    }, {\n      key: 'walk',\n      value: function walk(startItem, endItem, callback) {\n        var item = startItem || this.head;\n        while (item) {\n          callback(item);\n          if (item === endItem) {\n            break;\n          }\n          item = item.next;\n        }\n      }\n    }, {\n      key: 'readRange',\n      value: function readRange(startItem, endItem) {\n        var items = [];\n        this.walk(startItem, endItem, function (item) {\n          items.push(item);\n        });\n        return items;\n      }\n    }, {\n      key: 'toArray',\n      value: function toArray() {\n        return this.readRange();\n      }\n    }, {\n      key: 'detect',\n      value: function detect(callback) {\n        var item = arguments.length <= 1 || arguments[1] === undefined ? this.head : arguments[1];\n\n        while (item) {\n          if (callback(item)) {\n            return item;\n          }\n          item = item.next;\n        }\n      }\n    }, {\n      key: 'objectAt',\n      value: function objectAt(targetIndex) {\n        var index = -1;\n        return this.detect(function () {\n          index++;\n          return targetIndex === index;\n        });\n      }\n    }, {\n      key: 'splice',\n      value: function splice(targetItem, removalCount, newItems) {\n        var _this = this;\n\n        var item = targetItem;\n        var nextItem = item.next;\n        var count = 0;\n        while (item && count < removalCount) {\n          count++;\n          nextItem = item.next;\n          this.remove(item);\n          item = nextItem;\n        }\n        newItems.forEach(function (newItem) {\n          _this.insertBefore(newItem, nextItem);\n        });\n      }\n    }, {\n      key: 'removeBy',\n      value: function removeBy(conditionFn) {\n        var item = this.head;\n        while (item) {\n          var nextItem = item.next;\n\n          if (conditionFn(item)) {\n            this.remove(item);\n          }\n\n          item = nextItem;\n        }\n      }\n    }, {\n      key: 'isEmpty',\n      get: function get() {\n        return this.length === 0;\n      }\n    }]);\n\n    return LinkedList;\n  })();\n\n  exports['default'] = LinkedList;\n});","define('content-kit-editor/utils/mixin', ['exports'], function (exports) {\n  'use strict';\n\n  exports['default'] = mixin;\n  var CONSTRUCTOR_FN_NAME = 'constructor';\n\n  function mixin(target, source) {\n    target = target.prototype;\n    // Fallback to just `source` to allow mixing in a plain object (pojo)\n    source = source.prototype || source;\n\n    Object.getOwnPropertyNames(source).forEach(function (name) {\n      if (name !== CONSTRUCTOR_FN_NAME) {\n        var descriptor = Object.getOwnPropertyDescriptor(source, name);\n\n        Object.defineProperty(target, name, descriptor);\n      }\n    });\n  }\n});","define('content-kit-editor/utils/selection-utils', ['exports', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  function clearSelection() {\n    // FIXME-IE ensure this works on IE 9. It works on IE10.\n    window.getSelection().removeAllRanges();\n  }\n\n  function comparePosition(selection) {\n    var anchorNode = selection.anchorNode;\n    var focusNode = selection.focusNode;\n    var anchorOffset = selection.anchorOffset;\n    var focusOffset = selection.focusOffset;\n\n    var headNode = undefined,\n        tailNode = undefined,\n        headOffset = undefined,\n        tailOffset = undefined;\n\n    var position = anchorNode.compareDocumentPosition(focusNode);\n\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      headNode = anchorNode;tailNode = focusNode;\n      headOffset = anchorOffset;tailOffset = focusOffset;\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      headNode = focusNode;tailNode = anchorNode;\n      headOffset = focusOffset;tailOffset = anchorOffset;\n    } else {\n      // same node\n      headNode = anchorNode;\n      tailNode = focusNode;\n      headOffset = Math.min(anchorOffset, focusOffset);\n      tailOffset = Math.max(anchorOffset, focusOffset);\n    }\n\n    return { headNode: headNode, headOffset: headOffset, tailNode: tailNode, tailOffset: tailOffset };\n  }\n\n  function restoreRange(range) {\n    clearSelection();\n    var selection = window.getSelection();\n    selection.addRange(range);\n  }\n\n  exports.restoreRange = restoreRange;\n  exports.containsNode = _contentKitEditorUtilsDomUtils.containsNode;\n  exports.clearSelection = clearSelection;\n  exports.comparePosition = comparePosition;\n});","define(\"content-kit-editor/utils/set\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n  var Set = (function () {\n    function Set() {\n      var _this = this;\n\n      var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n      _classCallCheck(this, Set);\n\n      this.items = [];\n      items.forEach(function (i) {\n        return _this.add(i);\n      });\n    }\n\n    _createClass(Set, [{\n      key: \"add\",\n      value: function add(item) {\n        if (!this.has(item)) {\n          this.items.push(item);\n        }\n      }\n    }, {\n      key: \"has\",\n      value: function has(item) {\n        return this.items.indexOf(item) !== -1;\n      }\n    }, {\n      key: \"toArray\",\n      value: function toArray() {\n        return this.items;\n      }\n    }]);\n\n    return Set;\n  })();\n\n  exports[\"default\"] = Set;\n});","define('content-kit-editor/utils/string-utils', ['exports'], function (exports) {\n  /*\n   * @param {String} string\n   * @return {String} a dasherized string. 'modelIndex' -> 'model-index', etc\n   */\n  'use strict';\n\n  exports.dasherize = dasherize;\n  exports.capitalize = capitalize;\n  exports.startsWith = startsWith;\n  exports.endsWith = endsWith;\n\n  function dasherize(string) {\n    return string.replace(/[A-Z]/g, function (match, offset) {\n      var lower = match.toLowerCase();\n\n      return offset === 0 ? lower : '-' + lower;\n    });\n  }\n\n  function capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }\n\n  function startsWith(string, character) {\n    return string.charAt(0) === character;\n  }\n\n  function endsWith(string, character) {\n    return string.charAt(string.length - 1) === character;\n  }\n});","define('content-kit-editor/views/embed-intent', ['exports', 'content-kit-editor/views/view', 'content-kit-editor/views/toolbar', 'content-kit-editor/utils/element-utils', 'content-kit-editor/commands/unordered-list', 'content-kit-editor/commands/ordered-list', 'content-kit-editor/commands/image', 'content-kit-editor/commands/card'], function (exports, _contentKitEditorViewsView, _contentKitEditorViewsToolbar, _contentKitEditorUtilsElementUtils, _contentKitEditorCommandsUnorderedList, _contentKitEditorCommandsOrderedList, _contentKitEditorCommandsImage, _contentKitEditorCommandsCard) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var LayoutStyle = {\n    GUTTER: 1,\n    CENTERED: 2\n  };\n\n  function computeLayoutStyle(rootElement) {\n    if (rootElement.getBoundingClientRect().left > 100) {\n      return LayoutStyle.GUTTER;\n    }\n    return LayoutStyle.CENTERED;\n  }\n\n  var EmbedIntent = (function (_View) {\n    _inherits(EmbedIntent, _View);\n\n    function EmbedIntent() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, EmbedIntent);\n\n      options.classNames = ['ck-embed-intent'];\n      _get(Object.getPrototypeOf(EmbedIntent.prototype), 'constructor', this).call(this, options);\n      this.rootElement = options.rootElement;\n\n      this.isActive = false;\n      this.editor = options.editor;\n      this.button = document.createElement('button');\n      this.button.className = 'ck-embed-intent-btn';\n      this.button.title = 'Insert image or embed...';\n      this.element.appendChild(this.button);\n\n      var commands = [new _contentKitEditorCommandsImage['default'](), new _contentKitEditorCommandsCard['default'](), new _contentKitEditorCommandsUnorderedList['default'](this.editor), new _contentKitEditorCommandsOrderedList['default'](this.editor)];\n\n      this.addEventListener(this.button, 'click', function (e) {\n        if (_this.isActive) {\n          _this.deactivate();\n        } else {\n          _this.activate();\n        }\n        e.stopPropagation();\n      });\n\n      this.toolbar = new _contentKitEditorViewsToolbar['default']({\n        container: this.element,\n        embedIntent: this,\n        editor: this.editor,\n        commands: commands,\n        direction: _contentKitEditorViewsToolbar['default'].Direction.RIGHT\n      });\n\n      var embedIntentHandler = function embedIntentHandler() {\n        var editor = _this.editor;\n\n        if (_this._isDestroyed || editor._isDestroyed) {\n          return;\n        }\n\n        var showElement = undefined;\n\n        var headSection = _this.editor.cursor.offsets.headSection;\n\n        var headElement = headSection && headSection.renderNode && headSection.renderNode.element;\n        if (headElement && headSection.isBlank) {\n          showElement = headElement;\n        } else if (editor.post.isBlank) {\n          showElement = editor.post.renderNode.element;\n        }\n\n        if (showElement) {\n          _this.showAt(showElement);\n        } else {\n          _this.hide();\n        }\n      };\n\n      this.addEventListener(this.rootElement, 'keyup', embedIntentHandler);\n      this.addEventListener(document, 'click', function () {\n        setTimeout(embedIntentHandler);\n      });\n      this.addEventListener(window, 'resize', function () {\n        _this.reposition();\n      });\n    }\n\n    _createClass(EmbedIntent, [{\n      key: 'hide',\n      value: function hide() {\n        if (_get(Object.getPrototypeOf(EmbedIntent.prototype), 'hide', this).call(this)) {\n          this.deactivate();\n        }\n      }\n    }, {\n      key: 'showAt',\n      value: function showAt(node) {\n        this.atNode = node;\n        this.show();\n        this.deactivate();\n        this.reposition();\n      }\n    }, {\n      key: 'reposition',\n      value: function reposition() {\n        if (!this.isShowing) {\n          return;\n        }\n        if (computeLayoutStyle(this.rootElement) === LayoutStyle.GUTTER) {\n          (0, _contentKitEditorUtilsElementUtils.positionElementToLeftOf)(this.element, this.atNode);\n        } else {\n          (0, _contentKitEditorUtilsElementUtils.positionElementCenteredIn)(this.element, this.atNode);\n        }\n      }\n    }, {\n      key: 'activate',\n      value: function activate() {\n        if (this.isActive) {\n          return;\n        }\n\n        this.addClass('activated');\n        this.toolbar.show();\n        this.isActive = true;\n      }\n    }, {\n      key: 'deactivate',\n      value: function deactivate() {\n        if (!this.isActive) {\n          return;\n        }\n\n        this.removeClass('activated');\n        this.toolbar.hide();\n        this.isActive = false;\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.toolbar.destroy();\n        _get(Object.getPrototypeOf(EmbedIntent.prototype), 'destroy', this).call(this);\n      }\n    }]);\n\n    return EmbedIntent;\n  })(_contentKitEditorViewsView['default']);\n\n  exports['default'] = EmbedIntent;\n});","define('content-kit-editor/views/message', ['exports', 'content-kit-editor/views/view', 'content-kit-utils'], function (exports, _contentKitEditorViewsView, _contentKitUtils) {\n  'use strict';\n\n  var defaultClassNames = ['ck-message'];\n\n  function Message(options) {\n    options = options || {};\n    options.classNames = defaultClassNames;\n    _contentKitEditorViewsView['default'].call(this, options);\n  }\n  (0, _contentKitUtils.inherit)(Message, _contentKitEditorViewsView['default']);\n\n  function show(view, message) {\n    view.element.innerHTML = message;\n    Message._super.prototype.show.call(view);\n    setTimeout(function () {\n      view.hide();\n    }, 3200);\n  }\n\n  Message.prototype.showInfo = function (message) {\n    this.setClasses(defaultClassNames);\n    show(this, message);\n  };\n\n  Message.prototype.showError = function (message) {\n    this.addClass('ck-message-error');\n    show(this, message);\n  };\n\n  exports['default'] = Message;\n});","define('content-kit-editor/views/prompt', ['exports', 'content-kit-editor/views/view', 'content-kit-editor/utils/selection-utils', 'content-kit-editor/utils/element-utils', 'content-kit-editor/utils/key'], function (exports, _contentKitEditorViewsView, _contentKitEditorUtilsSelectionUtils, _contentKitEditorUtilsElementUtils, _contentKitEditorUtilsKey) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var container = document.body;\n  var hiliter = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-editor-hilite');\n\n  function positionHiliteRange(range) {\n    var rect = range.getBoundingClientRect();\n    var style = hiliter.style;\n    style.width = rect.width + 'px';\n    style.height = rect.height + 'px';\n    (0, _contentKitEditorUtilsElementUtils.positionElementToRect)(hiliter, rect);\n  }\n\n  var Prompt = (function (_View) {\n    _inherits(Prompt, _View);\n\n    function Prompt(options) {\n      var _this = this;\n\n      _classCallCheck(this, Prompt);\n\n      options.tagName = 'input';\n      _get(Object.getPrototypeOf(Prompt.prototype), 'constructor', this).call(this, options);\n      this.toolbar = options.toolbar;\n\n      this.element.placeholder = options.placeholder || '';\n      this.addEventListener(this.element, 'click', function (e) {\n        // prevents closing prompt when clicking input\n        e.stopPropagation();\n      });\n      this.addEventListener(this.element, 'keyup', function (e) {\n        var key = _contentKitEditorUtilsKey['default'].fromEvent(e);\n        var entry = _this.element.value;\n\n        if (entry && _this.range && !key.isShift() && key.isEnter()) {\n          (0, _contentKitEditorUtilsSelectionUtils.restoreRange)(_this.range);\n          _this.doComplete(entry);\n        }\n      });\n\n      this.addEventListener(window, 'resize', function () {\n        var activeHilite = hiliter.parentNode;\n        var range = _this.range;\n        if (activeHilite && range) {\n          positionHiliteRange(range);\n        }\n      });\n    }\n\n    _createClass(Prompt, [{\n      key: 'doComplete',\n      value: function doComplete(value) {\n        this.hide();\n        this.onComplete(value);\n        this.toolbar.hide();\n      }\n    }, {\n      key: 'show',\n      value: function show() {\n        var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n        var toolbar = this.toolbar;\n\n        toolbar.displayPrompt(this);\n\n        this.onComplete = callback;\n        var element = this.element;\n        var selection = window.getSelection();\n        var range = selection && selection.rangeCount && selection.getRangeAt(0);\n        element.value = null;\n        this.range = range || null;\n\n        if (range) {\n          container.appendChild(hiliter);\n          positionHiliteRange(this.range);\n          setTimeout(function () {\n            // defer focus (disrupts mouseup events)\n            element.focus();\n          });\n        }\n      }\n    }, {\n      key: 'hide',\n      value: function hide() {\n        if (hiliter.parentNode) {\n          container.removeChild(hiliter);\n        }\n        this.toolbar.dismissPrompt();\n      }\n    }]);\n\n    return Prompt;\n  })(_contentKitEditorViewsView['default']);\n\n  exports['default'] = Prompt;\n});","define('content-kit-editor/views/reversible-prompt-button', ['exports', 'content-kit-editor/views/reversible-toolbar-button'], function (exports, _contentKitEditorViewsReversibleToolbarButton) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var PromptButton = (function (_ReversibleToolbarButton) {\n    _inherits(PromptButton, _ReversibleToolbarButton);\n\n    function PromptButton(command, editor) {\n      _classCallCheck(this, PromptButton);\n\n      _get(Object.getPrototypeOf(PromptButton.prototype), 'constructor', this).call(this, command, editor);\n    }\n\n    _createClass(PromptButton, [{\n      key: 'handleClick',\n      value: function handleClick(e) {\n        var _this = this;\n\n        e.stopPropagation();\n\n        var prompt = this.prompt;\n\n        if (!this.active) {\n          prompt.show(function () {\n            return _this.exec.apply(_this, arguments);\n          });\n        } else {\n          this.unexec();\n        }\n      }\n    }, {\n      key: 'prompt',\n      get: function get() {\n        return this.toolbar.prompt;\n      }\n    }]);\n\n    return PromptButton;\n  })(_contentKitEditorViewsReversibleToolbarButton['default']);\n\n  exports['default'] = PromptButton;\n});","define('content-kit-editor/views/reversible-toolbar-button', ['exports', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener', 'content-kit-editor/utils/dom-utils'], function (exports, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener, _contentKitEditorUtilsDomUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var ELEMENT_TYPE = 'button';\n  var BUTTON_CLASS_NAME = 'ck-toolbar-btn';\n  var ACTIVE_CLASS_NAME = 'active';\n\n  var ReversibleToolbarButton = (function () {\n    function ReversibleToolbarButton(command, editor) {\n      var _this = this;\n\n      _classCallCheck(this, ReversibleToolbarButton);\n\n      this.command = command;\n      this.editor = editor;\n      this.element = this.createElement();\n      this.active = false;\n\n      this.addEventListener(this.element, 'click', function (e) {\n        return _this.handleClick(e);\n      });\n      this.editor.on('selection', function () {\n        return _this.updateActiveState();\n      });\n      this.editor.on('selectionUpdated', function () {\n        return _this.updateActiveState();\n      });\n      this.editor.on('selectionEnded', function () {\n        return _this.updateActiveState();\n      });\n    }\n\n    // These are here to match the API of the ToolbarButton class\n\n    _createClass(ReversibleToolbarButton, [{\n      key: 'setInactive',\n      value: function setInactive() {}\n    }, {\n      key: 'setActive',\n      value: function setActive() {}\n    }, {\n      key: 'handleClick',\n      value: function handleClick(e) {\n        e.stopPropagation();\n\n        if (this.active) {\n          this.unexec();\n        } else {\n          this.exec();\n        }\n      }\n    }, {\n      key: 'exec',\n      value: function exec() {\n        var _command;\n\n        (_command = this.command).exec.apply(_command, arguments);\n      }\n    }, {\n      key: 'unexec',\n      value: function unexec() {\n        var _command2;\n\n        (_command2 = this.command).unexec.apply(_command2, arguments);\n      }\n    }, {\n      key: 'updateActiveState',\n      value: function updateActiveState() {\n        this.active = this.command.isActive();\n      }\n    }, {\n      key: 'createElement',\n      value: function createElement() {\n        var element = document.createElement(ELEMENT_TYPE);\n        element.className = BUTTON_CLASS_NAME;\n        element.innerHTML = this.command.button;\n        element.title = this.command.name;\n        return element;\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeAllEventListeners();\n      }\n    }, {\n      key: 'active',\n      set: function set(val) {\n        this._active = val;\n        var method = this._active ? _contentKitEditorUtilsDomUtils.addClassName : _contentKitEditorUtilsDomUtils.removeClassName;\n        method(this.element, ACTIVE_CLASS_NAME);\n      },\n      get: function get() {\n        return this._active;\n      }\n    }]);\n\n    return ReversibleToolbarButton;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(ReversibleToolbarButton, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = ReversibleToolbarButton;\n});","define('content-kit-editor/views/text-format-toolbar', ['exports', 'content-kit-editor/views/toolbar', 'content-kit-editor/views/reversible-toolbar-button', 'content-kit-editor/views/reversible-prompt-button', 'content-kit-editor/commands/bold', 'content-kit-editor/commands/italic', 'content-kit-editor/commands/link', 'content-kit-editor/commands/quote', 'content-kit-editor/commands/heading', 'content-kit-editor/commands/subheading'], function (exports, _contentKitEditorViewsToolbar, _contentKitEditorViewsReversibleToolbarButton, _contentKitEditorViewsReversiblePromptButton, _contentKitEditorCommandsBold, _contentKitEditorCommandsItalic, _contentKitEditorCommandsLink, _contentKitEditorCommandsQuote, _contentKitEditorCommandsHeading, _contentKitEditorCommandsSubheading) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  function makeButtons(editor) {\n    var headingCommand = new _contentKitEditorCommandsHeading['default'](editor);\n    var headingButton = new _contentKitEditorViewsReversibleToolbarButton['default'](headingCommand, editor);\n\n    var subheadingCommand = new _contentKitEditorCommandsSubheading['default'](editor);\n    var subheadingButton = new _contentKitEditorViewsReversibleToolbarButton['default'](subheadingCommand, editor);\n\n    var quoteCommand = new _contentKitEditorCommandsQuote['default'](editor);\n    var quoteButton = new _contentKitEditorViewsReversibleToolbarButton['default'](quoteCommand, editor);\n\n    var boldCommand = new _contentKitEditorCommandsBold['default'](editor);\n    var boldButton = new _contentKitEditorViewsReversibleToolbarButton['default'](boldCommand, editor);\n\n    var italicCommand = new _contentKitEditorCommandsItalic['default'](editor);\n    var italicButton = new _contentKitEditorViewsReversibleToolbarButton['default'](italicCommand, editor);\n\n    var linkCommand = new _contentKitEditorCommandsLink['default'](editor);\n    var linkButton = new _contentKitEditorViewsReversiblePromptButton['default'](linkCommand, editor);\n\n    return [headingButton, subheadingButton, quoteButton, boldButton, italicButton, linkButton];\n  }\n\n  var TextFormatToolbar = (function (_Toolbar) {\n    _inherits(TextFormatToolbar, _Toolbar);\n\n    function TextFormatToolbar() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, TextFormatToolbar);\n\n      _get(Object.getPrototypeOf(TextFormatToolbar.prototype), 'constructor', this).call(this, options);\n\n      this.editor.on('selection', function () {\n        return _this.handleSelection();\n      });\n      this.editor.on('selectionUpdated', function () {\n        return _this.handleSelection();\n      });\n      this.editor.on('selectionEnded', function () {\n        return _this.handleSelectionEnded();\n      });\n      this.editor.on('escapeKey', function () {\n        return _this.editor.cancelSelection();\n      });\n      this.addEventListener(window, 'resize', function () {\n        return _this.handleResize();\n      });\n\n      var buttons = makeButtons(this.editor);\n      buttons.forEach(function (b) {\n        return _this.addButton(b);\n      });\n    }\n\n    _createClass(TextFormatToolbar, [{\n      key: 'handleResize',\n      value: function handleResize() {\n        if (this.isShowing) {\n          this.positionToContent();\n        }\n      }\n    }, {\n      key: 'handleSelection',\n      value: function handleSelection() {\n        this.show();\n        this.updateForSelection();\n      }\n    }, {\n      key: 'handleSelectionEnded',\n      value: function handleSelectionEnded() {\n        this.hide();\n      }\n    }]);\n\n    return TextFormatToolbar;\n  })(_contentKitEditorViewsToolbar['default']);\n\n  exports['default'] = TextFormatToolbar;\n});","define('content-kit-editor/views/toolbar-button', ['exports', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener'], function (exports, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var ELEMENT_TYPE = 'button';\n  var BUTTON_CLASS_NAME = 'ck-toolbar-btn';\n\n  var ToolbarButton = (function () {\n    function ToolbarButton() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, ToolbarButton);\n\n      var toolbar = options.toolbar;\n      var command = options.command;\n\n      this.command = command;\n      this.element = this.createElement();\n      this.isActive = false;\n\n      this.addEventListener(this.element, 'click', function (e) {\n        command.exec();\n        if (toolbar.embedIntent) {\n          toolbar.embedIntent.hide();\n        }\n        e.stopPropagation();\n      });\n    }\n\n    _createClass(ToolbarButton, [{\n      key: 'createElement',\n      value: function createElement() {\n        var element = document.createElement(ELEMENT_TYPE);\n        element.className = BUTTON_CLASS_NAME;\n        element.innerHTML = this.command.button;\n        element.title = this.command.name;\n        return element;\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeAllEventListeners();\n      }\n    }]);\n\n    return ToolbarButton;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(ToolbarButton, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = ToolbarButton;\n});","define('content-kit-editor/views/toolbar', ['exports', 'content-kit-editor/views/view', 'content-kit-editor/views/prompt', 'content-kit-editor/views/toolbar-button', 'content-kit-editor/utils/element-utils'], function (exports, _contentKitEditorViewsView, _contentKitEditorViewsPrompt, _contentKitEditorViewsToolbarButton, _contentKitEditorUtilsElementUtils) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n  var ToolbarDirection = {\n    TOP: 1,\n    RIGHT: 2\n  };\n\n  var Toolbar = (function (_View) {\n    _inherits(Toolbar, _View);\n\n    function Toolbar() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, Toolbar);\n\n      options.classNames = ['ck-toolbar'];\n      _get(Object.getPrototypeOf(Toolbar.prototype), 'constructor', this).call(this, options);\n\n      this.prompt = new _contentKitEditorViewsPrompt['default']({ toolbar: this });\n\n      this.setDirection(options.direction || ToolbarDirection.TOP);\n      this.editor = options.editor || null;\n      this.embedIntent = options.embedIntent || null;\n      this.buttons = [];\n\n      this.contentElement = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-toolbar-content');\n      this.promptContainerElement = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-toolbar-prompt');\n      this.buttonContainerElement = (0, _contentKitEditorUtilsElementUtils.createDiv)('ck-toolbar-buttons');\n      this.contentElement.appendChild(this.promptContainerElement);\n      this.contentElement.appendChild(this.buttonContainerElement);\n      this.element.appendChild(this.contentElement);\n\n      (options.buttons || []).forEach(function (b) {\n        return _this.addButton(b);\n      });\n      (options.commands || []).forEach(function (c) {\n        return _this.addCommand(c);\n      });\n\n      // Closes prompt if displayed when changing selection\n      this.addEventListener(document, 'click', function () {\n        _this.dismissPrompt();\n      });\n    }\n\n    _createClass(Toolbar, [{\n      key: 'hide',\n      value: function hide() {\n        if (_get(Object.getPrototypeOf(Toolbar.prototype), 'hide', this).call(this)) {\n          var style = this.element.style;\n          style.left = '';\n          style.top = '';\n          this.dismissPrompt();\n        }\n      }\n    }, {\n      key: 'addCommand',\n      value: function addCommand(command) {\n        command.editor = this.editor;\n        command.embedIntent = this.embedIntent;\n        this.addButton(new _contentKitEditorViewsToolbarButton['default']({ command: command, toolbar: this }));\n      }\n    }, {\n      key: 'addButton',\n      value: function addButton(button) {\n        button.toolbar = this;\n        this.buttons.push(button);\n        this.buttonContainerElement.appendChild(button.element);\n      }\n    }, {\n      key: 'displayPrompt',\n      value: function displayPrompt(prompt) {\n        (0, _contentKitEditorUtilsElementUtils.swapElements)(this.promptContainerElement, this.buttonContainerElement);\n        this.promptContainerElement.appendChild(prompt.element);\n      }\n    }, {\n      key: 'dismissPrompt',\n      value: function dismissPrompt() {\n        (0, _contentKitEditorUtilsElementUtils.swapElements)(this.buttonContainerElement, this.promptContainerElement);\n        this.updateForSelection();\n      }\n    }, {\n      key: 'updateForSelection',\n      value: function updateForSelection() {\n        if (!this.isShowing) {\n          return;\n        }\n        var selection = window.getSelection(),\n            range = selection && selection.getRangeAt(0);\n        if (!range.collapsed) {\n          this.positionToContent(range);\n        }\n      }\n    }, {\n      key: 'positionToContent',\n      value: function positionToContent() {\n        var content = arguments.length <= 0 || arguments[0] === undefined ? window.getSelection().getRangeAt(0) : arguments[0];\n\n        var directions = ToolbarDirection;\n        var positioningMethod, position, sideEdgeOffset;\n        switch (this.direction) {\n          case directions.RIGHT:\n            positioningMethod = _contentKitEditorUtilsElementUtils.positionElementToRightOf;\n            break;\n          default:\n            positioningMethod = _contentKitEditorUtilsElementUtils.positionElementCenteredAbove;\n        }\n        position = positioningMethod(this.element, content);\n        sideEdgeOffset = Math.min(Math.max(10, position.left), document.body.clientWidth - this.element.offsetWidth - 10);\n        this.contentElement.style.transform = 'translateX(' + (sideEdgeOffset - position.left) + 'px)';\n      }\n    }, {\n      key: 'setDirection',\n      value: function setDirection(direction) {\n        this.direction = direction;\n        if (direction === ToolbarDirection.RIGHT) {\n          this.addClass('right');\n        } else {\n          this.removeClass('right');\n        }\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.buttons.forEach(function (b) {\n          return b.destroy();\n        });\n        this.prompt.destroy();\n        _get(Object.getPrototypeOf(Toolbar.prototype), 'destroy', this).call(this);\n      }\n    }]);\n\n    return Toolbar;\n  })(_contentKitEditorViewsView['default']);\n\n  Toolbar.Direction = ToolbarDirection;\n\n  exports['default'] = Toolbar;\n});","define('content-kit-editor/views/tooltip', ['exports', 'content-kit-editor/views/view', 'content-kit-utils', 'content-kit-editor/utils/element-utils'], function (exports, _contentKitEditorViewsView, _contentKitUtils, _contentKitEditorUtilsElementUtils) {\n  'use strict';\n\n  function Tooltip(options) {\n    var tooltip = this;\n    var rootElement = options.rootElement;\n    var delay = options.delay || 200;\n    var timeout;\n    options.classNames = ['ck-tooltip'];\n    _contentKitEditorViewsView['default'].call(tooltip, options);\n\n    this.addEventListener(rootElement, 'mouseover', function (e) {\n      var target = (0, _contentKitEditorUtilsElementUtils.getEventTargetMatchingTag)(options.showForTag, e.target, rootElement);\n      if (target && target.isContentEditable) {\n        timeout = setTimeout(function () {\n          tooltip.showLink(target.href, target);\n        }, delay);\n      }\n    });\n\n    this.addEventListener(rootElement, 'mouseout', function (e) {\n      clearTimeout(timeout);\n      var toElement = e.toElement || e.relatedTarget;\n      if (toElement && toElement.className !== tooltip.element.className) {\n        tooltip.hide();\n      }\n    });\n  }\n  (0, _contentKitUtils.inherit)(Tooltip, _contentKitEditorViewsView['default']);\n\n  Tooltip.prototype.showMessage = function (message, element) {\n    var tooltip = this;\n    var tooltipElement = tooltip.element;\n    tooltipElement.innerHTML = message;\n    tooltip.show();\n    (0, _contentKitEditorUtilsElementUtils.positionElementCenteredBelow)(tooltipElement, element);\n  };\n\n  Tooltip.prototype.showLink = function (link, element) {\n    var message = '<a href=\"' + link + '\" target=\"_blank\">' + link + '</a>';\n    this.showMessage(message, element);\n  };\n\n  exports['default'] = Tooltip;\n});","define('content-kit-editor/views/view', ['exports', 'content-kit-editor/utils/mixin', 'content-kit-editor/utils/event-listener'], function (exports, _contentKitEditorUtilsMixin, _contentKitEditorUtilsEventListener) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  function renderClasses(view) {\n    var classNames = view.classNames;\n    if (classNames && classNames.length) {\n      view.element.className = classNames.join(' ');\n    } else if (view.element.className) {\n      view.element.removeAttribute('className');\n    }\n  }\n\n  var View = (function () {\n    function View() {\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      _classCallCheck(this, View);\n\n      this.tagName = options.tagName || 'div';\n      this.classNames = options.classNames || [];\n      this.element = document.createElement(this.tagName);\n      this.container = options.container || document.body;\n      this.isShowing = false;\n      renderClasses(this);\n    }\n\n    _createClass(View, [{\n      key: 'show',\n      value: function show() {\n        var view = this;\n        if (!view.isShowing) {\n          view.container.appendChild(view.element);\n          view.isShowing = true;\n          return true;\n        }\n      }\n    }, {\n      key: 'hide',\n      value: function hide() {\n        if (this.isShowing) {\n          this.container.removeChild(this.element);\n          this.isShowing = false;\n          return true;\n        }\n      }\n    }, {\n      key: 'addClass',\n      value: function addClass(className) {\n        var index = this.classNames && this.classNames.indexOf(className);\n        if (index === -1) {\n          this.classNames.push(className);\n          renderClasses(this);\n        }\n      }\n    }, {\n      key: 'removeClass',\n      value: function removeClass(className) {\n        var index = this.classNames && this.classNames.indexOf(className);\n        if (index > -1) {\n          this.classNames.splice(index, 1);\n          renderClasses(this);\n        }\n      }\n    }, {\n      key: 'setClasses',\n      value: function setClasses(classNameArr) {\n        this.classNames = classNameArr;\n        renderClasses(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeAllEventListeners();\n        this.hide();\n        this._isDestroyed = true;\n      }\n    }]);\n\n    return View;\n  })();\n\n  (0, _contentKitEditorUtilsMixin['default'])(View, _contentKitEditorUtilsEventListener['default']);\n\n  exports['default'] = View;\n});","define(\"content-kit-utils/array-utils\", [\"exports\"], function (exports) {\n  /**\n   * Converts an array-like object (i.e. NodeList) to Array\n   * Note: could just use Array.prototype.slice but does not work in IE <= 8\n   */\n  \"use strict\";\n\n  function toArray(obj) {\n    var array = [];\n    var i = obj && obj.length >>> 0; // cast to Uint32\n    while (i--) {\n      array[i] = obj[i];\n    }\n    return array;\n  }\n\n  /**\n   * Computes the sum of values in a (sparse) array\n   */\n  function sumSparseArray(array) {\n    var sum = 0,\n        i;\n    for (i in array) {\n      // 'for in' is better for sparse arrays\n      if (array.hasOwnProperty(i)) {\n        sum += array[i];\n      }\n    }\n    return sum;\n  }\n\n  exports.toArray = toArray;\n  exports.sumSparseArray = sumSparseArray;\n});","define('content-kit-utils', ['exports', 'content-kit-utils/array-utils', 'content-kit-utils/node-utils', 'content-kit-utils/object-utils', 'content-kit-utils/string-utils'], function (exports, _contentKitUtilsArrayUtils, _contentKitUtilsNodeUtils, _contentKitUtilsObjectUtils, _contentKitUtilsStringUtils) {\n  'use strict';\n\n  exports.toArray = _contentKitUtilsArrayUtils.toArray;\n  exports.sumSparseArray = _contentKitUtilsArrayUtils.sumSparseArray;\n  exports.textOfNode = _contentKitUtilsNodeUtils.textOfNode;\n  exports.unwrapNode = _contentKitUtilsNodeUtils.unwrapNode;\n  exports.attributesForNode = _contentKitUtilsNodeUtils.attributesForNode;\n  exports.mergeWithOptions = _contentKitUtilsObjectUtils.mergeWithOptions;\n  exports.merge = _contentKitUtilsObjectUtils.merge;\n  exports.inherit = _contentKitUtilsObjectUtils.inherit;\n  exports.trim = _contentKitUtilsStringUtils.trim;\n  exports.trimLeft = _contentKitUtilsStringUtils.trimLeft;\n  exports.underscore = _contentKitUtilsStringUtils.underscore;\n  exports.sanitizeWhitespace = _contentKitUtilsStringUtils.sanitizeWhitespace;\n  exports.injectIntoString = _contentKitUtilsStringUtils.injectIntoString;\n\n  // needs a default export to be compatible with\n  // broccoli-multi-builder\n  exports['default'] = {};\n});","define('content-kit-utils/node-utils', ['exports', 'content-kit-utils/string-utils', 'content-kit-utils/array-utils'], function (exports, _contentKitUtilsStringUtils, _contentKitUtilsArrayUtils) {\n  'use strict';\n\n  /**\n   * Returns plain-text of a `Node`\n   */\n  function textOfNode(node) {\n    var text = node.textContent || node.innerText;\n    return text ? (0, _contentKitUtilsStringUtils.sanitizeWhitespace)(text) : '';\n  }\n\n  /**\n   * Replaces a `Node` with its children\n   */\n  function unwrapNode(node) {\n    if (node.hasChildNodes()) {\n      var children = (0, _contentKitUtilsArrayUtils.toArray)(node.childNodes);\n      var len = children.length;\n      var parent = node.parentNode,\n          i;\n      for (i = 0; i < len; i++) {\n        parent.insertBefore(children[i], node);\n      }\n    }\n  }\n\n  /**\n   * Extracts attributes of a `Node` to a hash of key/value pairs\n   */\n  function attributesForNode(node, blacklist) {\n    var attrs = node.attributes;\n    var len = attrs && attrs.length;\n    var i, attr, name, hash;\n\n    for (i = 0; i < len; i++) {\n      attr = attrs[i];\n      name = attr.name;\n      if (attr.specified && attr.value) {\n        if (blacklist && name in blacklist) {\n          continue;\n        }\n        hash = hash || {};\n        hash[name] = attr.value;\n      }\n    }\n    return hash;\n  }\n\n  exports.textOfNode = textOfNode;\n  exports.unwrapNode = unwrapNode;\n  exports.attributesForNode = attributesForNode;\n});","define(\"content-kit-utils/object-utils\", [\"exports\"], function (exports) {\n  /**\n   * Merges defaults/options into an Object\n   * Useful for constructors\n   */\n  \"use strict\";\n\n  function mergeWithOptions(original, updates, options) {\n    options = options || {};\n    for (var prop in updates) {\n      if (options.hasOwnProperty(prop)) {\n        original[prop] = options[prop];\n      } else if (updates.hasOwnProperty(prop)) {\n        original[prop] = updates[prop];\n      }\n    }\n    return original;\n  }\n\n  /**\n   * Merges properties of one object into another\n   */\n  function merge(original, updates) {\n    return mergeWithOptions(original, updates);\n  }\n\n  /**\n   * Prototype inheritance helper\n   */\n  function inherit(Subclass, Superclass) {\n    for (var key in Superclass) {\n      if (Superclass.hasOwnProperty(key)) {\n        Subclass[key] = Superclass[key];\n      }\n    }\n    Subclass.prototype = new Superclass();\n    Subclass.constructor = Subclass;\n    Subclass._super = Superclass;\n  }\n\n  exports.mergeWithOptions = mergeWithOptions;\n  exports.merge = merge;\n  exports.inherit = inherit;\n});","define('content-kit-utils/string-utils', ['exports'], function (exports) {\n  'use strict';\n\n  var RegExpTrim = /^\\s+|\\s+$/g;\n  var RegExpTrimLeft = /^\\s+/;\n  var RegExpWSChars = /(\\r\\n|\\n|\\r|\\t)/gm;\n  var RegExpMultiWS = /\\s+/g;\n  var RegExpNonAlphaNum = /[^a-zA-Z\\d]/g;\n\n  /**\n   * String.prototype.trim polyfill\n   * Removes whitespace at beginning and end of string\n   */\n  function trim(string) {\n    return string ? (string + '').replace(RegExpTrim, '') : '';\n  }\n\n  /**\n   * String.prototype.trimLeft polyfill\n   * Removes whitespace at beginning of string\n   */\n  function trimLeft(string) {\n    return string ? (string + '').replace(RegExpTrimLeft, '') : '';\n  }\n\n  /**\n   * Replaces non-alphanumeric chars with underscores\n   */\n  function underscore(string) {\n    return string ? trim(string + '').replace(RegExpNonAlphaNum, '_') : '';\n  }\n\n  /**\n   * Cleans line breaks, tabs, then multiple occuring whitespaces.\n   */\n  function sanitizeWhitespace(string) {\n    return string ? (string + '').replace(RegExpWSChars, '').replace(RegExpMultiWS, ' ') : '';\n  }\n\n  /**\n   * Injects a string into another string at the index specified\n   */\n  function injectIntoString(string, injection, index) {\n    return string.substr(0, index) + injection + string.substr(index);\n  }\n\n  exports.trim = trim;\n  exports.trimLeft = trimLeft;\n  exports.underscore = underscore;\n  exports.sanitizeWhitespace = sanitizeWhitespace;\n  exports.injectIntoString = injectIntoString;\n});"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;","file":"content-kit-editor.js"}